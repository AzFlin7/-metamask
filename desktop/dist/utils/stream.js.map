{"version":3,"file":"stream.js","sourceRoot":"","sources":["../../src/utils/stream.ts"],"names":[],"mappings":";;;AAAA,mCAAoD;AACpD,4CAAmD;AAE5C,MAAM,cAAc,GAAG,CAC5B,MAAgB,EAChB,MAAkC,EAClC,EAAE,kBAAkB,GAAG,KAAK,EAAE,GAAG,EAAE,EACvB,EAAE;IACd,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;QAC7B,MAAM,QAAQ,GAAG,KAAK,EAAE,IAAO,EAAE,EAAE;YACjC,MAAM,OAAO,GAAG,MAAM,CAAC,CAAC,CAAC,MAAM,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAEpE,IAAI,OAAO,EAAE;gBACX,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;gBACxC,OAAO,CAAC,kBAAkB,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;aAC9C;QACH,CAAC,CAAC;QAEF,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;IAC9B,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAjBW,QAAA,cAAc,kBAiBzB;AAEK,MAAM,kBAAkB,GAAG,KAAK,EAAE,MAAgB,EAAE,EAAE;IAC3D,MAAM,IAAA,sBAAc,EAAC,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE,CACpC,OAAO,CAAC,OAAO,CAAC,IAAI,KAAK,+BAAmB,CAAC,CAC9C,CAAC;AACJ,CAAC,CAAC;AAJW,QAAA,kBAAkB,sBAI7B;AAEK,MAAM,WAAW,GAAG,CAAC,MAAgB,EAAE,EAAE;IAC9C,MAAM,CAAC,KAAK,CAAC,+BAAmB,CAAC,CAAC;AACpC,CAAC,CAAC;AAFW,QAAA,WAAW,eAEtB;AAEK,MAAM,eAAe,GAAG,CAC7B,MAAgB,EAChB,QAA6B,EAC7B,EAAE;IACF,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAS,EAAE,EAAE;QAC9B,IAAI,IAAI,KAAK,+BAAmB,EAAE;YAChC,OAAO;SACR;QAED,QAAQ,CAAC,IAAI,CAAC,CAAC;IACjB,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAXW,QAAA,eAAe,mBAW1B;AAEF,MAAa,UAAW,SAAQ,eAAM;IAGpC,YAAY,MAAc;QACxB,KAAK,CAAC,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC;QAE5B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QAErB,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAS,EAAE,EAAE;YACnC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACvB,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,SAAS,CAAC,IAAS;QACzB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAClB,CAAC;IAEM,KAAK;QACV,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,MAAM,CACX,GAAQ,EACR,QAAoC,EACpC,EAAc;QAEd,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,QAAQ,EAAE,EAAE,CAAC,CAAC;IACvC,CAAC;CACF;AA5BD,gCA4BC","sourcesContent":["import { Duplex, Readable, Writable } from 'stream';\nimport { MESSAGE_ACKNOWLEDGE } from '../constants';\n\nexport const waitForMessage = <T>(\n  stream: Readable,\n  filter?: (data: T) => Promise<any>,\n  { returnFilterOutput = false } = {},\n): Promise<T> => {\n  return new Promise((resolve) => {\n    const listener = async (data: T) => {\n      const isMatch = filter ? await filter(data) : Promise.resolve(true);\n\n      if (isMatch) {\n        stream.removeListener('data', listener);\n        resolve(returnFilterOutput ? isMatch : data);\n      }\n    };\n\n    stream.on('data', listener);\n  });\n};\n\nexport const waitForAcknowledge = async (stream: Readable) => {\n  await waitForMessage(stream, (data) =>\n    Promise.resolve(data === MESSAGE_ACKNOWLEDGE),\n  );\n};\n\nexport const acknowledge = (stream: Writable) => {\n  stream.write(MESSAGE_ACKNOWLEDGE);\n};\n\nexport const addDataListener = (\n  stream: Readable,\n  listener: (data: any) => void,\n) => {\n  stream.on('data', (data: any) => {\n    if (data === MESSAGE_ACKNOWLEDGE) {\n      return;\n    }\n\n    listener(data);\n  });\n};\n\nexport class DuplexCopy extends Duplex {\n  private stream: Duplex;\n\n  constructor(stream: Duplex) {\n    super({ objectMode: true });\n\n    this.stream = stream;\n\n    this.stream.on('data', (data: any) => {\n      this.onMessage(data);\n    });\n  }\n\n  private onMessage(data: any) {\n    this.push(data);\n  }\n\n  public _read() {\n    return null;\n  }\n\n  public _write(\n    msg: any,\n    encoding: BufferEncoding | undefined,\n    cb: () => void,\n  ) {\n    this.stream.write(msg, encoding, cb);\n  }\n}\n"]}