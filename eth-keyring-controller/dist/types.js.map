{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import type {\n  DetailedDecryptResult,\n  DetailedEncryptionResult,\n  EncryptionResult,\n  KeyDerivationOptions,\n} from '@metamask/browser-passworder';\nimport type { EthKeyring } from '@metamask/keyring-api';\nimport type { Json } from '@metamask/utils';\n\nexport type KeyringControllerArgs = {\n  keyringBuilders?: { (): EthKeyring<Json>; type: string }[];\n  initState?: KeyringControllerPersistentState;\n} & (\n  | { encryptor?: ExportableKeyEncryptor; cacheEncryptionKey: true }\n  | {\n      encryptor?: GenericEncryptor | ExportableKeyEncryptor;\n      cacheEncryptionKey: false;\n    }\n);\n\nexport type KeyringObject = {\n  type: string;\n  accounts: string[];\n};\n\nexport type KeyringControllerPersistentState = {\n  vault?: string;\n};\n\nexport type KeyringControllerState = {\n  keyrings: KeyringObject[];\n  isUnlocked: boolean;\n} & (\n  | { encryptionKey: string; encryptionSalt: string }\n  | {\n      encryptionKey?: never;\n      encryptionSalt?: never;\n    }\n);\n\nexport type SerializedKeyring = {\n  type: string;\n  data: Json;\n};\n\n/**\n * A generic encryptor interface that supports encrypting and decrypting\n * serializable data with a password.\n */\nexport type GenericEncryptor = {\n  /**\n   * Encrypts the given object with the given password.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encrypted string.\n   */\n  encrypt: (password: string, object: Json) => Promise<string>;\n  /**\n   * Decrypts the given encrypted string with the given password.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decrypt: (password: string, encryptedString: string) => Promise<unknown>;\n  /**\n   * Optional vault migration helper. Checks if the provided vault is up to date\n   * with the desired encryption algorithm.\n   *\n   * @param vault - The encrypted string to check.\n   * @param targetDerivationParams - The desired target derivation params.\n   * @returns The updated encrypted string.\n   */\n  isVaultUpdated?: (\n    vault: string,\n    targetDerivationParams?: KeyDerivationOptions,\n  ) => boolean;\n};\n\n/**\n * An encryptor interface that supports encrypting and decrypting\n * serializable data with a password, and exporting and importing keys.\n */\nexport type ExportableKeyEncryptor = GenericEncryptor & {\n  /**\n   * Encrypts the given object with the given encryption key.\n   *\n   * @param key - The encryption key to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encryption result.\n   */\n  encryptWithKey: (key: unknown, object: Json) => Promise<EncryptionResult>;\n  /**\n   * Encrypts the given object with the given password, and returns the\n   * encryption result and the exported key string.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @param salt - The optional salt to use for encryption.\n   * @returns The encrypted string and the exported key string.\n   */\n  encryptWithDetail: (\n    password: string,\n    object: Json,\n    salt?: string,\n  ) => Promise<DetailedEncryptionResult>;\n  /**\n   * Decrypts the given encrypted string with the given encryption key.\n   *\n   * @param key - The encryption key to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decryptWithKey: (key: unknown, encryptedString: string) => Promise<unknown>;\n  /**\n   * Decrypts the given encrypted string with the given password, and returns\n   * the decrypted object and the salt and exported key string used for\n   * encryption.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object and the salt and exported key string used for\n   * encryption.\n   */\n  decryptWithDetail: (\n    password: string,\n    encryptedString: string,\n  ) => Promise<DetailedDecryptResult>;\n  /**\n   * Generates an encryption key from exported key string.\n   *\n   * @param key - The exported key string.\n   * @returns The encryption key.\n   */\n  importKey: (key: string) => Promise<unknown>;\n};\n"]}