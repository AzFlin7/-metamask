{"version":3,"sources":["../../../src/restricted/notify.ts"],"sourcesContent":["import type {\n  PermissionSpecificationBuilder,\n  RestrictedMethodOptions,\n  ValidPermissionSpecification,\n} from '@metamask/permission-controller';\nimport { PermissionType, SubjectType } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport { NotificationType } from '@metamask/snaps-sdk';\nimport type {\n  NotifyParams,\n  NotifyResult,\n  EnumToUnion,\n} from '@metamask/snaps-sdk';\nimport { validateTextLinks } from '@metamask/snaps-utils';\nimport type { NonEmptyArray } from '@metamask/utils';\nimport { isObject } from '@metamask/utils';\n\nimport { type MethodHooksObject } from '../utils';\n\nconst methodName = 'snap_notify';\n\nexport type NotificationArgs = {\n  /**\n   * Enum type to determine notification type.\n   */\n  type: EnumToUnion<NotificationType>;\n\n  /**\n   * A message to show on the notification.\n   */\n  message: string;\n};\n\nexport type NotifyMethodHooks = {\n  /**\n   * @param snapId - The ID of the Snap that created the notification.\n   * @param args - The notification arguments.\n   */\n  showNativeNotification: (\n    snapId: string,\n    args: NotificationArgs,\n  ) => Promise<null>;\n\n  /**\n   * @param snapId - The ID of the Snap that created the notification.\n   * @param args - The notification arguments.\n   */\n  showInAppNotification: (\n    snapId: string,\n    args: NotificationArgs,\n  ) => Promise<null>;\n\n  isOnPhishingList: (url: string) => boolean;\n\n  maybeUpdatePhishingList: () => Promise<void>;\n};\n\ntype SpecificationBuilderOptions = {\n  allowedCaveats?: Readonly<NonEmptyArray<string>> | null;\n  methodHooks: NotifyMethodHooks;\n};\n\ntype Specification = ValidPermissionSpecification<{\n  permissionType: PermissionType.RestrictedMethod;\n  targetName: typeof methodName;\n  methodImplementation: ReturnType<typeof getImplementation>;\n  allowedCaveats: Readonly<NonEmptyArray<string>> | null;\n}>;\n\n/**\n * The specification builder for the `snap_notify` permission.\n * `snap_notify` allows snaps to send multiple types of notifications to its users.\n *\n * @param options - The specification builder options.\n * @param options.allowedCaveats - The optional allowed caveats for the permission.\n * @param options.methodHooks - The RPC method hooks needed by the method implementation.\n * @returns The specification for the `snap_notify` permission.\n */\nexport const specificationBuilder: PermissionSpecificationBuilder<\n  PermissionType.RestrictedMethod,\n  SpecificationBuilderOptions,\n  Specification\n> = ({ allowedCaveats = null, methodHooks }: SpecificationBuilderOptions) => {\n  return {\n    permissionType: PermissionType.RestrictedMethod,\n    targetName: methodName,\n    allowedCaveats,\n    methodImplementation: getImplementation(methodHooks),\n    subjectTypes: [SubjectType.Snap],\n  };\n};\n\nconst methodHooks: MethodHooksObject<NotifyMethodHooks> = {\n  showNativeNotification: true,\n  showInAppNotification: true,\n  isOnPhishingList: true,\n  maybeUpdatePhishingList: true,\n};\n\nexport const notifyBuilder = Object.freeze({\n  targetName: methodName,\n  specificationBuilder,\n  methodHooks,\n} as const);\n\n/**\n * Builds the method implementation for `snap_notify`.\n *\n * @param hooks - The RPC method hooks.\n * @param hooks.showNativeNotification - A function that shows a native browser notification.\n * @param hooks.showInAppNotification - A function that shows a notification in the MetaMask UI.\n * @param hooks.isOnPhishingList - A function that checks for links against the phishing list.\n * @param hooks.maybeUpdatePhishingList - A function that updates the phishing list if needed.\n * @returns The method implementation which returns `null` on success.\n * @throws If the params are invalid.\n */\nexport function getImplementation({\n  showNativeNotification,\n  showInAppNotification,\n  isOnPhishingList,\n  maybeUpdatePhishingList,\n}: NotifyMethodHooks) {\n  return async function implementation(\n    args: RestrictedMethodOptions<NotifyParams>,\n  ): Promise<NotifyResult> {\n    const {\n      params,\n      context: { origin },\n    } = args;\n\n    const validatedParams = getValidatedParams(params);\n\n    await maybeUpdatePhishingList();\n\n    validateTextLinks(validatedParams.message, isOnPhishingList);\n\n    switch (validatedParams.type) {\n      case NotificationType.Native:\n        return await showNativeNotification(origin, validatedParams);\n      case NotificationType.InApp:\n        return await showInAppNotification(origin, validatedParams);\n      default:\n        throw rpcErrors.invalidParams({\n          message: 'Must specify a valid notification \"type\".',\n        });\n    }\n  };\n}\n\n/**\n * Validates the notify method `params` and returns them cast to the correct\n * type. Throws if validation fails.\n *\n * @param params - The unvalidated params object from the method request.\n * @returns The validated method parameter object.\n */\nexport function getValidatedParams(params: unknown): NotifyParams {\n  if (!isObject(params)) {\n    throw rpcErrors.invalidParams({\n      message: 'Expected params to be a single object.',\n    });\n  }\n\n  const { type, message } = params;\n\n  if (\n    !type ||\n    typeof type !== 'string' ||\n    !Object.values(NotificationType).includes(type as NotificationType)\n  ) {\n    throw rpcErrors.invalidParams({\n      message: 'Must specify a valid notification \"type\".',\n    });\n  }\n\n  // Set to the max message length on a Mac notification for now.\n  if (!message || typeof message !== 'string' || message.length >= 50) {\n    throw rpcErrors.invalidParams({\n      message:\n        'Must specify a non-empty string \"message\" less than 50 characters long.',\n    });\n  }\n\n  return params as NotificationArgs;\n}\n"],"names":["PermissionType","SubjectType","rpcErrors","NotificationType","validateTextLinks","isObject","methodName","specificationBuilder","allowedCaveats","methodHooks","permissionType","RestrictedMethod","targetName","methodImplementation","getImplementation","subjectTypes","Snap","showNativeNotification","showInAppNotification","isOnPhishingList","maybeUpdatePhishingList","notifyBuilder","Object","freeze","implementation","args","params","context","origin","validatedParams","getValidatedParams","message","type","Native","InApp","invalidParams","values","includes","length"],"mappings":"AAKA,SAASA,cAAc,EAAEC,WAAW,QAAQ,kCAAkC;AAC9E,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,gBAAgB,QAAQ,sBAAsB;AAMvD,SAASC,iBAAiB,QAAQ,wBAAwB;AAE1D,SAASC,QAAQ,QAAQ,kBAAkB;AAI3C,MAAMC,aAAa;AAkDnB;;;;;;;;CAQC,GACD,OAAO,MAAMC,uBAIT,CAAC,EAAEC,iBAAiB,IAAI,EAAEC,WAAW,EAA+B;IACtE,OAAO;QACLC,gBAAgBV,eAAeW,gBAAgB;QAC/CC,YAAYN;QACZE;QACAK,sBAAsBC,kBAAkBL;QACxCM,cAAc;YAACd,YAAYe,IAAI;SAAC;IAClC;AACF,EAAE;AAEF,MAAMP,cAAoD;IACxDQ,wBAAwB;IACxBC,uBAAuB;IACvBC,kBAAkB;IAClBC,yBAAyB;AAC3B;AAEA,OAAO,MAAMC,gBAAgBC,OAAOC,MAAM,CAAC;IACzCX,YAAYN;IACZC;IACAE;AACF,GAAY;AAEZ;;;;;;;;;;CAUC,GACD,OAAO,SAASK,kBAAkB,EAChCG,sBAAsB,EACtBC,qBAAqB,EACrBC,gBAAgB,EAChBC,uBAAuB,EACL;IAClB,OAAO,eAAeI,eACpBC,IAA2C;QAE3C,MAAM,EACJC,MAAM,EACNC,SAAS,EAAEC,MAAM,EAAE,EACpB,GAAGH;QAEJ,MAAMI,kBAAkBC,mBAAmBJ;QAE3C,MAAMN;QAENhB,kBAAkByB,gBAAgBE,OAAO,EAAEZ;QAE3C,OAAQU,gBAAgBG,IAAI;YAC1B,KAAK7B,iBAAiB8B,MAAM;gBAC1B,OAAO,MAAMhB,uBAAuBW,QAAQC;YAC9C,KAAK1B,iBAAiB+B,KAAK;gBACzB,OAAO,MAAMhB,sBAAsBU,QAAQC;YAC7C;gBACE,MAAM3B,UAAUiC,aAAa,CAAC;oBAC5BJ,SAAS;gBACX;QACJ;IACF;AACF;AAEA;;;;;;CAMC,GACD,OAAO,SAASD,mBAAmBJ,MAAe;IAChD,IAAI,CAACrB,SAASqB,SAAS;QACrB,MAAMxB,UAAUiC,aAAa,CAAC;YAC5BJ,SAAS;QACX;IACF;IAEA,MAAM,EAAEC,IAAI,EAAED,OAAO,EAAE,GAAGL;IAE1B,IACE,CAACM,QACD,OAAOA,SAAS,YAChB,CAACV,OAAOc,MAAM,CAACjC,kBAAkBkC,QAAQ,CAACL,OAC1C;QACA,MAAM9B,UAAUiC,aAAa,CAAC;YAC5BJ,SAAS;QACX;IACF;IAEA,+DAA+D;IAC/D,IAAI,CAACA,WAAW,OAAOA,YAAY,YAAYA,QAAQO,MAAM,IAAI,IAAI;QACnE,MAAMpC,UAAUiC,aAAa,CAAC;YAC5BJ,SACE;QACJ;IACF;IAEA,OAAOL;AACT"}