{"version":3,"sources":["../src/create-auto-managed-network-client.ts"],"names":[],"mappings":";;;;;AAaA,IAAM,2BAA2B;AAkCjC,IAAM,uBAAuB,EAAE,mBAAmB,KAAK;AAgBhD,SAAS,+BAGd,4BACyC;AACzC,MAAI;AAEJ,QAAM,gBAAgB,IAAI,MAAM,sBAAsB;AAAA;AAAA;AAAA,IAGpD,IAAI,SAAc,cAA2B,UAAmB;AAC9D,UAAI,iBAAiB,0BAA0B;AAC7C,eAAO,eAAe;AAAA,MACxB;AAEA,wCAAkB,oBAAoB,0BAA0B;AAChE,UAAI,kBAAkB,QAAW;AAC/B,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AACA,YAAM,EAAE,SAAS,IAAI;AAErB,UAAI,gBAAgB,UAAU;AAG5B,cAAM,QAAQ,SAAS,YAAqC;AAC5D,YAAI,OAAO,UAAU,YAAY;AAM/B,iBAAO,YAA4B,MAAa;AAI9C,mBAAO,MAAM,MAAM,SAAS,WAAW,WAAW,MAAM,IAAI;AAAA,UAC9D;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAEA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA,IAIA,IAAI,SAAc,cAA2B;AAC3C,UAAI,iBAAiB,0BAA0B;AAC7C,eAAO;AAAA,MACT;AACA,wCAAkB,oBAAoB,0BAA0B;AAChE,YAAM,EAAE,SAAS,IAAI;AACrB,aAAO,gBAAgB;AAAA,IACzB;AAAA,EACF,CAAC;AAED,QAAM,oBAA6D,IAAI;AAAA,IACrE;AAAA,IACA;AAAA;AAAA;AAAA,MAGE,IAAI,SAAc,cAA2B,UAAmB;AAC9D,YAAI,iBAAiB,0BAA0B;AAC7C,iBAAO,eAAe;AAAA,QACxB;AAEA,0CAAkB,oBAAoB,0BAA0B;AAChE,YAAI,kBAAkB,QAAW;AAC/B,gBAAM,IAAI;AAAA,YACR;AAAA,UACF;AAAA,QACF;AACA,cAAM,EAAE,aAAa,IAAI;AAEzB,YAAI,gBAAgB,cAAc;AAGhC,gBAAM,QAAQ,aAAa,YAAyC;AACpE,cAAI,OAAO,UAAU,YAAY;AAM/B,mBAAO,YAA4B,MAAa;AAI9C,qBAAO,MAAM,MAAM,SAAS,WAAW,eAAe,MAAM,IAAI;AAAA,YAClE;AAAA,UACF;AACA,iBAAO;AAAA,QACT;AAEA,eAAO;AAAA,MACT;AAAA;AAAA;AAAA,MAIA,IAAI,SAAc,cAA2B;AAC3C,YAAI,iBAAiB,0BAA0B;AAC7C,iBAAO;AAAA,QACT;AACA,0CAAkB,oBAAoB,0BAA0B;AAChE,cAAM,EAAE,aAAa,IAAI;AACzB,eAAO,gBAAgB;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAEA,QAAM,UAAU,MAAM;AACpB,mBAAe,QAAQ;AAAA,EACzB;AAEA,SAAO;AAAA,IACL,eAAe;AAAA,IACf,UAAU;AAAA,IACV,cAAc;AAAA,IACd;AAAA,EACF;AACF","sourcesContent":["import type { NetworkClient } from './create-network-client';\nimport { createNetworkClient } from './create-network-client';\nimport type {\n  BlockTracker,\n  NetworkClientConfiguration,\n  Provider,\n} from './types';\n\n/**\n * The name of the method on both the provider and block tracker proxy which can\n * be used to get the underlying provider or block tracker from the network\n * client, when it is initialized.\n */\nconst REFLECTIVE_PROPERTY_NAME = '__target__';\n\n/**\n * Represents a proxy object which wraps a target object. As a proxy, it allows\n * for accessing and setting all of the properties that the target object\n * supports, but also supports an extra propertyName (`__target__`) to access\n * the target itself.\n *\n * @template Type - The type of the target object. It is assumed that this type\n * will be constant even when the target is swapped.\n */\nexport type ProxyWithAccessibleTarget<TargetType> = TargetType & {\n  [REFLECTIVE_PROPERTY_NAME]: TargetType;\n};\n\n/**\n * An object that provides the same interface as a network client but where the\n * network client is not initialized until either the provider or block tracker\n * is first accessed.\n */\nexport type AutoManagedNetworkClient<\n  Configuration extends NetworkClientConfiguration,\n> = {\n  configuration: Configuration;\n  provider: ProxyWithAccessibleTarget<Provider>;\n  blockTracker: ProxyWithAccessibleTarget<BlockTracker>;\n  destroy: () => void;\n};\n\n/**\n * By default, the provider and block provider proxies will point to nothing.\n * This is impossible when using the Proxy API, as the target object has to be\n * something, so this object represents that \"something\".\n */\nconst UNINITIALIZED_TARGET = { __UNINITIALIZED__: true };\n\n/**\n * This function creates two proxies, one that wraps a provider and another that\n * wraps a block tracker. These proxies are unique in that both will be \"empty\"\n * at first; that is, neither will point to a functional provider or block\n * tracker. Instead, as soon as a method or event is accessed on either object\n * that requires a network request to function, a network client is created on\n * the fly and the method or event in question is then forwarded to whichever\n * part of the network client is serving as the receiver. The network client is\n * then cached for subsequent usages.\n *\n * @param networkClientConfiguration - The configuration object that will be\n * used to instantiate the network client when it is needed.\n * @returns The auto-managed network client.\n */\nexport function createAutoManagedNetworkClient<\n  Configuration extends NetworkClientConfiguration,\n>(\n  networkClientConfiguration: Configuration,\n): AutoManagedNetworkClient<Configuration> {\n  let networkClient: NetworkClient | undefined;\n\n  const providerProxy = new Proxy(UNINITIALIZED_TARGET, {\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(_target: any, propertyName: PropertyKey, receiver: unknown) {\n      if (propertyName === REFLECTIVE_PROPERTY_NAME) {\n        return networkClient?.provider;\n      }\n\n      networkClient ??= createNetworkClient(networkClientConfiguration);\n      if (networkClient === undefined) {\n        throw new Error(\n          \"It looks like `createNetworkClient` didn't return anything. Perhaps it's being mocked?\",\n        );\n      }\n      const { provider } = networkClient;\n\n      if (propertyName in provider) {\n        // Typecast: We know that `[propertyName]` is a propertyName on\n        // `provider`.\n        const value = provider[propertyName as keyof typeof provider];\n        if (typeof value === 'function') {\n          // Ensure that the method on the provider is called with `this` as\n          // the target, *not* the proxy (which happens by default) —\n          // this allows private properties to be accessed\n          // TODO: Replace `any` with type\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          return function (this: unknown, ...args: any[]) {\n            // @ts-expect-error We don't care that `this` may not be compatible\n            // with the signature of the method being called, as technically\n            // it can be anything.\n            return value.apply(this === receiver ? provider : this, args);\n          };\n        }\n        return value;\n      }\n\n      return undefined;\n    },\n\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    has(_target: any, propertyName: PropertyKey) {\n      if (propertyName === REFLECTIVE_PROPERTY_NAME) {\n        return true;\n      }\n      networkClient ??= createNetworkClient(networkClientConfiguration);\n      const { provider } = networkClient;\n      return propertyName in provider;\n    },\n  });\n\n  const blockTrackerProxy: ProxyWithAccessibleTarget<BlockTracker> = new Proxy(\n    UNINITIALIZED_TARGET,\n    {\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      get(_target: any, propertyName: PropertyKey, receiver: unknown) {\n        if (propertyName === REFLECTIVE_PROPERTY_NAME) {\n          return networkClient?.blockTracker;\n        }\n\n        networkClient ??= createNetworkClient(networkClientConfiguration);\n        if (networkClient === undefined) {\n          throw new Error(\n            \"It looks like createNetworkClient returned undefined. Perhaps it's mocked?\",\n          );\n        }\n        const { blockTracker } = networkClient;\n\n        if (propertyName in blockTracker) {\n          // Typecast: We know that `[propertyName]` is a propertyName on\n          // `provider`.\n          const value = blockTracker[propertyName as keyof typeof blockTracker];\n          if (typeof value === 'function') {\n            // Ensure that the method on the provider is called with `this` as\n            // the target, *not* the proxy (which happens by default) —\n            // this allows private properties to be accessed\n            // TODO: Replace `any` with type\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return function (this: unknown, ...args: any[]) {\n              // @ts-expect-error We don't care that `this` may not be\n              // compatible with the signature of the method being called, as\n              // technically it can be anything.\n              return value.apply(this === receiver ? blockTracker : this, args);\n            };\n          }\n          return value;\n        }\n\n        return undefined;\n      },\n\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      has(_target: any, propertyName: PropertyKey) {\n        if (propertyName === REFLECTIVE_PROPERTY_NAME) {\n          return true;\n        }\n        networkClient ??= createNetworkClient(networkClientConfiguration);\n        const { blockTracker } = networkClient;\n        return propertyName in blockTracker;\n      },\n    },\n  );\n\n  const destroy = () => {\n    networkClient?.destroy();\n  };\n\n  return {\n    configuration: networkClientConfiguration,\n    provider: providerProxy,\n    blockTracker: blockTrackerProxy,\n    destroy,\n  };\n}\n"]}