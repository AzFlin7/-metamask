{"version":3,"file":"createEventEmitterProxy.js","sourceRoot":"","sources":["../src/createEventEmitterProxy.ts"],"names":[],"mappings":"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","sourcesContent":["import type { SwappableProxy } from './types';\n\n/**\n * A portion of Node's EventEmitter interface that `createEventEmitterProxy`\n * expects its `target` to support.\n */\ntype EventEmitterLike = {\n  eventNames: () => (string | symbol)[];\n  // The `rawListeners` method returns an array of `Function`s.\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  rawListeners(eventName: string | symbol): Function[];\n  removeAllListeners(event?: string | symbol): EventEmitterLike;\n  on(name: string, handler: (...args: unknown[]) => unknown): void;\n  prependListener(name: string, handler: (...args: unknown[]) => unknown): void;\n  addListener(name: string, handler: (...args: unknown[]) => unknown): void;\n  off(name: string, handler: (...args: unknown[]) => unknown): void;\n  once(name: string, handler: (...args: unknown[]) => unknown): void;\n};\n\ntype EventDetails = {\n  /**\n   * The name of the event.\n   */\n  name: string;\n  /**\n   * The (wrapped) method given to handle the event. The wrapping will handle\n   * updating the internal event handler list used to migrate events.\n   */\n  handler: (...args: unknown[]) => unknown;\n  /**\n   * The original method given to handle the event.\n   */\n  unwrappedHandler: (...args: unknown[]) => unknown;\n  /**\n   * Name of the method used to add the event.\n   */\n  addedWith: 'on' | 'prependListener' | 'addListener' | 'once';\n  /**\n   * Determines if the event should be migrated or not when using setTarget\n   */\n  filtered: boolean;\n};\n\nconst filterNoop = () => true;\nconst internalEvents: (string | symbol)[] = ['newListener', 'removeListener'];\nconst externalEventFilter = (name: string | symbol) =>\n  !internalEvents.includes(name);\n\n/**\n * Creates a proxy object that initially points to the given object but whose\n * target can be substituted with another object later using its `setTarget`\n * method. In addition, when the target is changed, event listeners which have\n * been attached to the target will be detached and migrated to the new target.\n * Note that events attached to the eventEmitter (not the proxy) will not be\n * migrated or removed when calling `setTarget`.\n *\n * @template Type - An object that implements at least `eventNames`, `rawListeners`,\n * and `removeAllListeners` from [Node's EventEmitter interface](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/events.d.ts).\n * @param initialTarget - The initial object you want to wrap.\n * @param opts - The options.\n * @param opts.eventFilter - Usually, listeners for all events will be migrated\n * from old targets to new targets, but this function can be used to select\n * which events you want to migrate. If you pass `'skipInternal'`, then\n * `newListener` and `removeListener` will be excluded.\n * @returns The proxy object.\n */\nexport function createEventEmitterProxy<Type extends EventEmitterLike>(\n  initialTarget: Type,\n  {\n    eventFilter: givenEventFilter = filterNoop,\n  }: {\n    eventFilter?: ((eventName: string | symbol) => boolean) | 'skipInternal';\n  } = {},\n): SwappableProxy<Type> {\n  // parse options\n  const eventFilter =\n    givenEventFilter === 'skipInternal'\n      ? externalEventFilter\n      : givenEventFilter;\n\n  if (typeof eventFilter !== 'function') {\n    throw new Error('createEventEmitterProxy - Invalid eventFilter');\n  }\n\n  let eventsAdded: EventDetails[] = [];\n  let target = initialTarget;\n\n  /**\n   * Changes the object that the proxy wraps.\n   *\n   * @param newTarget - The new object.\n   */\n  let setTarget = (newTarget: Type) => {\n    const oldTarget = target;\n    target = newTarget;\n    // migrate listeners\n    eventsAdded.forEach(({ name, handler, addedWith, filtered }) => {\n      if (!filtered) {\n        newTarget[addedWith](name, handler);\n      }\n      oldTarget.off(name, handler);\n    });\n  };\n\n  const removeEvent = (name: string, handler: EventDetails['handler']) => {\n    eventsAdded = eventsAdded.filter(\n      (addedEvent) =>\n        name !== addedEvent.name ||\n        (handler !== addedEvent.handler &&\n          handler !== addedEvent.unwrappedHandler),\n    );\n  };\n\n  const proxy = new Proxy<Type>(target, {\n    // @ts-expect-error We are providing a different signature than the `get`\n    // option as defined in the Proxy interface; specifically, we've limited\n    // `name` so that it can't be arbitrary. Theoretically this is inaccurate,\n    // but because we've constrained what the `target` can be, that effectively\n    // constraints the allowed properties as well.\n    get(\n      _target: Type,\n      name: 'setTarget' | keyof Type,\n      receiver: SwappableProxy<Type>,\n    ): unknown {\n      // override `setTarget` access\n      if (name === 'setTarget') {\n        return setTarget;\n      }\n\n      const value = target[name];\n\n      if (typeof value === 'function') {\n        return function (this: unknown, ...args: any[]) {\n          const unwrappedHandler = args[1];\n          if (name === 'once') {\n            const wrappedHandler = (...handlerArgs: any[]) => {\n              removeEvent(args[0], wrappedHandler);\n              return unwrappedHandler(...handlerArgs);\n            };\n            args[1] = wrappedHandler;\n          }\n          if (\n            name === 'on' ||\n            name === 'addListener' ||\n            name === 'prependListener' ||\n            name === 'once'\n          ) {\n            eventsAdded.push({\n              addedWith: name,\n              name: args[0],\n              unwrappedHandler,\n              handler: args[1],\n              filtered: !eventFilter(args[0]),\n            });\n          } else if (name === 'off' || name === 'removeListener') {\n            const eventAdded = eventsAdded.find(\n              ({ name: addedName, unwrappedHandler: addedUnwrappedHandler }) =>\n                addedName === args[0] && addedUnwrappedHandler === args[1],\n            );\n            // this should never really happen unless you've called removeListener for something that is already not there.\n            if (eventAdded === undefined) {\n              return target;\n            }\n            removeEvent(args[0], args[1]);\n            args[1] = eventAdded.handler;\n          }\n\n          // This function may be either bound to something or nothing.\n          // eslint-disable-next-line no-invalid-this\n          return value.apply(this === receiver ? target : this, args);\n        };\n      }\n      return value;\n    },\n    // @ts-expect-error We are providing a different signature than the `set`\n    // option as defined in the Proxy interface; specifically, we've limited\n    // `name` so that it can't be arbitrary. Theoretically this is inaccurate,\n    // but because we've constrained what the `target` can be, that effectively\n    // constraints the allowed properties as well.\n    set(\n      _target: Type,\n      name: 'setTarget' | keyof Type,\n      // This setter takes either the `setTarget` function, the value of a a\n      // known property of Type, or something else. However, the type of this value\n      // depends on the property given, and getting TypeScript to figure this\n      // out is seriously difficult. It doesn't ultimately matter, however,\n      // as the setter is not visible to consumers.\n      value: any,\n    ): boolean {\n      // allow `setTarget` overrides\n      if (name === 'setTarget') {\n        setTarget = value;\n        return true;\n      }\n      target[name] = value;\n      return true;\n    },\n  });\n\n  // Typecast: The return type of the Proxy constructor is defined to be the\n  // same as the provided type parameter. This is naive, however, as it does not\n  // account for the proxy trapping and responding to arbitrary properties; in\n  // our case, we trap `setTarget`, so this means our final proxy object\n  // contains a property on top of the underlying object's properties.\n  return proxy as SwappableProxy<Type>;\n}\n"]}