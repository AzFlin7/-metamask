{"version":3,"sources":["../src/utils/gas-fees.ts"],"sourcesContent":["import {\n  gweiDecToWEIBN,\n  ORIGIN_METAMASK,\n  query,\n  toHex,\n} from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport {\n  GAS_ESTIMATE_TYPES,\n  type GasFeeState,\n} from '@metamask/gas-fee-controller';\nimport type { Provider } from '@metamask/network-controller';\nimport type { TransactionParams } from '@metamask/transaction-controller';\nimport { UserFeeLevel } from '@metamask/transaction-controller';\nimport type { Hex } from '@metamask/utils';\nimport { add0x } from '@metamask/utils';\n\nimport { EMPTY_BYTES } from '../constants';\nimport { createModuleLogger, projectLogger } from '../logger';\nimport type { UserOperation, UserOperationMetadata } from '../types';\nimport type { AddUserOperationRequest } from '../UserOperationController';\n\nconst log = createModuleLogger(projectLogger, 'gas-fees');\n\nexport type UpdateGasFeesRequest = {\n  getGasFeeEstimates: () => Promise<GasFeeState>;\n  metadata: UserOperationMetadata;\n  originalRequest: AddUserOperationRequest;\n  provider: Provider;\n  transaction?: TransactionParams;\n};\n\ntype SuggestedGasFees = {\n  maxFeePerGas?: string;\n  maxPriorityFeePerGas?: string;\n};\n\n/**\n * Populates the gas fee properties for a user operation.\n * @param request - The request to update the gas fees.\n * @param request.getGasFeeEstimates - A callback to get gas fee estimates.\n * @param request.metadata - The metadata for the user operation.\n * @param request.originalRequest - The original request to add the user operation.\n * @param request.provider - A provider to query the network.\n * @param request.transaction - The transaction that created the user operation.\n */\nexport async function updateGasFees(request: UpdateGasFeesRequest) {\n  const { metadata, originalRequest, transaction } = request;\n  const { userOperation } = metadata;\n  let suggestedGasFees: SuggestedGasFees | undefined;\n\n  const getGasFeeEstimates = async () => {\n    if (!suggestedGasFees) {\n      suggestedGasFees = await getSuggestedGasFees(request);\n    }\n\n    return suggestedGasFees;\n  };\n\n  userOperation.maxFeePerGas = await getMaxFeePerGas(\n    originalRequest,\n    getGasFeeEstimates,\n    transaction,\n  );\n\n  userOperation.maxPriorityFeePerGas = await getMaxPriorityFeePerGas(\n    originalRequest,\n    getGasFeeEstimates,\n    userOperation,\n    transaction,\n  );\n\n  metadata.userFeeLevel = getUserFeeLevel(\n    metadata,\n    originalRequest,\n    suggestedGasFees,\n    transaction,\n  );\n}\n\n/**\n * Gets the maxFeePerGas for a user operation.\n * @param originalRequest - The original request to add the user operation.\n * @param getGetFasEstimates - A callback to get gas fee estimates.\n * @param transaction - The transaction that created the user operation.\n * @returns The maxFeePerGas for the user operation.\n */\nasync function getMaxFeePerGas(\n  originalRequest: AddUserOperationRequest,\n  getGetFasEstimates: () => Promise<SuggestedGasFees>,\n  transaction?: TransactionParams,\n) {\n  const { maxFeePerGas, maxPriorityFeePerGas } = originalRequest;\n  const { gasPrice } = transaction ?? {};\n\n  if (!isGasFeeEmpty(maxFeePerGas)) {\n    log('Using maxFeePerGas from request', maxFeePerGas);\n    return maxFeePerGas as string;\n  }\n\n  if (isGasFeeEmpty(maxPriorityFeePerGas) && gasPrice) {\n    log('Setting maxFeePerGas to transaction gasPrice', gasPrice);\n    return gasPrice;\n  }\n\n  const { maxFeePerGas: suggestedMaxFeePerGas } = await getGetFasEstimates();\n\n  if (!suggestedMaxFeePerGas) {\n    throw new Error('Failed to get gas fee estimate for maxFeePerGas');\n  }\n\n  log('Using maxFeePerGas from estimate', suggestedMaxFeePerGas);\n\n  return suggestedMaxFeePerGas;\n}\n\n/**\n * Gets the maxPriorityFeePerGas for a user operation.\n * @param originalRequest - The original request to add the user operation.\n * @param getGetFasEstimates - A callback to get gas fee estimates.\n * @param userOperation - The user operation being updated.\n * @param transaction - The transaction that created the user operation.\n * @returns The maxPriorityFeePerGas for the user operation.\n */\nasync function getMaxPriorityFeePerGas(\n  originalRequest: AddUserOperationRequest,\n  getGetFasEstimates: () => Promise<SuggestedGasFees>,\n  userOperation: UserOperation,\n  transaction?: TransactionParams,\n) {\n  const { maxFeePerGas, maxPriorityFeePerGas } = originalRequest;\n  const { gasPrice } = transaction ?? {};\n  const { maxFeePerGas: updatedMaxFeePerGas } = userOperation;\n\n  if (!isGasFeeEmpty(maxPriorityFeePerGas)) {\n    log('Using maxPriorityFeePerGas from request', maxPriorityFeePerGas);\n    return maxPriorityFeePerGas as string;\n  }\n\n  if (isGasFeeEmpty(maxFeePerGas) && gasPrice) {\n    log('Setting maxPriorityFeePerGas to transaction gasPrice', gasPrice);\n    return gasPrice;\n  }\n\n  const { maxPriorityFeePerGas: suggestedMaxPriorityFeePerGas } =\n    await getGetFasEstimates();\n\n  if (suggestedMaxPriorityFeePerGas) {\n    log(\n      'Using maxPriorityFeePerGas from estimate',\n      suggestedMaxPriorityFeePerGas,\n    );\n    return suggestedMaxPriorityFeePerGas;\n  }\n\n  log('Setting maxPriorityFeePerGas to maxFeePerGas', updatedMaxFeePerGas);\n\n  return updatedMaxFeePerGas;\n}\n\n/**\n * Gets the userFeeLevel for a user operation.\n * @param metadata - The metadata for the user operation.\n * @param originalRequest - The original request to add the user operation.\n * @param suggestedGasFees - The suggested gas fees, if any.\n * @param transaction - The transaction that created the user operation.\n * @returns The userFeeLevel for the user operation.\n */\nfunction getUserFeeLevel(\n  metadata: UserOperationMetadata,\n  originalRequest: AddUserOperationRequest,\n  suggestedGasFees?: SuggestedGasFees,\n  transaction?: TransactionParams,\n): UserFeeLevel {\n  const { origin } = metadata;\n  const { maxFeePerGas, maxPriorityFeePerGas } = originalRequest;\n\n  const {\n    maxFeePerGas: suggestedMaxFeePerGas,\n    maxPriorityFeePerGas: suggestedMaxPriorityFeePerGas,\n  } = suggestedGasFees || {};\n\n  if (\n    isGasFeeEmpty(maxFeePerGas) &&\n    isGasFeeEmpty(maxPriorityFeePerGas) &&\n    transaction?.gasPrice\n  ) {\n    return origin === ORIGIN_METAMASK\n      ? UserFeeLevel.CUSTOM\n      : UserFeeLevel.DAPP_SUGGESTED;\n  }\n\n  if (\n    isGasFeeEmpty(maxFeePerGas) &&\n    isGasFeeEmpty(maxPriorityFeePerGas) &&\n    suggestedMaxFeePerGas &&\n    suggestedMaxPriorityFeePerGas\n  ) {\n    return UserFeeLevel.MEDIUM;\n  }\n\n  if (origin === ORIGIN_METAMASK) {\n    return UserFeeLevel.CUSTOM;\n  }\n\n  return UserFeeLevel.DAPP_SUGGESTED;\n}\n\n/**\n * Gets suggested gas fees.\n * @param request - The request to update the gas fees.\n * @param request.getGasFeeEstimates - A callback to get gas fee estimates.\n * @param request.provider - A provider to query the network.\n * @returns The suggested gas fees.\n */\nasync function getSuggestedGasFees(\n  request: UpdateGasFeesRequest,\n): Promise<{ maxFeePerGas?: Hex; maxPriorityFeePerGas?: Hex }> {\n  const { getGasFeeEstimates, provider } = request;\n\n  try {\n    const { gasFeeEstimates, gasEstimateType } = await getGasFeeEstimates();\n\n    if (gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n      /* istanbul ignore next */\n      const {\n        medium: { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = {},\n      } = gasFeeEstimates;\n\n      if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {\n        const values = {\n          maxFeePerGas: gweiDecimalToWeiHex(suggestedMaxFeePerGas),\n          maxPriorityFeePerGas: gweiDecimalToWeiHex(\n            suggestedMaxPriorityFeePerGas,\n          ),\n        };\n\n        log('Using medium values from fee market estimate', values);\n\n        return values;\n      }\n    }\n\n    if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n      const maxFeePerGas = gweiDecimalToWeiHex(gasFeeEstimates.medium);\n\n      log('Using medium value from legacy estimate', maxFeePerGas);\n\n      return {\n        maxFeePerGas,\n      };\n    }\n\n    if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {\n      const maxFeePerGas = gweiDecimalToWeiHex(gasFeeEstimates.gasPrice);\n\n      log('Using gasPrice from estimate', maxFeePerGas);\n\n      return {\n        maxFeePerGas,\n      };\n    }\n  } catch (error) {\n    log('Failed to get estimate', error);\n  }\n\n  const gasPriceDecimal = (await query(new EthQuery(provider), 'gasPrice')) as\n    | number\n    | undefined;\n\n  if (!gasPriceDecimal) {\n    return {};\n  }\n\n  const maxFeePerGas = add0x(gasPriceDecimal.toString(16)) as Hex;\n\n  log('Using gasPrice from network as fallback', maxFeePerGas);\n\n  return { maxFeePerGas };\n}\n\n/**\n * Converts a GWEI decimal string to a WEI hexadecimal string.\n * @param value - The GWEI decimal string to convert.\n * @returns The WEI hexadecimal string.\n */\nfunction gweiDecimalToWeiHex(value: string) {\n  return toHex(gweiDecToWEIBN(value));\n}\n\n/**\n * Checks if a gas fee property is empty.\n * @param value - The gas fee value to check.\n * @returns Whether the gas fee property is empty.\n */\nfunction isGasFeeEmpty(value?: string): boolean {\n  return !value || value === EMPTY_BYTES;\n}\n"],"mappings":"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","names":["maxFeePerGas"]}