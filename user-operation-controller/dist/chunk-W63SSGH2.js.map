{"version":3,"sources":["../src/UserOperationController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  AcceptResultCallbacks,\n  AddApprovalRequest,\n  AddResult,\n} from '@metamask/approval-controller';\nimport type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport { ApprovalType } from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport type { GasFeeState } from '@metamask/gas-fee-controller';\nimport type {\n  KeyringControllerPrepareUserOperationAction,\n  KeyringControllerPatchUserOperationAction,\n  KeyringControllerSignUserOperationAction,\n} from '@metamask/keyring-controller';\nimport type {\n  NetworkControllerGetNetworkClientByIdAction,\n  Provider,\n} from '@metamask/network-controller';\nimport { errorCodes } from '@metamask/rpc-errors';\nimport {\n  determineTransactionType,\n  type TransactionMeta,\n  type TransactionParams,\n  type TransactionType,\n} from '@metamask/transaction-controller';\nimport { add0x } from '@metamask/utils';\nimport EventEmitter from 'events';\nimport type { Patch } from 'immer';\nimport { cloneDeep } from 'lodash';\nimport { v1 as random } from 'uuid';\n\nimport { ADDRESS_ZERO, EMPTY_BYTES, VALUE_ZERO } from './constants';\nimport { Bundler } from './helpers/Bundler';\nimport { PendingUserOperationTracker } from './helpers/PendingUserOperationTracker';\nimport { SnapSmartContractAccount } from './helpers/SnapSmartContractAccount';\nimport { projectLogger as log } from './logger';\nimport type {\n  SmartContractAccount,\n  UserOperation,\n  UserOperationMetadata,\n} from './types';\nimport { UserOperationStatus } from './types';\nimport { updateGas } from './utils/gas';\nimport { updateGasFees } from './utils/gas-fees';\nimport { getTransactionMetadata } from './utils/transaction';\nimport {\n  validateAddUserOperationOptions,\n  validateAddUserOperationRequest,\n  validatePrepareUserOperationResponse,\n  validateSignUserOperationResponse,\n  validateUpdateUserOperationResponse,\n} from './utils/validation';\n\nconst controllerName = 'UserOperationController';\n\nconst stateMetadata = {\n  userOperations: { persist: true, anonymous: false },\n};\n\nconst getDefaultState = () => ({\n  userOperations: {},\n});\n\ntype Events = {\n  'transaction-updated': [metadata: TransactionMeta];\n  'user-operation-added': [metadata: UserOperationMetadata];\n  'user-operation-confirmed': [metadata: UserOperationMetadata];\n  'user-operation-failed': [metadata: UserOperationMetadata, error: Error];\n  [key: `${string}:confirmed`]: [metadata: UserOperationMetadata];\n  [key: `${string}:failed`]: [metadata: UserOperationMetadata, error: Error];\n};\n\nexport type UserOperationControllerEventEmitter = EventEmitter & {\n  on<T extends keyof Events>(\n    eventName: T,\n    listener: (...args: Events[T]) => void,\n  ): UserOperationControllerEventEmitter;\n\n  once<T extends keyof Events>(\n    eventName: T,\n    listener: (...args: Events[T]) => void,\n  ): UserOperationControllerEventEmitter;\n\n  emit<T extends keyof Events>(eventName: T, ...args: Events[T]): boolean;\n};\n\nexport type UserOperationControllerState = {\n  userOperations: Record<string, UserOperationMetadata>;\n};\n\nexport type GetUserOperationState = {\n  type: `${typeof controllerName}:getState`;\n  handler: () => UserOperationControllerState;\n};\n\nexport type UserOperationStateChange = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [UserOperationControllerState, Patch[]];\n};\n\nexport type UserOperationControllerActions =\n  | GetUserOperationState\n  | NetworkControllerGetNetworkClientByIdAction\n  | AddApprovalRequest\n  | KeyringControllerPrepareUserOperationAction\n  | KeyringControllerPatchUserOperationAction\n  | KeyringControllerSignUserOperationAction;\n\nexport type UserOperationControllerEvents = UserOperationStateChange;\n\nexport type UserOperationControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  UserOperationControllerActions,\n  UserOperationControllerEvents,\n  UserOperationControllerActions['type'],\n  UserOperationControllerEvents['type']\n>;\n\nexport type UserOperationControllerOptions = {\n  entrypoint: string;\n  getGasFeeEstimates: () => Promise<GasFeeState>;\n  interval?: number;\n  messenger: UserOperationControllerMessenger;\n  state?: Partial<UserOperationControllerState>;\n};\n\nexport type AddUserOperationRequest = {\n  data?: string;\n  from: string;\n  maxFeePerGas?: string;\n  maxPriorityFeePerGas?: string;\n  to?: string;\n  value?: string;\n};\n\nexport type AddUserOperationSwapOptions = {\n  approvalTxId?: string;\n  destinationTokenAddress?: string;\n  destinationTokenDecimals?: number;\n  destinationTokenSymbol?: string;\n  estimatedBaseFee?: string;\n  sourceTokenSymbol?: string;\n  swapMetaData?: Record<string, unknown>;\n  swapTokenValue?: string;\n};\n\nexport type AddUserOperationOptions = {\n  networkClientId: string;\n  origin: string;\n  requireApproval?: boolean;\n  smartContractAccount?: SmartContractAccount;\n  swaps?: AddUserOperationSwapOptions;\n  type?: TransactionType;\n};\n\nexport type AddUserOperationResponse = {\n  id: string;\n  hash: () => Promise<string | undefined>;\n  transactionHash: () => Promise<string | undefined>;\n};\n\n/**\n * All the objects related to a pending user operation in order to:\n * - Avoid duplicated effort to derive the same properties.\n * - Minimise duplicate arguments in private methods.\n */\ntype UserOperationCache = {\n  chainId: string;\n  metadata: UserOperationMetadata;\n  options: AddUserOperationOptions & {\n    smartContractAccount: SmartContractAccount;\n  };\n  provider: Provider;\n  request: AddUserOperationRequest;\n  transaction?: TransactionParams;\n};\n\n/**\n * Controller for creating and managing the life cycle of user operations.\n */\nexport class UserOperationController extends BaseController<\n  typeof controllerName,\n  UserOperationControllerState,\n  UserOperationControllerMessenger\n> {\n  hub: UserOperationControllerEventEmitter;\n\n  #entrypoint: string;\n\n  #getGasFeeEstimates: () => Promise<GasFeeState>;\n\n  #pendingUserOperationTracker: PendingUserOperationTracker;\n\n  /**\n   * Construct a UserOperationController instance.\n   *\n   * @param options - Controller options.\n   * @param options.entrypoint - Address of the entrypoint contract.\n   * @param options.getGasFeeEstimates - Callback to get gas fee estimates.\n   * @param options.messenger - Restricted controller messenger for the user operation controller.\n   * @param options.state - Initial state to set on the controller.\n   */\n  constructor({\n    entrypoint,\n    getGasFeeEstimates,\n    messenger,\n    state,\n  }: UserOperationControllerOptions) {\n    super({\n      name: controllerName,\n      metadata: stateMetadata,\n      messenger,\n      state: { ...getDefaultState(), ...state },\n    });\n\n    this.hub = new EventEmitter() as UserOperationControllerEventEmitter;\n\n    this.#entrypoint = entrypoint;\n    this.#getGasFeeEstimates = getGasFeeEstimates;\n\n    this.#pendingUserOperationTracker = new PendingUserOperationTracker({\n      getUserOperations: () =>\n        cloneDeep(Object.values(this.state.userOperations)),\n      messenger,\n    });\n\n    this.#addPendingUserOperationTrackerListeners();\n  }\n\n  /**\n   * Create and submit a user operation.\n   *\n   * @param request - Information required to create a user operation.\n   * @param request.data - Data to include in the resulting transaction.\n   * @param request.maxFeePerGas - Maximum fee per gas to pay towards the transaction.\n   * @param request.maxPriorityFeePerGas - Maximum priority fee per gas to pay towards the transaction.\n   * @param request.to - Destination address of the resulting transaction.\n   * @param request.value - Value to include in the resulting transaction.\n   * @param options - Configuration options when creating a user operation.\n   * @param options.networkClientId - ID of the network client used to query the chain.\n   * @param options.origin - Origin of the user operation, such as the hostname of a dApp.\n   * @param options.requireApproval - Whether to require user approval before submitting the user operation. Defaults to true.\n   * @param options.smartContractAccount - Smart contract abstraction to provide the contract specific values such as call data and nonce. Defaults to the current snap account.\n   * @param options.swaps - Swap metadata to record with the user operation.\n   * @param options.type - Type of the transaction.\n   */\n  async addUserOperation(\n    request: AddUserOperationRequest,\n    options: AddUserOperationOptions,\n  ): Promise<AddUserOperationResponse> {\n    validateAddUserOperationRequest(request);\n    validateAddUserOperationOptions(options);\n\n    return await this.#addUserOperation(request, options);\n  }\n\n  /**\n   * Create and submit a user operation equivalent to the provided transaction.\n   *\n   * @param transaction - Transaction to use as the basis for the user operation.\n   * @param options - Configuration options when creating a user operation.\n   * @param options.networkClientId - ID of the network client used to query the chain.\n   * @param options.origin - Origin of the user operation, such as the hostname of a dApp.\n   * @param options.requireApproval - Whether to require user approval before submitting the user operation. Defaults to true.\n   * @param options.smartContractAccount - Smart contract abstraction to provide the contract specific values such as call data and nonce. Defaults to the current snap account.\n   * @param options.swaps - Swap metadata to record with the user operation.\n   * @param options.type - Type of the transaction.\n   */\n  async addUserOperationFromTransaction(\n    transaction: TransactionParams,\n    options: AddUserOperationOptions,\n  ): Promise<AddUserOperationResponse> {\n    validateAddUserOperationOptions(options);\n\n    const { data, from, maxFeePerGas, maxPriorityFeePerGas, to, value } =\n      transaction;\n\n    const request: AddUserOperationRequest = {\n      data: data === '' ? undefined : data,\n      from,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      to,\n      value,\n    };\n\n    validateAddUserOperationRequest(request);\n\n    return await this.#addUserOperation(request, { ...options, transaction });\n  }\n\n  startPollingByNetworkClientId(networkClientId: string): string {\n    return this.#pendingUserOperationTracker.startPollingByNetworkClientId(\n      networkClientId,\n    );\n  }\n\n  async #addUserOperation(\n    request: AddUserOperationRequest,\n    options: AddUserOperationOptions & { transaction?: TransactionParams },\n  ): Promise<AddUserOperationResponse> {\n    log('Adding user operation', { request, options });\n\n    const {\n      networkClientId,\n      origin,\n      smartContractAccount: requestSmartContractAccount,\n      swaps,\n      transaction,\n    } = options;\n\n    const { chainId, provider } = await this.#getProvider(networkClientId);\n\n    const metadata = await this.#createMetadata(\n      chainId,\n      origin,\n      transaction,\n      swaps,\n    );\n\n    const smartContractAccount =\n      requestSmartContractAccount ??\n      new SnapSmartContractAccount(this.messagingSystem);\n\n    const cache: UserOperationCache = {\n      chainId,\n      metadata,\n      options: { ...options, smartContractAccount },\n      provider,\n      request,\n      transaction,\n    };\n\n    const { id } = metadata;\n    let throwError = false;\n\n    const hashValue = (async () => {\n      try {\n        return await this.#prepareAndSubmitUserOperation(cache);\n      } catch (error) {\n        this.#failUserOperation(metadata, error);\n\n        if (throwError) {\n          throw error;\n        }\n\n        return undefined;\n      }\n    })();\n\n    const hash = async () => {\n      throwError = true;\n      return await hashValue;\n    };\n\n    const transactionHash = async () => {\n      await hash();\n\n      const { transactionHash: finalTransactionHash } =\n        await this.#waitForConfirmation(metadata);\n\n      return finalTransactionHash as string;\n    };\n\n    return {\n      id,\n      hash,\n      transactionHash,\n    };\n  }\n\n  async #prepareAndSubmitUserOperation(cache: UserOperationCache) {\n    const { metadata, options } = cache;\n    const { requireApproval, smartContractAccount } = options;\n    let resultCallbacks: AcceptResultCallbacks | undefined;\n\n    try {\n      await this.#prepareUserOperation(cache);\n      await this.#addPaymasterData(metadata, smartContractAccount);\n\n      this.hub.emit('user-operation-added', metadata);\n\n      if (requireApproval !== false) {\n        resultCallbacks = await this.#approveUserOperation(cache);\n      }\n\n      await this.#signUserOperation(metadata, smartContractAccount);\n      await this.#submitUserOperation(metadata);\n\n      resultCallbacks?.success();\n\n      return metadata.hash as string;\n    } catch (error) {\n      /* istanbul ignore next */\n      resultCallbacks?.error(error as Error);\n      throw error;\n    }\n  }\n\n  async #waitForConfirmation(\n    metadata: UserOperationMetadata,\n  ): Promise<UserOperationMetadata> {\n    const { id, hash } = metadata;\n\n    log('Waiting for confirmation', id, hash);\n\n    return new Promise((resolve, reject) => {\n      this.hub.once(`${id}:confirmed`, (finalMetadata) => {\n        resolve(finalMetadata);\n      });\n\n      this.hub.once(`${id}:failed`, (_finalMetadata, error) => {\n        reject(error);\n      });\n    });\n  }\n\n  async #createMetadata(\n    chainId: string,\n    origin: string,\n    transaction?: TransactionParams,\n    swaps?: AddUserOperationSwapOptions,\n  ): Promise<UserOperationMetadata> {\n    const metadata: UserOperationMetadata = {\n      actualGasCost: null,\n      actualGasUsed: null,\n      baseFeePerGas: null,\n      bundlerUrl: null,\n      chainId,\n      error: null,\n      hash: null,\n      id: random(),\n      origin,\n      status: UserOperationStatus.Unapproved,\n      swapsMetadata: swaps\n        ? {\n            approvalTxId: swaps.approvalTxId ?? null,\n            destinationTokenAddress: swaps.destinationTokenAddress ?? null,\n            destinationTokenDecimals: swaps.destinationTokenDecimals ?? null,\n            destinationTokenSymbol: swaps.destinationTokenSymbol ?? null,\n            estimatedBaseFee: swaps.estimatedBaseFee ?? null,\n            sourceTokenSymbol: swaps.sourceTokenSymbol ?? null,\n            swapMetaData: (swaps.swapMetaData as Record<string, never>) ?? null,\n            swapTokenValue: swaps.swapTokenValue ?? null,\n          }\n        : null,\n      time: Date.now(),\n      transactionHash: null,\n      transactionParams: (transaction as Required<TransactionParams>) ?? null,\n      transactionType: null,\n      userFeeLevel: null,\n      userOperation: this.#createEmptyUserOperation(transaction),\n    };\n\n    this.#updateMetadata(metadata);\n\n    log('Added user operation', metadata.id);\n\n    return metadata;\n  }\n\n  async #prepareUserOperation(cache: UserOperationCache) {\n    const { chainId, metadata, options, provider, request, transaction } =\n      cache;\n\n    const { data, from, to, value } = request;\n    const { id, transactionParams, userOperation } = metadata;\n    const { smartContractAccount } = options;\n\n    log('Preparing user operation', { id });\n\n    const transactionType = await this.#getTransactionType(\n      transaction,\n      provider,\n      options,\n    );\n\n    metadata.transactionType = transactionType ?? null;\n\n    log('Determined transaction type', transactionType);\n\n    await updateGasFees({\n      getGasFeeEstimates: this.#getGasFeeEstimates,\n      metadata,\n      originalRequest: request,\n      provider,\n      transaction: transactionParams ?? undefined,\n    });\n\n    const response = await smartContractAccount.prepareUserOperation({\n      chainId,\n      data,\n      from,\n      to,\n      value,\n    });\n\n    validatePrepareUserOperationResponse(response);\n\n    const {\n      bundler: bundlerUrl,\n      callData,\n      dummyPaymasterAndData,\n      dummySignature,\n      initCode,\n      nonce,\n      sender,\n    } = response;\n\n    userOperation.callData = callData;\n    userOperation.initCode = initCode ?? EMPTY_BYTES;\n    userOperation.nonce = nonce;\n    userOperation.paymasterAndData = dummyPaymasterAndData ?? EMPTY_BYTES;\n    userOperation.sender = sender;\n    userOperation.signature = dummySignature ?? EMPTY_BYTES;\n\n    metadata.bundlerUrl = bundlerUrl;\n\n    await updateGas(metadata, response, this.#entrypoint);\n\n    this.#updateMetadata(metadata);\n  }\n\n  async #addPaymasterData(\n    metadata: UserOperationMetadata,\n    smartContractAccount: SmartContractAccount,\n  ) {\n    const { id, userOperation } = metadata;\n\n    log('Requesting paymaster data', { id });\n\n    const response = await smartContractAccount.updateUserOperation({\n      userOperation,\n    });\n\n    validateUpdateUserOperationResponse(response);\n\n    userOperation.paymasterAndData = response.paymasterAndData ?? EMPTY_BYTES;\n\n    this.#updateMetadata(metadata);\n  }\n\n  async #approveUserOperation(cache: UserOperationCache) {\n    log('Requesting approval');\n\n    const { metadata } = cache;\n\n    const { resultCallbacks, value } = await this.#requestApproval(metadata);\n    const updatedTransaction = value?.txMeta;\n\n    if (updatedTransaction) {\n      await this.#updateUserOperationAfterApproval(cache, updatedTransaction);\n    }\n\n    metadata.status = UserOperationStatus.Approved;\n\n    this.#updateMetadata(metadata);\n\n    return resultCallbacks;\n  }\n\n  async #signUserOperation(\n    metadata: UserOperationMetadata,\n    smartContractAccount: SmartContractAccount,\n  ) {\n    const { id, chainId, userOperation } = metadata;\n\n    log('Signing user operation', id, userOperation);\n\n    const response = await smartContractAccount.signUserOperation({\n      userOperation,\n      chainId,\n    });\n\n    validateSignUserOperationResponse(response);\n\n    const { signature } = response;\n\n    userOperation.signature = signature;\n\n    log('Signed user operation', signature);\n\n    metadata.status = UserOperationStatus.Signed;\n\n    this.#updateMetadata(metadata);\n  }\n\n  async #submitUserOperation(metadata: UserOperationMetadata) {\n    const { userOperation } = metadata;\n\n    log('Submitting user operation', userOperation);\n\n    const bundler = new Bundler(metadata.bundlerUrl as string);\n\n    const hash = await bundler.sendUserOperation(\n      userOperation,\n      this.#entrypoint,\n    );\n\n    metadata.hash = hash;\n    metadata.status = UserOperationStatus.Submitted;\n\n    this.#updateMetadata(metadata);\n  }\n\n  #failUserOperation(metadata: UserOperationMetadata, error: unknown) {\n    const { id } = metadata;\n    const rawError = error as Record<string, string>;\n\n    log('User operation failed', id, error);\n\n    metadata.error = {\n      name: rawError.name,\n      message: rawError.message,\n      stack: rawError.stack,\n      code: rawError.code,\n      rpc: rawError.value,\n    };\n\n    metadata.status = UserOperationStatus.Failed;\n\n    this.#updateMetadata(metadata);\n\n    if (\n      String(rawError.code) === String(errorCodes.provider.userRejectedRequest)\n    ) {\n      this.#deleteMetadata(id);\n    }\n  }\n\n  #createEmptyUserOperation(transaction?: TransactionParams): UserOperation {\n    return {\n      callData: EMPTY_BYTES,\n      callGasLimit: EMPTY_BYTES,\n      initCode: EMPTY_BYTES,\n      maxFeePerGas: transaction?.maxFeePerGas ?? EMPTY_BYTES,\n      maxPriorityFeePerGas: transaction?.maxPriorityFeePerGas ?? EMPTY_BYTES,\n      nonce: EMPTY_BYTES,\n      paymasterAndData: EMPTY_BYTES,\n      preVerificationGas: EMPTY_BYTES,\n      sender: ADDRESS_ZERO,\n      signature: EMPTY_BYTES,\n      verificationGasLimit: EMPTY_BYTES,\n    };\n  }\n\n  #updateMetadata(metadata: UserOperationMetadata) {\n    const { id } = metadata;\n\n    this.update((state) => {\n      state.userOperations[id] = cloneDeep(metadata);\n    });\n\n    this.#updateTransaction(metadata);\n  }\n\n  #deleteMetadata(id: string) {\n    this.update((state) => {\n      delete state.userOperations[id];\n    });\n  }\n\n  #updateTransaction(metadata: UserOperationMetadata) {\n    if (!metadata.transactionParams) {\n      return;\n    }\n\n    const transactionMetadata = getTransactionMetadata(metadata);\n\n    this.hub.emit('transaction-updated', transactionMetadata);\n  }\n\n  #addPendingUserOperationTrackerListeners() {\n    this.#pendingUserOperationTracker.hub.on(\n      'user-operation-confirmed',\n      (metadata) => {\n        log('In listener...');\n        this.hub.emit('user-operation-confirmed', metadata);\n        this.hub.emit(`${metadata.id}:confirmed`, metadata);\n      },\n    );\n\n    this.#pendingUserOperationTracker.hub.on(\n      'user-operation-failed',\n      (metadata, error) => {\n        this.hub.emit('user-operation-failed', metadata, error);\n        this.hub.emit(`${metadata.id}:failed`, metadata, error);\n      },\n    );\n\n    this.#pendingUserOperationTracker.hub.on(\n      'user-operation-updated',\n      (metadata) => {\n        this.#updateMetadata(metadata);\n      },\n    );\n  }\n\n  async #requestApproval(metadata: UserOperationMetadata) {\n    const { id, origin } = metadata;\n    const type = ApprovalType.Transaction;\n    const requestData = { txId: id };\n\n    return (await this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id,\n        origin,\n        type,\n        requestData,\n        expectsResult: true,\n      },\n      true, // Should display approval request to user\n    )) as AddResult & { value?: { txMeta?: TransactionMeta } };\n  }\n\n  async #getTransactionType(\n    transaction: TransactionParams | undefined,\n    provider: Provider,\n    options: AddUserOperationOptions,\n  ): Promise<TransactionType | undefined> {\n    if (!transaction) {\n      return undefined;\n    }\n\n    if (options.type) {\n      return options.type;\n    }\n\n    const ethQuery = new EthQuery(provider);\n    const result = determineTransactionType(transaction, ethQuery);\n\n    return (await result).type;\n  }\n\n  async #getProvider(\n    networkClientId: string,\n  ): Promise<{ provider: Provider; chainId: string }> {\n    const { provider, configuration } = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      networkClientId,\n    );\n\n    const { chainId } = configuration;\n\n    return { provider, chainId };\n  }\n\n  async #updateUserOperationAfterApproval(\n    cache: UserOperationCache,\n    updatedTransaction: TransactionMeta,\n  ) {\n    log('Found updated transaction in approval', { updatedTransaction });\n\n    const { metadata, request } = cache;\n\n    const { userOperation } = metadata;\n    const usingPaymaster = userOperation.paymasterAndData !== EMPTY_BYTES;\n\n    const updatedMaxFeePerGas = add0x(\n      updatedTransaction.txParams.maxFeePerGas as string,\n    );\n\n    const updatedMaxPriorityFeePerGas = add0x(\n      updatedTransaction.txParams.maxPriorityFeePerGas as string,\n    );\n\n    let regenerateUserOperation = false;\n    const previousMaxFeePerGas = userOperation.maxFeePerGas;\n    const previousMaxPriorityFeePerGas = userOperation.maxPriorityFeePerGas;\n\n    if (\n      previousMaxFeePerGas !== updatedMaxFeePerGas ||\n      previousMaxPriorityFeePerGas !== updatedMaxPriorityFeePerGas\n    ) {\n      log('Gas fees updated during approval', {\n        previousMaxFeePerGas,\n        previousMaxPriorityFeePerGas,\n        updatedMaxFeePerGas,\n        updatedMaxPriorityFeePerGas,\n      });\n\n      userOperation.maxFeePerGas = updatedMaxFeePerGas;\n      userOperation.maxPriorityFeePerGas = updatedMaxPriorityFeePerGas;\n\n      regenerateUserOperation = usingPaymaster;\n    }\n\n    const previousData = request.data ?? EMPTY_BYTES;\n    const updatedData = updatedTransaction.txParams.data ?? EMPTY_BYTES;\n\n    if (previousData !== updatedData) {\n      log('Data updated during approval', { previousData, updatedData });\n      regenerateUserOperation = true;\n    }\n\n    const previousValue = request.value ?? VALUE_ZERO;\n    const updatedValue = updatedTransaction.txParams.value ?? VALUE_ZERO;\n\n    if (previousValue !== updatedValue) {\n      log('Value updated during approval', { previousValue, updatedValue });\n      regenerateUserOperation = true;\n    }\n\n    if (regenerateUserOperation) {\n      const updatedRequest = {\n        ...request,\n        data: updatedData,\n        maxFeePerGas: updatedMaxFeePerGas,\n        maxPriorityFeePerGas: updatedMaxPriorityFeePerGas,\n        value: updatedValue,\n      };\n\n      await this.#regenerateUserOperation({\n        ...cache,\n        request: updatedRequest,\n      });\n    }\n  }\n\n  async #regenerateUserOperation(cache: UserOperationCache) {\n    log(\n      'Regenerating user operation as parameters were updated during approval',\n    );\n\n    const {\n      options: { smartContractAccount },\n      metadata,\n    } = cache;\n\n    await this.#prepareUserOperation(cache);\n    await this.#addPaymasterData(metadata, smartContractAccount);\n\n    log('Regenerated user operation', metadata.userOperation);\n  }\n}\n"]}