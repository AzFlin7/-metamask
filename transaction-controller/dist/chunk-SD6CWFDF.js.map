{"version":3,"sources":["../src/utils/transaction-type.ts"],"names":[],"mappings":";AACA,SAAS,iBAAiB;AAC1B,SAAS,aAAa;AAEtB;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAKA,IAAM,qBAAqB;AAElC,IAAM,iBAAiB,IAAI,UAAU,QAAQ;AAC7C,IAAM,kBAAkB,IAAI,UAAU,SAAS;AAC/C,IAAM,mBAAmB,IAAI,UAAU,UAAU;AACjD,IAAM,gBAAgB,IAAI,UAAU,cAAc;AAWlD,eAAsB,yBACpB,UACA,UACqC;AACrC,QAAM,EAAE,MAAM,GAAG,IAAI;AAErB,MAAI,QAAQ,CAAC,IAAI;AACf,WAAO,EAAE,iDAAsC,iBAAiB,OAAU;AAAA,EAC5E;AAEA,QAAM,EAAE,cAAc,iBAAiB,kBAAkB,IACvD,MAAM,sBAAsB,UAAU,EAAE;AAE1C,MAAI,CAAC,mBAAmB;AACtB,WAAO,EAAE,qCAAkC,gBAAgB;AAAA,EAC7D;AAEA,QAAM,WAAW,OAAO,SAAS,SAAS,GAAG,MAAM;AAEnD,QAAM,4BAA4B;AAAA,IAChC;AAAA,IACA;AAAA,EACF;AAEA,MAAI,CAAC,QAAQ,UAAU;AACrB,WAAO;AAAA,EACT;AAEA,QAAM,OAAO,kCAAkC,IAAI,GAAG;AAEtD,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AAEA,QAAM,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOxB,EAAE;AAAA,IACA,CAAC,eAAe,WAAW,YAAY,MAAO,KAAgB,YAAY;AAAA,EAC5E;AAEA,MAAI,iBAAiB;AACnB,WAAO,EAAE,MAAM,iBAAiB,gBAAgB;AAAA,EAClD;AAEA,SAAO;AACT;AAUA,SAAS,kCACP,MACoC;AACpC,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AAEA,MAAI;AACF,WAAO,eAAe,iBAAiB,EAAE,KAAK,CAAC;AAAA,EACjD,QAAQ;AAAA,EAER;AAEA,MAAI;AACF,WAAO,gBAAgB,iBAAiB,EAAE,KAAK,CAAC;AAAA,EAClD,QAAQ;AAAA,EAER;AAEA,MAAI;AACF,WAAO,iBAAiB,iBAAiB,EAAE,KAAK,CAAC;AAAA,EACnD,QAAQ;AAAA,EAER;AAEA,MAAI;AACF,WAAO,cAAc,iBAAiB,EAAE,KAAK,CAAC;AAAA,EAChD,QAAQ;AAAA,EAER;AAEA,SAAO;AACT;AASA,eAAe,sBACb,UACA,SAIC;AACD,MAAI;AACJ,MAAI;AACF,mBAAe,MAAM,MAAM,UAAU,WAAW,CAAC,OAAO,CAAC;AAAA,EAC3D,SAAS,GAAG;AACV,mBAAe;AAAA,EACjB;AAEA,QAAM,oBAAoB,eACtB,iBAAiB,QAAQ,iBAAiB,QAC1C;AACJ,SAAO,EAAE,cAAc,kBAAkB;AAC3C","sourcesContent":["import type { TransactionDescription } from '@ethersproject/abi';\nimport { Interface } from '@ethersproject/abi';\nimport { query } from '@metamask/controller-utils';\nimport type EthQuery from '@metamask/eth-query';\nimport {\n  abiERC721,\n  abiERC20,\n  abiERC1155,\n  abiFiatTokenV2,\n} from '@metamask/metamask-eth-abis';\n\nimport type { InferTransactionTypeResult, TransactionParams } from '../types';\nimport { TransactionType } from '../types';\n\nexport const ESTIMATE_GAS_ERROR = 'eth_estimateGas rpc method error';\n\nconst ERC20Interface = new Interface(abiERC20);\nconst ERC721Interface = new Interface(abiERC721);\nconst ERC1155Interface = new Interface(abiERC1155);\nconst USDCInterface = new Interface(abiFiatTokenV2);\n\n/**\n * Determines the type of the transaction by analyzing the txParams.\n * It will never return TRANSACTION_TYPE_CANCEL or TRANSACTION_TYPE_RETRY as these\n * represent specific events that we specify manually at transaction creation.\n *\n * @param txParams - Parameters for the transaction.\n * @param ethQuery - EthQuery instance.\n * @returns A object with the transaction type and the contract code response in Hex.\n */\nexport async function determineTransactionType(\n  txParams: TransactionParams,\n  ethQuery: EthQuery,\n): Promise<InferTransactionTypeResult> {\n  const { data, to } = txParams;\n\n  if (data && !to) {\n    return { type: TransactionType.deployContract, getCodeResponse: undefined };\n  }\n\n  const { contractCode: getCodeResponse, isContractAddress } =\n    await readAddressAsContract(ethQuery, to);\n\n  if (!isContractAddress) {\n    return { type: TransactionType.simpleSend, getCodeResponse };\n  }\n\n  const hasValue = Number(txParams.value ?? '0') !== 0;\n\n  const contractInteractionResult = {\n    type: TransactionType.contractInteraction,\n    getCodeResponse,\n  };\n\n  if (!data || hasValue) {\n    return contractInteractionResult;\n  }\n\n  const name = parseStandardTokenTransactionData(data)?.name;\n\n  if (!name) {\n    return contractInteractionResult;\n  }\n\n  const tokenMethodName = [\n    TransactionType.tokenMethodApprove,\n    TransactionType.tokenMethodSetApprovalForAll,\n    TransactionType.tokenMethodTransfer,\n    TransactionType.tokenMethodTransferFrom,\n    TransactionType.tokenMethodSafeTransferFrom,\n    TransactionType.tokenMethodIncreaseAllowance,\n  ].find(\n    (methodName) => methodName.toLowerCase() === (name as string).toLowerCase(),\n  );\n\n  if (tokenMethodName) {\n    return { type: tokenMethodName, getCodeResponse };\n  }\n\n  return contractInteractionResult;\n}\n\n/**\n * Attempts to decode transaction data using ABIs for three different token standards: ERC20, ERC721, ERC1155.\n * The data will decode correctly if the transaction is an interaction with a contract that matches one of these\n * contract standards\n *\n * @param data - Encoded transaction data.\n * @returns A representation of an ethereum contract call.\n */\nfunction parseStandardTokenTransactionData(\n  data?: string,\n): TransactionDescription | undefined {\n  if (!data) {\n    return undefined;\n  }\n\n  try {\n    return ERC20Interface.parseTransaction({ data });\n  } catch {\n    // ignore and next try to parse with erc721 ABI\n  }\n\n  try {\n    return ERC721Interface.parseTransaction({ data });\n  } catch {\n    // ignore and next try to parse with erc1155 ABI\n  }\n\n  try {\n    return ERC1155Interface.parseTransaction({ data });\n  } catch {\n    // ignore and return undefined\n  }\n\n  try {\n    return USDCInterface.parseTransaction({ data });\n  } catch {\n    // ignore and return undefined\n  }\n\n  return undefined;\n}\n\n/**\n * Reads an Ethereum address and determines if it is a contract address.\n *\n * @param ethQuery - The Ethereum query object used to interact with the Ethereum blockchain.\n * @param address - The Ethereum address.\n * @returns An object containing the contract code and a boolean indicating if it is a contract address.\n */\nasync function readAddressAsContract(\n  ethQuery: EthQuery,\n  address?: string,\n): Promise<{\n  contractCode: string | null;\n  isContractAddress: boolean;\n}> {\n  let contractCode;\n  try {\n    contractCode = await query(ethQuery, 'getCode', [address]);\n  } catch (e) {\n    contractCode = null;\n  }\n\n  const isContractAddress = contractCode\n    ? contractCode !== '0x' && contractCode !== '0x0'\n    : false;\n  return { contractCode, isContractAddress };\n}\n"]}