{"version":3,"sources":["../src/helpers/MultichainTrackingHelper.ts"],"sourcesContent":["import EthQuery from '@metamask/eth-query';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkClient,\n  BlockTracker,\n  Provider,\n  NetworkControllerStateChangeEvent,\n} from '@metamask/network-controller';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport type { NonceLock, NonceTracker } from 'nonce-tracker';\n\nimport { incomingTransactionsLogger as log } from '../logger';\nimport { EtherscanRemoteTransactionSource } from './EtherscanRemoteTransactionSource';\nimport type {\n  IncomingTransactionHelper,\n  IncomingTransactionOptions,\n} from './IncomingTransactionHelper';\nimport type { PendingTransactionTracker } from './PendingTransactionTracker';\n\n/**\n * Registry of network clients provided by the NetworkController\n */\ntype NetworkClientRegistry = ReturnType<\n  NetworkController['getNetworkClientRegistry']\n>;\n\nexport type MultichainTrackingHelperOptions = {\n  isMultichainEnabled: boolean;\n  provider: Provider;\n  nonceTracker: NonceTracker;\n  incomingTransactionOptions: IncomingTransactionOptions;\n\n  findNetworkClientIdByChainId: NetworkController['findNetworkClientIdByChainId'];\n  getNetworkClientById: NetworkController['getNetworkClientById'];\n  getNetworkClientRegistry: NetworkController['getNetworkClientRegistry'];\n\n  removeIncomingTransactionHelperListeners: (\n    IncomingTransactionHelper: IncomingTransactionHelper,\n  ) => void;\n  removePendingTransactionTrackerListeners: (\n    pendingTransactionTracker: PendingTransactionTracker,\n  ) => void;\n  createNonceTracker: (opts: {\n    provider: Provider;\n    blockTracker: BlockTracker;\n    chainId?: Hex;\n  }) => NonceTracker;\n  createIncomingTransactionHelper: (opts: {\n    blockTracker: BlockTracker;\n    etherscanRemoteTransactionSource: EtherscanRemoteTransactionSource;\n    chainId?: Hex;\n  }) => IncomingTransactionHelper;\n  createPendingTransactionTracker: (opts: {\n    provider: Provider;\n    blockTracker: BlockTracker;\n    chainId?: Hex;\n  }) => PendingTransactionTracker;\n  onNetworkStateChange: (\n    listener: (\n      ...payload: NetworkControllerStateChangeEvent['payload']\n    ) => void,\n  ) => void;\n};\n\nexport class MultichainTrackingHelper {\n  #isMultichainEnabled: boolean;\n\n  readonly #provider: Provider;\n\n  readonly #nonceTracker: NonceTracker;\n\n  readonly #incomingTransactionOptions: IncomingTransactionOptions;\n\n  readonly #findNetworkClientIdByChainId: NetworkController['findNetworkClientIdByChainId'];\n\n  readonly #getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  readonly #getNetworkClientRegistry: NetworkController['getNetworkClientRegistry'];\n\n  readonly #removeIncomingTransactionHelperListeners: (\n    IncomingTransactionHelper: IncomingTransactionHelper,\n  ) => void;\n\n  readonly #removePendingTransactionTrackerListeners: (\n    pendingTransactionTracker: PendingTransactionTracker,\n  ) => void;\n\n  readonly #createNonceTracker: (opts: {\n    provider: Provider;\n    blockTracker: BlockTracker;\n    chainId?: Hex;\n  }) => NonceTracker;\n\n  readonly #createIncomingTransactionHelper: (opts: {\n    blockTracker: BlockTracker;\n    chainId?: Hex;\n    etherscanRemoteTransactionSource: EtherscanRemoteTransactionSource;\n  }) => IncomingTransactionHelper;\n\n  readonly #createPendingTransactionTracker: (opts: {\n    provider: Provider;\n    blockTracker: BlockTracker;\n    chainId?: Hex;\n  }) => PendingTransactionTracker;\n\n  readonly #nonceMutexesByChainId = new Map<Hex, Map<string, Mutex>>();\n\n  readonly #trackingMap: Map<\n    NetworkClientId,\n    {\n      nonceTracker: NonceTracker;\n      pendingTransactionTracker: PendingTransactionTracker;\n      incomingTransactionHelper: IncomingTransactionHelper;\n    }\n  > = new Map();\n\n  readonly #etherscanRemoteTransactionSourcesMap: Map<\n    Hex,\n    EtherscanRemoteTransactionSource\n  > = new Map();\n\n  constructor({\n    isMultichainEnabled,\n    provider,\n    nonceTracker,\n    incomingTransactionOptions,\n    findNetworkClientIdByChainId,\n    getNetworkClientById,\n    getNetworkClientRegistry,\n    removeIncomingTransactionHelperListeners,\n    removePendingTransactionTrackerListeners,\n    createNonceTracker,\n    createIncomingTransactionHelper,\n    createPendingTransactionTracker,\n    onNetworkStateChange,\n  }: MultichainTrackingHelperOptions) {\n    this.#isMultichainEnabled = isMultichainEnabled;\n    this.#provider = provider;\n    this.#nonceTracker = nonceTracker;\n    this.#incomingTransactionOptions = incomingTransactionOptions;\n\n    this.#findNetworkClientIdByChainId = findNetworkClientIdByChainId;\n    this.#getNetworkClientById = getNetworkClientById;\n    this.#getNetworkClientRegistry = getNetworkClientRegistry;\n\n    this.#removeIncomingTransactionHelperListeners =\n      removeIncomingTransactionHelperListeners;\n    this.#removePendingTransactionTrackerListeners =\n      removePendingTransactionTrackerListeners;\n    this.#createNonceTracker = createNonceTracker;\n    this.#createIncomingTransactionHelper = createIncomingTransactionHelper;\n    this.#createPendingTransactionTracker = createPendingTransactionTracker;\n\n    onNetworkStateChange((_, patches) => {\n      if (this.#isMultichainEnabled) {\n        const networkClients = this.#getNetworkClientRegistry();\n        patches.forEach(({ op, path }) => {\n          if (op === 'remove' && path[0] === 'networkConfigurations') {\n            const networkClientId = path[1] as NetworkClientId;\n            delete networkClients[networkClientId];\n          }\n        });\n\n        this.#refreshTrackingMap(networkClients);\n      }\n    });\n  }\n\n  initialize() {\n    if (!this.#isMultichainEnabled) {\n      return;\n    }\n    const networkClients = this.#getNetworkClientRegistry();\n    this.#refreshTrackingMap(networkClients);\n  }\n\n  has(networkClientId: NetworkClientId) {\n    return this.#trackingMap.has(networkClientId);\n  }\n\n  getEthQuery({\n    networkClientId,\n    chainId,\n  }: {\n    networkClientId?: NetworkClientId;\n    chainId?: Hex;\n  } = {}): EthQuery {\n    return new EthQuery(this.getProvider({ networkClientId, chainId }));\n  }\n\n  getProvider({\n    networkClientId,\n    chainId,\n  }: {\n    networkClientId?: NetworkClientId;\n    chainId?: Hex;\n  } = {}): Provider {\n    if (!this.#isMultichainEnabled) {\n      return this.#provider;\n    }\n\n    const networkClient = this.#getNetworkClient({\n      networkClientId,\n      chainId,\n    });\n\n    return networkClient?.provider || this.#provider;\n  }\n\n  /**\n   * Gets the mutex intended to guard the nonceTracker for a particular chainId and key .\n   *\n   * @param opts - The options object.\n   * @param opts.chainId - The hex chainId.\n   * @param opts.key - The hex address (or constant) pertaining to the chainId\n   * @returns Mutex instance for the given chainId and key pair\n   */\n  async acquireNonceLockForChainIdKey({\n    chainId,\n    key = 'global',\n  }: {\n    chainId: Hex;\n    key?: string;\n  }): Promise<() => void> {\n    let nonceMutexesForChainId = this.#nonceMutexesByChainId.get(chainId);\n    if (!nonceMutexesForChainId) {\n      nonceMutexesForChainId = new Map<string, Mutex>();\n      this.#nonceMutexesByChainId.set(chainId, nonceMutexesForChainId);\n    }\n    let nonceMutexForKey = nonceMutexesForChainId.get(key);\n    if (!nonceMutexForKey) {\n      nonceMutexForKey = new Mutex();\n      nonceMutexesForChainId.set(key, nonceMutexForKey);\n    }\n\n    return await nonceMutexForKey.acquire();\n  }\n\n  /**\n   * Gets the next nonce according to the nonce-tracker.\n   * Ensure `releaseLock` is called once processing of the `nonce` value is complete.\n   *\n   * @param address - The hex string address for the transaction.\n   * @param networkClientId - The network client ID for the transaction, used to fetch the correct nonce tracker.\n   * @returns object with the `nextNonce` `nonceDetails`, and the releaseLock.\n   */\n  async getNonceLock(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NonceLock> {\n    let releaseLockForChainIdKey: (() => void) | undefined;\n    let nonceTracker = this.#nonceTracker;\n    if (networkClientId && this.#isMultichainEnabled) {\n      const networkClient = this.#getNetworkClientById(networkClientId);\n      releaseLockForChainIdKey = await this.acquireNonceLockForChainIdKey({\n        chainId: networkClient.configuration.chainId,\n        key: address,\n      });\n      const trackers = this.#trackingMap.get(networkClientId);\n      if (!trackers) {\n        throw new Error('missing nonceTracker for networkClientId');\n      }\n      nonceTracker = trackers.nonceTracker;\n    }\n\n    // Acquires the lock for the chainId + address and the nonceLock from the nonceTracker, then\n    // couples them together by replacing the nonceLock's releaseLock method with\n    // an anonymous function that calls releases both the original nonceLock and the\n    // lock for the chainId.\n    try {\n      const nonceLock = await nonceTracker.getNonceLock(address);\n      return {\n        ...nonceLock,\n        releaseLock: () => {\n          nonceLock.releaseLock();\n          releaseLockForChainIdKey?.();\n        },\n      };\n    } catch (err) {\n      releaseLockForChainIdKey?.();\n      throw err;\n    }\n  }\n\n  startIncomingTransactionPolling(networkClientIds: NetworkClientId[] = []) {\n    networkClientIds.forEach((networkClientId) => {\n      this.#trackingMap.get(networkClientId)?.incomingTransactionHelper.start();\n    });\n  }\n\n  stopIncomingTransactionPolling(networkClientIds: NetworkClientId[] = []) {\n    networkClientIds.forEach((networkClientId) => {\n      this.#trackingMap.get(networkClientId)?.incomingTransactionHelper.stop();\n    });\n  }\n\n  stopAllIncomingTransactionPolling() {\n    for (const [, trackers] of this.#trackingMap) {\n      trackers.incomingTransactionHelper.stop();\n    }\n  }\n\n  async updateIncomingTransactions(networkClientIds: NetworkClientId[] = []) {\n    const promises = await Promise.allSettled(\n      networkClientIds.map(async (networkClientId) => {\n        return await this.#trackingMap\n          .get(networkClientId)\n          ?.incomingTransactionHelper.update();\n      }),\n    );\n\n    promises\n      .filter((result) => result.status === 'rejected')\n      .forEach((result) => {\n        log(\n          'failed to update incoming transactions',\n          (result as PromiseRejectedResult).reason,\n        );\n      });\n  }\n\n  checkForPendingTransactionAndStartPolling = () => {\n    for (const [, trackers] of this.#trackingMap) {\n      trackers.pendingTransactionTracker.startIfPendingTransactions();\n    }\n  };\n\n  stopAllTracking() {\n    for (const [networkClientId] of this.#trackingMap) {\n      this.#stopTrackingByNetworkClientId(networkClientId);\n    }\n  }\n\n  #refreshTrackingMap = (networkClients: NetworkClientRegistry) => {\n    this.#refreshEtherscanRemoteTransactionSources(networkClients);\n\n    const networkClientIds = Object.keys(networkClients);\n    const existingNetworkClientIds = Array.from(this.#trackingMap.keys());\n\n    // Remove tracking for NetworkClientIds that no longer exist\n    const networkClientIdsToRemove = existingNetworkClientIds.filter(\n      (id) => !networkClientIds.includes(id),\n    );\n    networkClientIdsToRemove.forEach((id) => {\n      this.#stopTrackingByNetworkClientId(id);\n    });\n\n    // Start tracking new NetworkClientIds from the registry\n    const networkClientIdsToAdd = networkClientIds.filter(\n      (id) => !existingNetworkClientIds.includes(id),\n    );\n    networkClientIdsToAdd.forEach((id) => {\n      this.#startTrackingByNetworkClientId(id);\n    });\n  };\n\n  #stopTrackingByNetworkClientId(networkClientId: NetworkClientId) {\n    const trackers = this.#trackingMap.get(networkClientId);\n    if (trackers) {\n      trackers.pendingTransactionTracker.stop();\n      this.#removePendingTransactionTrackerListeners(\n        trackers.pendingTransactionTracker,\n      );\n      trackers.incomingTransactionHelper.stop();\n      this.#removeIncomingTransactionHelperListeners(\n        trackers.incomingTransactionHelper,\n      );\n      this.#trackingMap.delete(networkClientId);\n    }\n  }\n\n  #startTrackingByNetworkClientId(networkClientId: NetworkClientId) {\n    const trackers = this.#trackingMap.get(networkClientId);\n    if (trackers) {\n      return;\n    }\n\n    const {\n      provider,\n      blockTracker,\n      configuration: { chainId },\n    } = this.#getNetworkClientById(networkClientId);\n\n    let etherscanRemoteTransactionSource =\n      this.#etherscanRemoteTransactionSourcesMap.get(chainId);\n    if (!etherscanRemoteTransactionSource) {\n      etherscanRemoteTransactionSource = new EtherscanRemoteTransactionSource({\n        includeTokenTransfers:\n          this.#incomingTransactionOptions.includeTokenTransfers,\n      });\n      this.#etherscanRemoteTransactionSourcesMap.set(\n        chainId,\n        etherscanRemoteTransactionSource,\n      );\n    }\n\n    const nonceTracker = this.#createNonceTracker({\n      provider,\n      blockTracker,\n      chainId,\n    });\n\n    const incomingTransactionHelper = this.#createIncomingTransactionHelper({\n      blockTracker,\n      etherscanRemoteTransactionSource,\n      chainId,\n    });\n\n    const pendingTransactionTracker = this.#createPendingTransactionTracker({\n      provider,\n      blockTracker,\n      chainId,\n    });\n\n    this.#trackingMap.set(networkClientId, {\n      nonceTracker,\n      incomingTransactionHelper,\n      pendingTransactionTracker,\n    });\n  }\n\n  #refreshEtherscanRemoteTransactionSources = (\n    networkClients: NetworkClientRegistry,\n  ) => {\n    // this will be prettier when we have consolidated network clients with a single chainId:\n    // check if there are still other network clients using the same chainId\n    // if not remove the etherscanRemoteTransaction source from the map\n    const chainIdsInRegistry = new Set();\n    Object.values(networkClients).forEach((networkClient) =>\n      chainIdsInRegistry.add(networkClient.configuration.chainId),\n    );\n    const existingChainIds = Array.from(\n      this.#etherscanRemoteTransactionSourcesMap.keys(),\n    );\n    const chainIdsToRemove = existingChainIds.filter(\n      (chainId) => !chainIdsInRegistry.has(chainId),\n    );\n\n    chainIdsToRemove.forEach((chainId) => {\n      this.#etherscanRemoteTransactionSourcesMap.delete(chainId);\n    });\n  };\n\n  #getNetworkClient({\n    networkClientId,\n    chainId,\n  }: {\n    networkClientId?: NetworkClientId;\n    chainId?: Hex;\n  } = {}): NetworkClient | undefined {\n    let networkClient: NetworkClient | undefined;\n\n    if (networkClientId) {\n      try {\n        networkClient = this.#getNetworkClientById(networkClientId);\n      } catch (err) {\n        log('failed to get network client by networkClientId');\n      }\n    }\n    if (!networkClient && chainId) {\n      try {\n        const networkClientIdForChainId =\n          this.#findNetworkClientIdByChainId(chainId);\n        networkClient = this.#getNetworkClientById(networkClientIdForChainId);\n      } catch (err) {\n        log('failed to get network client by chainId');\n      }\n    }\n    return networkClient;\n  }\n}\n"],"mappings":"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","names":[]}