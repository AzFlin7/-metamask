{"version":3,"sources":["../src/TransactionController.ts"],"sourcesContent":["import { Hardfork, Common, type ChainConfig } from '@ethereumjs/common';\nimport type { TypedTransaction } from '@ethereumjs/tx';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport { bufferToHex } from '@ethereumjs/util';\nimport type {\n  AcceptResultCallbacks,\n  AddApprovalRequest,\n  AddResult,\n} from '@metamask/approval-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  query,\n  NetworkType,\n  ApprovalType,\n  ORIGIN_METAMASK,\n  convertHexToDecimal,\n} from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport type { GasFeeState } from '@metamask/gas-fee-controller';\nimport type {\n  BlockTracker,\n  NetworkClientId,\n  NetworkController,\n  NetworkControllerStateChangeEvent,\n  NetworkState,\n  Provider,\n  NetworkControllerFindNetworkClientIdByChainIdAction,\n  NetworkControllerGetNetworkClientByIdAction,\n} from '@metamask/network-controller';\nimport { NetworkClientType } from '@metamask/network-controller';\nimport { errorCodes, rpcErrors, providerErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { add0x } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { MethodRegistry } from 'eth-method-registry';\nimport { EventEmitter } from 'events';\nimport { cloneDeep, mapValues, merge, pickBy, sortBy, isEqual } from 'lodash';\nimport { NonceTracker } from 'nonce-tracker';\nimport type {\n  NonceLock,\n  Transaction as NonceTrackerTransaction,\n} from 'nonce-tracker';\nimport { v1 as random } from 'uuid';\n\nimport { DefaultGasFeeFlow } from './gas-flows/DefaultGasFeeFlow';\nimport { LineaGasFeeFlow } from './gas-flows/LineaGasFeeFlow';\nimport { OptimismLayer1GasFeeFlow } from './gas-flows/OptimismLayer1GasFeeFlow';\nimport { ScrollLayer1GasFeeFlow } from './gas-flows/ScrollLayer1GasFeeFlow';\nimport { EtherscanRemoteTransactionSource } from './helpers/EtherscanRemoteTransactionSource';\nimport { GasFeePoller } from './helpers/GasFeePoller';\nimport type { IncomingTransactionOptions } from './helpers/IncomingTransactionHelper';\nimport { IncomingTransactionHelper } from './helpers/IncomingTransactionHelper';\nimport { MultichainTrackingHelper } from './helpers/MultichainTrackingHelper';\nimport { PendingTransactionTracker } from './helpers/PendingTransactionTracker';\nimport { projectLogger as log } from './logger';\nimport type {\n  DappSuggestedGasFees,\n  Layer1GasFeeFlow,\n  SavedGasFees,\n  SecurityProviderRequest,\n  SendFlowHistoryEntry,\n  TransactionParams,\n  TransactionMeta,\n  TransactionReceipt,\n  WalletDevice,\n  SecurityAlertResponse,\n  GasFeeFlow,\n  SimulationData,\n  GasFeeEstimates,\n} from './types';\nimport {\n  TransactionEnvelopeType,\n  TransactionType,\n  TransactionStatus,\n  SimulationErrorCode,\n} from './types';\nimport { validateConfirmedExternalTransaction } from './utils/external-transactions';\nimport { addGasBuffer, estimateGas, updateGas } from './utils/gas';\nimport { updateGasFees } from './utils/gas-fees';\nimport {\n  addInitialHistorySnapshot,\n  updateTransactionHistory,\n} from './utils/history';\nimport {\n  getTransactionLayer1GasFee,\n  updateTransactionLayer1GasFee,\n} from './utils/layer1-gas-fee-flow';\nimport {\n  getAndFormatTransactionsForNonceTracker,\n  getNextNonce,\n} from './utils/nonce';\nimport { getSimulationData } from './utils/simulation';\nimport {\n  updatePostTransactionBalance,\n  updateSwapsTransaction,\n} from './utils/swaps';\nimport { determineTransactionType } from './utils/transaction-type';\nimport {\n  getIncreasedPriceFromExisting,\n  normalizeTransactionParams,\n  isEIP1559Transaction,\n  isFeeMarketEIP1559Values,\n  isGasPriceValue,\n  validateGasValues,\n  validateIfTransactionUnapproved,\n  validateMinimumIncrease,\n  normalizeTxError,\n  normalizeGasFeeValues,\n} from './utils/utils';\nimport {\n  validateTransactionOrigin,\n  validateTxParams,\n} from './utils/validation';\n\n/**\n * Metadata for the TransactionController state, describing how to \"anonymize\"\n * the state and which parts should be persisted.\n */\nconst metadata = {\n  transactions: {\n    persist: true,\n    anonymous: false,\n  },\n  methodData: {\n    persist: true,\n    anonymous: false,\n  },\n  lastFetchedBlockNumbers: {\n    persist: true,\n    anonymous: false,\n  },\n};\n\nexport const HARDFORK = Hardfork.London;\n\n/**\n * Object with new transaction's meta and a promise resolving to the\n * transaction hash if successful.\n *\n * @property result - Promise resolving to a new transaction hash\n * @property transactionMeta - Meta information about this new transaction\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Result {\n  result: Promise<string>;\n  transactionMeta: TransactionMeta;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface GasPriceValue {\n  gasPrice: string;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface FeeMarketEIP1559Values {\n  maxFeePerGas: string;\n  maxPriorityFeePerGas: string;\n}\n\n/**\n * Method data registry object\n *\n * @property registryMethod - Registry method raw string\n * @property parsedRegistryMethod - Registry method object, containing name and method arguments\n */\nexport type MethodData = {\n  registryMethod: string;\n  parsedRegistryMethod:\n    | {\n        name: string;\n        args: { type: string }[];\n      }\n    | {\n        // We're using `any` instead of `undefined` for compatibility with `Json`\n        // TODO: Correct this type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        name?: any;\n        // We're using `any` instead of `undefined` for compatibility with `Json`\n        // TODO: Correct this type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        args?: any;\n      };\n};\n\n/**\n * Transaction controller state\n *\n * @property transactions - A list of TransactionMeta objects\n * @property methodData - Object containing all known method data information\n * @property lastFetchedBlockNumbers - Last fetched block numbers.\n */\nexport type TransactionControllerState = {\n  transactions: TransactionMeta[];\n  methodData: Record<string, MethodData>;\n  lastFetchedBlockNumbers: { [key: string]: number };\n};\n\n/**\n * Multiplier used to determine a transaction's increased gas fee during cancellation\n */\nexport const CANCEL_RATE = 1.1;\n\n/**\n * Multiplier used to determine a transaction's increased gas fee during speed up\n */\nexport const SPEED_UP_RATE = 1.1;\n\n/**\n * Represents the `TransactionController:getState` action.\n */\nexport type TransactionControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  TransactionControllerState\n>;\n\n/**\n * The internal actions available to the TransactionController.\n */\nexport type TransactionControllerActions = TransactionControllerGetStateAction;\n\n/**\n * Configuration options for the PendingTransactionTracker\n *\n * @property isResubmitEnabled - Whether transaction publishing is automatically retried.\n */\nexport type PendingTransactionOptions = {\n  isResubmitEnabled?: () => boolean;\n};\n\n/**\n * TransactionController constructor options.\n *\n * @property blockTracker - The block tracker used to poll for new blocks data.\n * @property disableHistory - Whether to disable storing history in transaction metadata.\n * @property disableSendFlowHistory - Explicitly disable transaction metadata history.\n * @property disableSwaps - Whether to disable additional processing on swaps transactions.\n * @property getCurrentAccountEIP1559Compatibility - Whether or not the account supports EIP-1559.\n * @property getCurrentNetworkEIP1559Compatibility - Whether or not the network supports EIP-1559.\n * @property getExternalPendingTransactions - Callback to retrieve pending transactions from external sources.\n * @property getGasFeeEstimates - Callback to retrieve gas fee estimates.\n * @property getNetworkClientRegistry - Gets the network client registry.\n * @property getNetworkState - Gets the state of the network controller.\n * @property getPermittedAccounts - Get accounts that a given origin has permissions for.\n * @property getSavedGasFees - Gets the saved gas fee config.\n * @property getSelectedAddress - Gets the address of the currently selected account.\n * @property incomingTransactions - Configuration options for incoming transaction support.\n * @property isMultichainEnabled - Enable multichain support.\n * @property isSimulationEnabled - Whether new transactions will be automatically simulated.\n * @property messenger - The controller messenger.\n * @property onNetworkStateChange - Allows subscribing to network controller state changes.\n * @property pendingTransactions - Configuration options for pending transaction support.\n * @property provider - The provider used to create the underlying EthQuery instance.\n * @property securityProviderRequest - A function for verifying a transaction, whether it is malicious or not.\n * @property sign - Function used to sign transactions.\n * @property state - Initial state to set on this controller.\n * @property transactionHistoryLimit - Transaction history limit.\n * @property hooks - The controller hooks.\n * @property hooks.afterSign - Additional logic to execute after signing a transaction. Return false to not change the status to signed.\n * @property hooks.beforeApproveOnInit - Additional logic to execute before starting an approval flow for a transaction during initialization. Return false to skip the transaction.\n * @property hooks.beforeCheckPendingTransaction - Additional logic to execute before checking pending transactions. Return false to prevent the broadcast of the transaction.\n * @property hooks.beforePublish - Additional logic to execute before publishing a transaction. Return false to prevent the broadcast of the transaction.\n * @property hooks.getAdditionalSignArguments - Returns additional arguments required to sign a transaction.\n * @property hooks.publish - Alternate logic to publish a transaction.\n */\nexport type TransactionControllerOptions = {\n  blockTracker: BlockTracker;\n  disableHistory: boolean;\n  disableSendFlowHistory: boolean;\n  disableSwaps: boolean;\n  getCurrentAccountEIP1559Compatibility?: () => Promise<boolean>;\n  getCurrentNetworkEIP1559Compatibility: () => Promise<boolean>;\n  getExternalPendingTransactions?: (\n    address: string,\n    chainId?: string,\n  ) => NonceTrackerTransaction[];\n  getGasFeeEstimates?: () => Promise<GasFeeState>;\n  getNetworkClientRegistry: NetworkController['getNetworkClientRegistry'];\n  getNetworkState: () => NetworkState;\n  getPermittedAccounts: (origin?: string) => Promise<string[]>;\n  getSavedGasFees?: (chainId: Hex) => SavedGasFees | undefined;\n  getSelectedAddress: () => string;\n  incomingTransactions?: IncomingTransactionOptions;\n  isMultichainEnabled: boolean;\n  isSimulationEnabled?: () => boolean;\n  messenger: TransactionControllerMessenger;\n  onNetworkStateChange: (listener: (state: NetworkState) => void) => void;\n  pendingTransactions?: PendingTransactionOptions;\n  provider: Provider;\n  securityProviderRequest?: SecurityProviderRequest;\n  sign?: (\n    transaction: TypedTransaction,\n    from: string,\n    transactionMeta?: TransactionMeta,\n  ) => Promise<TypedTransaction>;\n  state?: Partial<TransactionControllerState>;\n  transactionHistoryLimit: number;\n  hooks: {\n    afterSign?: (\n      transactionMeta: TransactionMeta,\n      signedTx: TypedTransaction,\n    ) => boolean;\n    beforeApproveOnInit?: (transactionMeta: TransactionMeta) => boolean;\n    beforeCheckPendingTransaction?: (\n      transactionMeta: TransactionMeta,\n    ) => boolean;\n    beforePublish?: (transactionMeta: TransactionMeta) => boolean;\n    getAdditionalSignArguments?: (\n      transactionMeta: TransactionMeta,\n    ) => (TransactionMeta | undefined)[];\n    publish?: (\n      transactionMeta: TransactionMeta,\n    ) => Promise<{ transactionHash: string }>;\n  };\n};\n\n/**\n * The name of the {@link TransactionController}.\n */\nconst controllerName = 'TransactionController';\n\n/**\n * The external actions available to the {@link TransactionController}.\n */\nexport type AllowedActions =\n  | AddApprovalRequest\n  | NetworkControllerFindNetworkClientIdByChainIdAction\n  | NetworkControllerGetNetworkClientByIdAction;\n\n/**\n * The external events available to the {@link TransactionController}.\n */\nexport type AllowedEvents = NetworkControllerStateChangeEvent;\n\n/**\n * Represents the `TransactionController:stateChange` event.\n */\nexport type TransactionControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  TransactionControllerState\n>;\n\n/**\n * Represents the `TransactionController:incomingTransactionBlockReceived` event.\n */\nexport type TransactionControllerIncomingTransactionBlockReceivedEvent = {\n  type: `${typeof controllerName}:incomingTransactionBlockReceived`;\n  payload: [blockNumber: number];\n};\n\n/**\n * Represents the `TransactionController:postTransactionBalanceUpdated` event.\n */\nexport type TransactionControllerPostTransactionBalanceUpdatedEvent = {\n  type: `${typeof controllerName}:postTransactionBalanceUpdated`;\n  payload: [\n    {\n      transactionMeta: TransactionMeta;\n      approvalTransactionMeta?: TransactionMeta;\n    },\n  ];\n};\n\n/**\n * Represents the `TransactionController:speedUpTransactionAdded` event.\n */\nexport type TransactionControllerSpeedupTransactionAddedEvent = {\n  type: `${typeof controllerName}:speedupTransactionAdded`;\n  payload: [transactionMeta: TransactionMeta];\n};\n\n/**\n * Represents the `TransactionController:transactionApproved` event.\n */\nexport type TransactionControllerTransactionApprovedEvent = {\n  type: `${typeof controllerName}:transactionApproved`;\n  payload: [\n    {\n      transactionMeta: TransactionMeta;\n      actionId?: string;\n    },\n  ];\n};\n\n/**\n * Represents the `TransactionController:transactionConfirmed` event.\n */\nexport type TransactionControllerTransactionConfirmedEvent = {\n  type: `${typeof controllerName}:transactionConfirmed`;\n  payload: [transactionMeta: TransactionMeta];\n};\n\n/**\n * Represents the `TransactionController:transactionDropped` event.\n */\nexport type TransactionControllerTransactionDroppedEvent = {\n  type: `${typeof controllerName}:transactionDropped`;\n  payload: [{ transactionMeta: TransactionMeta }];\n};\n\n/**\n * Represents the `TransactionController:transactionFailed` event.\n */\nexport type TransactionControllerTransactionFailedEvent = {\n  type: `${typeof controllerName}:transactionFailed`;\n  payload: [\n    {\n      actionId?: string;\n      error: string;\n      transactionMeta: TransactionMeta;\n    },\n  ];\n};\n\n/**\n * Represents the `TransactionController:transactionFinished` event.\n */\nexport type TransactionControllerTransactionFinishedEvent = {\n  type: `${typeof controllerName}:transactionFinished`;\n  payload: [transactionMeta: TransactionMeta];\n};\n\n/**\n * Represents the `TransactionController:transactionNewSwapApproval` event.\n */\nexport type TransactionControllerTransactionNewSwapApprovalEvent = {\n  type: `${typeof controllerName}:transactionNewSwapApproval`;\n  payload: [{ transactionMeta: TransactionMeta }];\n};\n\n/**\n * Represents the `TransactionController:transactionNewSwap` event.\n */\nexport type TransactionControllerTransactionNewSwapEvent = {\n  type: `${typeof controllerName}:transactionNewSwap`;\n  payload: [{ transactionMeta: TransactionMeta }];\n};\n\n/**\n * Represents the `TransactionController:transactionPublishingSkipped` event.\n */\nexport type TransactionControllerTransactionPublishingSkipped = {\n  type: `${typeof controllerName}:transactionPublishingSkipped`;\n  payload: [transactionMeta: TransactionMeta];\n};\n\n/**\n * Represents the `TransactionController:transactionRejected` event.\n */\nexport type TransactionControllerTransactionRejectedEvent = {\n  type: `${typeof controllerName}:transactionRejected`;\n  payload: [\n    {\n      transactionMeta: TransactionMeta;\n      actionId?: string;\n    },\n  ];\n};\n\n/**\n * Represents the `TransactionController:transactionStatusUpdated` event.\n */\nexport type TransactionControllerTransactionStatusUpdatedEvent = {\n  type: `${typeof controllerName}:transactionStatusUpdated`;\n  payload: [\n    {\n      transactionMeta: TransactionMeta;\n    },\n  ];\n};\n\n/**\n * Represents the `TransactionController:transactionSubmitted` event.\n */\nexport type TransactionControllerTransactionSubmittedEvent = {\n  type: `${typeof controllerName}:transactionSubmitted`;\n  payload: [\n    {\n      transactionMeta: TransactionMeta;\n      actionId?: string;\n    },\n  ];\n};\n\n/**\n * Represents the `TransactionController:unapprovedTransactionAdded` event.\n */\nexport type TransactionControllerUnapprovedTransactionAddedEvent = {\n  type: `${typeof controllerName}:unapprovedTransactionAdded`;\n  payload: [transactionMeta: TransactionMeta];\n};\n\n/**\n * The internal events available to the {@link TransactionController}.\n */\nexport type TransactionControllerEvents =\n  | TransactionControllerIncomingTransactionBlockReceivedEvent\n  | TransactionControllerPostTransactionBalanceUpdatedEvent\n  | TransactionControllerSpeedupTransactionAddedEvent\n  | TransactionControllerStateChangeEvent\n  | TransactionControllerTransactionApprovedEvent\n  | TransactionControllerTransactionConfirmedEvent\n  | TransactionControllerTransactionDroppedEvent\n  | TransactionControllerTransactionFailedEvent\n  | TransactionControllerTransactionFinishedEvent\n  | TransactionControllerTransactionNewSwapApprovalEvent\n  | TransactionControllerTransactionNewSwapEvent\n  | TransactionControllerTransactionPublishingSkipped\n  | TransactionControllerTransactionRejectedEvent\n  | TransactionControllerTransactionStatusUpdatedEvent\n  | TransactionControllerTransactionSubmittedEvent\n  | TransactionControllerUnapprovedTransactionAddedEvent;\n\n/**\n * The messenger of the {@link TransactionController}.\n */\nexport type TransactionControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TransactionControllerActions | AllowedActions,\n  TransactionControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Possible states of the approve transaction step.\n */\nexport enum ApprovalState {\n  Approved = 'approved',\n  NotApproved = 'not-approved',\n  SkippedViaBeforePublishHook = 'skipped-via-before-publish-hook',\n}\n\n/**\n * Get the default TransactionsController state.\n *\n * @returns The default TransactionsController state.\n */\nfunction getDefaultTransactionControllerState(): TransactionControllerState {\n  return {\n    methodData: {},\n    transactions: [],\n    lastFetchedBlockNumbers: {},\n  };\n}\n\n/**\n * Controller responsible for submitting and managing transactions.\n */\nexport class TransactionController extends BaseController<\n  typeof controllerName,\n  TransactionControllerState,\n  TransactionControllerMessenger\n> {\n  #internalEvents = new EventEmitter();\n\n  private readonly isHistoryDisabled: boolean;\n\n  private readonly isSwapsDisabled: boolean;\n\n  private readonly isSendFlowHistoryDisabled: boolean;\n\n  private readonly inProcessOfSigning: Set<string> = new Set();\n\n  private readonly nonceTracker: NonceTracker;\n\n  private readonly registry: MethodRegistry;\n\n  private readonly mutex = new Mutex();\n\n  private readonly gasFeeFlows: GasFeeFlow[];\n\n  private readonly getSavedGasFees: (chainId: Hex) => SavedGasFees | undefined;\n\n  private readonly getNetworkState: () => NetworkState;\n\n  private readonly getCurrentAccountEIP1559Compatibility: () => Promise<boolean>;\n\n  private readonly getCurrentNetworkEIP1559Compatibility: (\n    networkClientId?: NetworkClientId,\n  ) => Promise<boolean>;\n\n  private readonly getGasFeeEstimates: () => Promise<GasFeeState>;\n\n  private readonly getPermittedAccounts: (origin?: string) => Promise<string[]>;\n\n  private readonly getSelectedAddress: () => string;\n\n  private readonly getExternalPendingTransactions: (\n    address: string,\n    chainId?: string,\n  ) => NonceTrackerTransaction[];\n\n  private readonly layer1GasFeeFlows: Layer1GasFeeFlow[];\n\n  readonly #incomingTransactionOptions: IncomingTransactionOptions;\n\n  private readonly incomingTransactionHelper: IncomingTransactionHelper;\n\n  private readonly securityProviderRequest?: SecurityProviderRequest;\n\n  readonly #pendingTransactionOptions: PendingTransactionOptions;\n\n  private readonly pendingTransactionTracker: PendingTransactionTracker;\n\n  private readonly signAbortCallbacks: Map<string, () => void> = new Map();\n\n  #transactionHistoryLimit: number;\n\n  #isSimulationEnabled: () => boolean;\n\n  private readonly afterSign: (\n    transactionMeta: TransactionMeta,\n    signedTx: TypedTransaction,\n  ) => boolean;\n\n  private readonly beforeApproveOnInit: (\n    transactionMeta: TransactionMeta,\n  ) => boolean;\n\n  private readonly beforeCheckPendingTransaction: (\n    transactionMeta: TransactionMeta,\n  ) => boolean;\n\n  private readonly beforePublish: (transactionMeta: TransactionMeta) => boolean;\n\n  private readonly publish: (\n    transactionMeta: TransactionMeta,\n    rawTx: string,\n  ) => Promise<{ transactionHash?: string }>;\n\n  private readonly getAdditionalSignArguments: (\n    transactionMeta: TransactionMeta,\n  ) => (TransactionMeta | undefined)[];\n\n  private failTransaction(\n    transactionMeta: TransactionMeta,\n    error: Error,\n    actionId?: string,\n  ) {\n    const newTransactionMeta = merge({}, transactionMeta, {\n      error: normalizeTxError(error),\n      status: TransactionStatus.failed as const,\n    });\n    this.messagingSystem.publish(`${controllerName}:transactionFailed`, {\n      actionId,\n      error: error.message,\n      transactionMeta: newTransactionMeta,\n    });\n    this.updateTransaction(\n      newTransactionMeta,\n      'TransactionController#failTransaction - Add error message and set status to failed',\n    );\n    this.onTransactionStatusChange(newTransactionMeta);\n    this.messagingSystem.publish(\n      `${controllerName}:transactionFinished`,\n      newTransactionMeta,\n    );\n    this.#internalEvents.emit(\n      `${transactionMeta.id}:finished`,\n      newTransactionMeta,\n    );\n  }\n\n  private async registryLookup(fourBytePrefix: string): Promise<MethodData> {\n    const registryMethod = await this.registry.lookup(fourBytePrefix);\n    if (!registryMethod) {\n      return {\n        registryMethod: '',\n        parsedRegistryMethod: { name: undefined, args: undefined },\n      };\n    }\n    const parsedRegistryMethod = this.registry.parse(registryMethod);\n    return { registryMethod, parsedRegistryMethod };\n  }\n\n  #multichainTrackingHelper: MultichainTrackingHelper;\n\n  /**\n   * Method used to sign transactions\n   */\n  sign?: (\n    transaction: TypedTransaction,\n    from: string,\n    transactionMeta?: TransactionMeta,\n  ) => Promise<TypedTransaction>;\n\n  /**\n   * Constructs a TransactionController.\n   *\n   * @param options - The controller options.\n   * @param options.blockTracker - The block tracker used to poll for new blocks data.\n   * @param options.disableHistory - Whether to disable storing history in transaction metadata.\n   * @param options.disableSendFlowHistory - Explicitly disable transaction metadata history.\n   * @param options.disableSwaps - Whether to disable additional processing on swaps transactions.\n   * @param options.getCurrentAccountEIP1559Compatibility - Whether or not the account supports EIP-1559.\n   * @param options.getCurrentNetworkEIP1559Compatibility - Whether or not the network supports EIP-1559.\n   * @param options.getExternalPendingTransactions - Callback to retrieve pending transactions from external sources.\n   * @param options.getGasFeeEstimates - Callback to retrieve gas fee estimates.\n   * @param options.getNetworkClientRegistry - Gets the network client registry.\n   * @param options.getNetworkState - Gets the state of the network controller.\n   * @param options.getPermittedAccounts - Get accounts that a given origin has permissions for.\n   * @param options.getSavedGasFees - Gets the saved gas fee config.\n   * @param options.getSelectedAddress - Gets the address of the currently selected account.\n   * @param options.incomingTransactions - Configuration options for incoming transaction support.\n   * @param options.isMultichainEnabled - Enable multichain support.\n   * @param options.isSimulationEnabled - Whether new transactions will be automatically simulated.\n   * @param options.messenger - The controller messenger.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.pendingTransactions - Configuration options for pending transaction support.\n   * @param options.provider - The provider used to create the underlying EthQuery instance.\n   * @param options.securityProviderRequest - A function for verifying a transaction, whether it is malicious or not.\n   * @param options.sign - Function used to sign transactions.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.transactionHistoryLimit - Transaction history limit.\n   * @param options.hooks - The controller hooks.\n   */\n  constructor({\n    blockTracker,\n    disableHistory,\n    disableSendFlowHistory,\n    disableSwaps,\n    getCurrentAccountEIP1559Compatibility,\n    getCurrentNetworkEIP1559Compatibility,\n    getExternalPendingTransactions,\n    getGasFeeEstimates,\n    getNetworkClientRegistry,\n    getNetworkState,\n    getPermittedAccounts,\n    getSavedGasFees,\n    getSelectedAddress,\n    incomingTransactions = {},\n    isMultichainEnabled = false,\n    isSimulationEnabled,\n    messenger,\n    onNetworkStateChange,\n    pendingTransactions = {},\n    provider,\n    securityProviderRequest,\n    sign,\n    state,\n    transactionHistoryLimit = 40,\n    hooks,\n  }: TransactionControllerOptions) {\n    super({\n      name: controllerName,\n      metadata,\n      messenger,\n      state: {\n        ...getDefaultTransactionControllerState(),\n        ...state,\n      },\n    });\n\n    this.messagingSystem = messenger;\n    this.getNetworkState = getNetworkState;\n    this.isSendFlowHistoryDisabled = disableSendFlowHistory ?? false;\n    this.isHistoryDisabled = disableHistory ?? false;\n    this.isSwapsDisabled = disableSwaps ?? false;\n    this.#isSimulationEnabled = isSimulationEnabled ?? (() => true);\n    // @ts-expect-error the type in eth-method-registry is inappropriate and should be changed\n    this.registry = new MethodRegistry({ provider });\n    this.getSavedGasFees = getSavedGasFees ?? ((_chainId) => undefined);\n    this.getCurrentAccountEIP1559Compatibility =\n      getCurrentAccountEIP1559Compatibility ?? (() => Promise.resolve(true));\n    this.getCurrentNetworkEIP1559Compatibility =\n      getCurrentNetworkEIP1559Compatibility;\n    this.getGasFeeEstimates =\n      getGasFeeEstimates || (() => Promise.resolve({} as GasFeeState));\n    this.getPermittedAccounts = getPermittedAccounts;\n    this.getSelectedAddress = getSelectedAddress;\n    this.getExternalPendingTransactions =\n      getExternalPendingTransactions ?? (() => []);\n    this.securityProviderRequest = securityProviderRequest;\n    this.#incomingTransactionOptions = incomingTransactions;\n    this.#pendingTransactionOptions = pendingTransactions;\n    this.#transactionHistoryLimit = transactionHistoryLimit;\n    this.sign = sign;\n\n    this.afterSign = hooks?.afterSign ?? (() => true);\n    this.beforeApproveOnInit = hooks?.beforeApproveOnInit ?? (() => true);\n    this.beforeCheckPendingTransaction =\n      hooks?.beforeCheckPendingTransaction ??\n      /* istanbul ignore next */\n      (() => true);\n    this.beforePublish = hooks?.beforePublish ?? (() => true);\n    this.getAdditionalSignArguments =\n      hooks?.getAdditionalSignArguments ?? (() => []);\n    this.publish =\n      hooks?.publish ?? (() => Promise.resolve({ transactionHash: undefined }));\n\n    this.nonceTracker = this.#createNonceTracker({\n      provider,\n      blockTracker,\n    });\n\n    this.#multichainTrackingHelper = new MultichainTrackingHelper({\n      isMultichainEnabled,\n      provider,\n      nonceTracker: this.nonceTracker,\n      incomingTransactionOptions: incomingTransactions,\n      findNetworkClientIdByChainId: (chainId: Hex) => {\n        return this.messagingSystem.call(\n          `NetworkController:findNetworkClientIdByChainId`,\n          chainId,\n        );\n      },\n      getNetworkClientById: ((networkClientId: NetworkClientId) => {\n        return this.messagingSystem.call(\n          `NetworkController:getNetworkClientById`,\n          networkClientId,\n        );\n      }) as NetworkController['getNetworkClientById'],\n      getNetworkClientRegistry,\n      removeIncomingTransactionHelperListeners:\n        this.#removeIncomingTransactionHelperListeners.bind(this),\n      removePendingTransactionTrackerListeners:\n        this.#removePendingTransactionTrackerListeners.bind(this),\n      createNonceTracker: this.#createNonceTracker.bind(this),\n      createIncomingTransactionHelper:\n        this.#createIncomingTransactionHelper.bind(this),\n      createPendingTransactionTracker:\n        this.#createPendingTransactionTracker.bind(this),\n      onNetworkStateChange: (listener) => {\n        this.messagingSystem.subscribe(\n          'NetworkController:stateChange',\n          listener,\n        );\n      },\n    });\n    this.#multichainTrackingHelper.initialize();\n\n    const etherscanRemoteTransactionSource =\n      new EtherscanRemoteTransactionSource({\n        includeTokenTransfers: incomingTransactions.includeTokenTransfers,\n      });\n\n    this.incomingTransactionHelper = this.#createIncomingTransactionHelper({\n      blockTracker,\n      etherscanRemoteTransactionSource,\n    });\n\n    this.pendingTransactionTracker = this.#createPendingTransactionTracker({\n      provider,\n      blockTracker,\n    });\n\n    this.gasFeeFlows = this.#getGasFeeFlows();\n    this.layer1GasFeeFlows = this.#getLayer1GasFeeFlows();\n\n    const gasFeePoller = new GasFeePoller({\n      // Default gas fee polling is not yet supported by the clients\n      gasFeeFlows: this.gasFeeFlows.slice(0, -1),\n      getGasFeeControllerEstimates: this.getGasFeeEstimates,\n      getProvider: (chainId, networkClientId) =>\n        this.#multichainTrackingHelper.getProvider({\n          networkClientId,\n          chainId,\n        }),\n      getTransactions: () => this.state.transactions,\n      layer1GasFeeFlows: this.layer1GasFeeFlows,\n      onStateChange: (listener) => {\n        this.messagingSystem.subscribe(\n          'TransactionController:stateChange',\n          listener,\n        );\n      },\n    });\n\n    gasFeePoller.hub.on(\n      'transaction-updated',\n      this.#onGasFeePollerTransactionUpdate.bind(this),\n    );\n\n    // when transactionsController state changes\n    // check for pending transactions and start polling if there are any\n    this.messagingSystem.subscribe(\n      'TransactionController:stateChange',\n      this.#checkForPendingTransactionAndStartPolling,\n    );\n\n    // TODO once v2 is merged make sure this only runs when\n    // selectedNetworkClientId changes\n    onNetworkStateChange(() => {\n      log('Detected network change', this.getChainId());\n      this.pendingTransactionTracker.startIfPendingTransactions();\n      this.onBootCleanup();\n    });\n\n    this.onBootCleanup();\n    this.#checkForPendingTransactionAndStartPolling();\n  }\n\n  /**\n   * Stops polling and removes listeners to prepare the controller for garbage collection.\n   */\n  destroy() {\n    this.#stopAllTracking();\n  }\n\n  /**\n   * Handle new method data request.\n   *\n   * @param fourBytePrefix - The method prefix.\n   * @returns The method data object corresponding to the given signature prefix.\n   */\n  async handleMethodData(fourBytePrefix: string): Promise<MethodData> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const { methodData } = this.state;\n      const knownMethod = Object.keys(methodData).find(\n        (knownFourBytePrefix) => fourBytePrefix === knownFourBytePrefix,\n      );\n      if (knownMethod) {\n        return methodData[fourBytePrefix];\n      }\n      const registry = await this.registryLookup(fourBytePrefix);\n      this.update((state) => {\n        state.methodData[fourBytePrefix] = registry;\n      });\n      return registry;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a new unapproved transaction to state. Parameters will be validated, a\n   * unique transaction id will be generated, and gas and gasPrice will be calculated\n   * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.\n   *\n   * @param txParams - Standard parameters for an Ethereum transaction.\n   * @param opts - Additional options to control how the transaction is added.\n   * @param opts.actionId - Unique ID to prevent duplicate requests.\n   * @param opts.deviceConfirmedOn - An enum to indicate what device confirmed the transaction.\n   * @param opts.method - RPC method that requested the transaction.\n   * @param opts.origin - The origin of the transaction request, such as a dApp hostname.\n   * @param opts.requireApproval - Whether the transaction requires approval by the user, defaults to true unless explicitly disabled.\n   * @param opts.securityAlertResponse - Response from security validator.\n   * @param opts.sendFlowHistory - The sendFlowHistory entries to add.\n   * @param opts.type - Type of transaction to add, such as 'cancel' or 'swap'.\n   * @param opts.swaps - Options for swaps transactions.\n   * @param opts.swaps.hasApproveTx - Whether the transaction has an approval transaction.\n   * @param opts.swaps.meta - Metadata for swap transaction.\n   * @param opts.networkClientId - The id of the network client for this transaction.\n   * @returns Object containing a promise resolving to the transaction hash if approved.\n   */\n  async addTransaction(\n    txParams: TransactionParams,\n    {\n      actionId,\n      deviceConfirmedOn,\n      method,\n      origin,\n      requireApproval,\n      securityAlertResponse,\n      sendFlowHistory,\n      swaps = {},\n      type,\n      networkClientId,\n    }: {\n      actionId?: string;\n      deviceConfirmedOn?: WalletDevice;\n      method?: string;\n      origin?: string;\n      requireApproval?: boolean | undefined;\n      securityAlertResponse?: SecurityAlertResponse;\n      sendFlowHistory?: SendFlowHistoryEntry[];\n      swaps?: {\n        hasApproveTx?: boolean;\n        meta?: Partial<TransactionMeta>;\n      };\n      type?: TransactionType;\n      networkClientId?: NetworkClientId;\n    } = {},\n  ): Promise<Result> {\n    log('Adding transaction', txParams);\n\n    txParams = normalizeTransactionParams(txParams);\n    if (\n      networkClientId &&\n      !this.#multichainTrackingHelper.has(networkClientId)\n    ) {\n      throw new Error(\n        'The networkClientId for this transaction could not be found',\n      );\n    }\n\n    const isEIP1559Compatible = await this.getEIP1559Compatibility(\n      networkClientId,\n    );\n\n    validateTxParams(txParams, isEIP1559Compatible);\n\n    if (origin) {\n      await validateTransactionOrigin(\n        await this.getPermittedAccounts(origin),\n        this.getSelectedAddress(),\n        txParams.from,\n        origin,\n      );\n    }\n\n    const dappSuggestedGasFees = this.generateDappSuggestedGasFees(\n      txParams,\n      origin,\n    );\n\n    const chainId = this.getChainId(networkClientId);\n    const ethQuery = this.#multichainTrackingHelper.getEthQuery({\n      networkClientId,\n      chainId,\n    });\n\n    const transactionType =\n      type ?? (await determineTransactionType(txParams, ethQuery)).type;\n\n    const existingTransactionMeta = this.getTransactionWithActionId(actionId);\n\n    // If a request to add a transaction with the same actionId is submitted again, a new transaction will not be created for it.\n    let addedTransactionMeta = existingTransactionMeta\n      ? cloneDeep(existingTransactionMeta)\n      : {\n          // Add actionId to txMeta to check if same actionId is seen again\n          actionId,\n          chainId,\n          dappSuggestedGasFees,\n          deviceConfirmedOn,\n          id: random(),\n          origin,\n          securityAlertResponse,\n          status: TransactionStatus.unapproved as const,\n          time: Date.now(),\n          txParams,\n          userEditedGasLimit: false,\n          verifiedOnBlockchain: false,\n          type: transactionType,\n          networkClientId,\n        };\n\n    await this.updateGasProperties(addedTransactionMeta);\n\n    // Checks if a transaction already exists with a given actionId\n    if (!existingTransactionMeta) {\n      // Set security provider response\n      if (method && this.securityProviderRequest) {\n        const securityProviderResponse = await this.securityProviderRequest(\n          addedTransactionMeta,\n          method,\n        );\n        addedTransactionMeta.securityProviderResponse =\n          securityProviderResponse;\n      }\n\n      if (!this.isSendFlowHistoryDisabled) {\n        addedTransactionMeta.sendFlowHistory = sendFlowHistory ?? [];\n      }\n      // Initial history push\n      if (!this.isHistoryDisabled) {\n        addedTransactionMeta = addInitialHistorySnapshot(addedTransactionMeta);\n      }\n\n      addedTransactionMeta = updateSwapsTransaction(\n        addedTransactionMeta,\n        transactionType,\n        swaps,\n        {\n          isSwapsDisabled: this.isSwapsDisabled,\n          cancelTransaction: this.cancelTransaction.bind(this),\n          messenger: this.messagingSystem,\n        },\n      );\n\n      this.addMetadata(addedTransactionMeta);\n\n      if (requireApproval !== false) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.#updateSimulationData(addedTransactionMeta);\n      } else {\n        log('Skipping simulation as approval not required');\n      }\n\n      this.messagingSystem.publish(\n        `${controllerName}:unapprovedTransactionAdded`,\n        addedTransactionMeta,\n      );\n    }\n\n    return {\n      result: this.processApproval(addedTransactionMeta, {\n        isExisting: Boolean(existingTransactionMeta),\n        requireApproval,\n        actionId,\n      }),\n      transactionMeta: addedTransactionMeta,\n    };\n  }\n\n  startIncomingTransactionPolling(networkClientIds: NetworkClientId[] = []) {\n    if (networkClientIds.length === 0) {\n      this.incomingTransactionHelper.start();\n      return;\n    }\n    this.#multichainTrackingHelper.startIncomingTransactionPolling(\n      networkClientIds,\n    );\n  }\n\n  stopIncomingTransactionPolling(networkClientIds: NetworkClientId[] = []) {\n    if (networkClientIds.length === 0) {\n      this.incomingTransactionHelper.stop();\n      return;\n    }\n    this.#multichainTrackingHelper.stopIncomingTransactionPolling(\n      networkClientIds,\n    );\n  }\n\n  stopAllIncomingTransactionPolling() {\n    this.incomingTransactionHelper.stop();\n    this.#multichainTrackingHelper.stopAllIncomingTransactionPolling();\n  }\n\n  async updateIncomingTransactions(networkClientIds: NetworkClientId[] = []) {\n    if (networkClientIds.length === 0) {\n      await this.incomingTransactionHelper.update();\n      return;\n    }\n    await this.#multichainTrackingHelper.updateIncomingTransactions(\n      networkClientIds,\n    );\n  }\n\n  /**\n   * Attempts to cancel a transaction based on its ID by setting its status to \"rejected\"\n   * and emitting a `<tx.id>:finished` hub event.\n   *\n   * @param transactionId - The ID of the transaction to cancel.\n   * @param gasValues - The gas values to use for the cancellation transaction.\n   * @param options - The options for the cancellation transaction.\n   * @param options.actionId - Unique ID to prevent duplicate requests.\n   * @param options.estimatedBaseFee - The estimated base fee of the transaction.\n   */\n  async stopTransaction(\n    transactionId: string,\n    gasValues?: GasPriceValue | FeeMarketEIP1559Values,\n    {\n      estimatedBaseFee,\n      actionId,\n    }: { estimatedBaseFee?: string; actionId?: string } = {},\n  ) {\n    // If transaction is found for same action id, do not create a cancel transaction.\n    if (this.getTransactionWithActionId(actionId)) {\n      return;\n    }\n\n    if (gasValues) {\n      // Not good practice to reassign a parameter but temporarily avoiding a larger refactor.\n      gasValues = normalizeGasFeeValues(gasValues);\n      validateGasValues(gasValues);\n    }\n\n    log('Creating cancel transaction', transactionId, gasValues);\n\n    const transactionMeta = this.getTransaction(transactionId);\n    if (!transactionMeta) {\n      return;\n    }\n\n    if (!this.sign) {\n      throw new Error('No sign method defined.');\n    }\n\n    // gasPrice (legacy non EIP1559)\n    const minGasPrice = getIncreasedPriceFromExisting(\n      transactionMeta.txParams.gasPrice,\n      CANCEL_RATE,\n    );\n\n    const gasPriceFromValues = isGasPriceValue(gasValues) && gasValues.gasPrice;\n\n    const newGasPrice =\n      (gasPriceFromValues &&\n        validateMinimumIncrease(gasPriceFromValues, minGasPrice)) ||\n      minGasPrice;\n\n    // maxFeePerGas (EIP1559)\n    const existingMaxFeePerGas = transactionMeta.txParams?.maxFeePerGas;\n    const minMaxFeePerGas = getIncreasedPriceFromExisting(\n      existingMaxFeePerGas,\n      CANCEL_RATE,\n    );\n    const maxFeePerGasValues =\n      isFeeMarketEIP1559Values(gasValues) && gasValues.maxFeePerGas;\n    const newMaxFeePerGas =\n      (maxFeePerGasValues &&\n        validateMinimumIncrease(maxFeePerGasValues, minMaxFeePerGas)) ||\n      (existingMaxFeePerGas && minMaxFeePerGas);\n\n    // maxPriorityFeePerGas (EIP1559)\n    const existingMaxPriorityFeePerGas =\n      transactionMeta.txParams?.maxPriorityFeePerGas;\n    const minMaxPriorityFeePerGas = getIncreasedPriceFromExisting(\n      existingMaxPriorityFeePerGas,\n      CANCEL_RATE,\n    );\n    const maxPriorityFeePerGasValues =\n      isFeeMarketEIP1559Values(gasValues) && gasValues.maxPriorityFeePerGas;\n    const newMaxPriorityFeePerGas =\n      (maxPriorityFeePerGasValues &&\n        validateMinimumIncrease(\n          maxPriorityFeePerGasValues,\n          minMaxPriorityFeePerGas,\n        )) ||\n      (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);\n\n    const newTxParams: TransactionParams =\n      newMaxFeePerGas && newMaxPriorityFeePerGas\n        ? {\n            from: transactionMeta.txParams.from,\n            gasLimit: transactionMeta.txParams.gas,\n            maxFeePerGas: newMaxFeePerGas,\n            maxPriorityFeePerGas: newMaxPriorityFeePerGas,\n            type: TransactionEnvelopeType.feeMarket,\n            nonce: transactionMeta.txParams.nonce,\n            to: transactionMeta.txParams.from,\n            value: '0x0',\n          }\n        : {\n            from: transactionMeta.txParams.from,\n            gasLimit: transactionMeta.txParams.gas,\n            gasPrice: newGasPrice,\n            nonce: transactionMeta.txParams.nonce,\n            to: transactionMeta.txParams.from,\n            value: '0x0',\n          };\n\n    const unsignedEthTx = this.prepareUnsignedEthTx(\n      transactionMeta.chainId,\n      newTxParams,\n    );\n\n    const signedTx = await this.sign(\n      unsignedEthTx,\n      transactionMeta.txParams.from,\n    );\n\n    const rawTx = bufferToHex(signedTx.serialize());\n\n    const newFee = newTxParams.maxFeePerGas ?? newTxParams.gasPrice;\n\n    const oldFee = newTxParams.maxFeePerGas\n      ? transactionMeta.txParams.maxFeePerGas\n      : transactionMeta.txParams.gasPrice;\n\n    log('Submitting cancel transaction', {\n      oldFee,\n      newFee,\n      txParams: newTxParams,\n    });\n\n    const ethQuery = this.#multichainTrackingHelper.getEthQuery({\n      networkClientId: transactionMeta.networkClientId,\n      chainId: transactionMeta.chainId,\n    });\n    const hash = await this.publishTransactionForRetry(\n      ethQuery,\n      rawTx,\n      transactionMeta,\n    );\n\n    const cancelTransactionMeta = {\n      actionId,\n      chainId: transactionMeta.chainId,\n      networkClientId: transactionMeta.networkClientId,\n      estimatedBaseFee,\n      hash,\n      id: random(),\n      originalGasEstimate: transactionMeta.txParams.gas,\n      status: TransactionStatus.submitted as const,\n      time: Date.now(),\n      type: TransactionType.cancel as const,\n      txParams: newTxParams,\n    };\n\n    this.addMetadata(cancelTransactionMeta);\n\n    // stopTransaction has no approval request, so we assume the user has already approved the transaction\n    this.messagingSystem.publish(`${controllerName}:transactionApproved`, {\n      transactionMeta: cancelTransactionMeta,\n      actionId,\n    });\n    this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {\n      transactionMeta: cancelTransactionMeta,\n      actionId,\n    });\n\n    this.messagingSystem.publish(\n      `${controllerName}:transactionFinished`,\n      cancelTransactionMeta,\n    );\n    this.#internalEvents.emit(\n      `${transactionMeta.id}:finished`,\n      cancelTransactionMeta,\n    );\n  }\n\n  /**\n   * Attempts to speed up a transaction increasing transaction gasPrice by ten percent.\n   *\n   * @param transactionId - The ID of the transaction to speed up.\n   * @param gasValues - The gas values to use for the speed up transaction.\n   * @param options - The options for the speed up transaction.\n   * @param options.actionId - Unique ID to prevent duplicate requests\n   * @param options.estimatedBaseFee - The estimated base fee of the transaction.\n   */\n  async speedUpTransaction(\n    transactionId: string,\n    gasValues?: GasPriceValue | FeeMarketEIP1559Values,\n    {\n      actionId,\n      estimatedBaseFee,\n    }: { actionId?: string; estimatedBaseFee?: string } = {},\n  ) {\n    // If transaction is found for same action id, do not create a new speed up transaction.\n    if (this.getTransactionWithActionId(actionId)) {\n      return;\n    }\n\n    if (gasValues) {\n      // Not good practice to reassign a parameter but temporarily avoiding a larger refactor.\n      gasValues = normalizeGasFeeValues(gasValues);\n      validateGasValues(gasValues);\n    }\n\n    log('Creating speed up transaction', transactionId, gasValues);\n\n    const transactionMeta = this.state.transactions.find(\n      ({ id }) => id === transactionId,\n    );\n    /* istanbul ignore next */\n    if (!transactionMeta) {\n      return;\n    }\n\n    /* istanbul ignore next */\n    if (!this.sign) {\n      throw new Error('No sign method defined.');\n    }\n\n    // gasPrice (legacy non EIP1559)\n    const minGasPrice = getIncreasedPriceFromExisting(\n      transactionMeta.txParams.gasPrice,\n      SPEED_UP_RATE,\n    );\n\n    const gasPriceFromValues = isGasPriceValue(gasValues) && gasValues.gasPrice;\n\n    const newGasPrice =\n      (gasPriceFromValues &&\n        validateMinimumIncrease(gasPriceFromValues, minGasPrice)) ||\n      minGasPrice;\n\n    // maxFeePerGas (EIP1559)\n    const existingMaxFeePerGas = transactionMeta.txParams?.maxFeePerGas;\n    const minMaxFeePerGas = getIncreasedPriceFromExisting(\n      existingMaxFeePerGas,\n      SPEED_UP_RATE,\n    );\n    const maxFeePerGasValues =\n      isFeeMarketEIP1559Values(gasValues) && gasValues.maxFeePerGas;\n    const newMaxFeePerGas =\n      (maxFeePerGasValues &&\n        validateMinimumIncrease(maxFeePerGasValues, minMaxFeePerGas)) ||\n      (existingMaxFeePerGas && minMaxFeePerGas);\n\n    // maxPriorityFeePerGas (EIP1559)\n    const existingMaxPriorityFeePerGas =\n      transactionMeta.txParams?.maxPriorityFeePerGas;\n    const minMaxPriorityFeePerGas = getIncreasedPriceFromExisting(\n      existingMaxPriorityFeePerGas,\n      SPEED_UP_RATE,\n    );\n    const maxPriorityFeePerGasValues =\n      isFeeMarketEIP1559Values(gasValues) && gasValues.maxPriorityFeePerGas;\n    const newMaxPriorityFeePerGas =\n      (maxPriorityFeePerGasValues &&\n        validateMinimumIncrease(\n          maxPriorityFeePerGasValues,\n          minMaxPriorityFeePerGas,\n        )) ||\n      (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);\n\n    const txParams: TransactionParams =\n      newMaxFeePerGas && newMaxPriorityFeePerGas\n        ? {\n            ...transactionMeta.txParams,\n            gasLimit: transactionMeta.txParams.gas,\n            maxFeePerGas: newMaxFeePerGas,\n            maxPriorityFeePerGas: newMaxPriorityFeePerGas,\n            type: TransactionEnvelopeType.feeMarket,\n          }\n        : {\n            ...transactionMeta.txParams,\n            gasLimit: transactionMeta.txParams.gas,\n            gasPrice: newGasPrice,\n          };\n\n    const unsignedEthTx = this.prepareUnsignedEthTx(\n      transactionMeta.chainId,\n      txParams,\n    );\n\n    const signedTx = await this.sign(\n      unsignedEthTx,\n      transactionMeta.txParams.from,\n    );\n\n    const transactionMetaWithRsv = await this.updateTransactionMetaRSV(\n      transactionMeta,\n      signedTx,\n    );\n    const rawTx = bufferToHex(signedTx.serialize());\n\n    const newFee = txParams.maxFeePerGas ?? txParams.gasPrice;\n\n    const oldFee = txParams.maxFeePerGas\n      ? transactionMetaWithRsv.txParams.maxFeePerGas\n      : transactionMetaWithRsv.txParams.gasPrice;\n\n    log('Submitting speed up transaction', { oldFee, newFee, txParams });\n\n    const ethQuery = this.#multichainTrackingHelper.getEthQuery({\n      networkClientId: transactionMeta.networkClientId,\n      chainId: transactionMeta.chainId,\n    });\n    const hash = await this.publishTransactionForRetry(\n      ethQuery,\n      rawTx,\n      transactionMeta,\n    );\n\n    const baseTransactionMeta = {\n      ...transactionMetaWithRsv,\n      estimatedBaseFee,\n      id: random(),\n      time: Date.now(),\n      hash,\n      actionId,\n      originalGasEstimate: transactionMeta.txParams.gas,\n      type: TransactionType.retry as const,\n      originalType: transactionMeta.type,\n    };\n\n    const newTransactionMeta =\n      newMaxFeePerGas && newMaxPriorityFeePerGas\n        ? {\n            ...baseTransactionMeta,\n            txParams: {\n              ...transactionMeta.txParams,\n              maxFeePerGas: newMaxFeePerGas,\n              maxPriorityFeePerGas: newMaxPriorityFeePerGas,\n            },\n          }\n        : {\n            ...baseTransactionMeta,\n            txParams: {\n              ...transactionMeta.txParams,\n              gasPrice: newGasPrice,\n            },\n          };\n\n    this.addMetadata(newTransactionMeta);\n\n    // speedUpTransaction has no approval request, so we assume the user has already approved the transaction\n    this.messagingSystem.publish(`${controllerName}:transactionApproved`, {\n      transactionMeta: newTransactionMeta,\n      actionId,\n    });\n\n    this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {\n      transactionMeta: newTransactionMeta,\n      actionId,\n    });\n\n    this.messagingSystem.publish(\n      `${controllerName}:speedupTransactionAdded`,\n      newTransactionMeta,\n    );\n  }\n\n  /**\n   * Estimates required gas for a given transaction.\n   *\n   * @param transaction - The transaction to estimate gas for.\n   * @param networkClientId - The network client id to use for the estimate.\n   * @returns The gas and gas price.\n   */\n  async estimateGas(\n    transaction: TransactionParams,\n    networkClientId?: NetworkClientId,\n  ) {\n    const ethQuery = this.#multichainTrackingHelper.getEthQuery({\n      networkClientId,\n    });\n    const { estimatedGas, simulationFails } = await estimateGas(\n      transaction,\n      ethQuery,\n    );\n\n    return { gas: estimatedGas, simulationFails };\n  }\n\n  /**\n   * Estimates required gas for a given transaction and add additional gas buffer with the given multiplier.\n   *\n   * @param transaction - The transaction params to estimate gas for.\n   * @param multiplier - The multiplier to use for the gas buffer.\n   * @param networkClientId - The network client id to use for the estimate.\n   */\n  async estimateGasBuffered(\n    transaction: TransactionParams,\n    multiplier: number,\n    networkClientId?: NetworkClientId,\n  ) {\n    const ethQuery = this.#multichainTrackingHelper.getEthQuery({\n      networkClientId,\n    });\n    const { blockGasLimit, estimatedGas, simulationFails } = await estimateGas(\n      transaction,\n      ethQuery,\n    );\n\n    const gas = addGasBuffer(estimatedGas, blockGasLimit, multiplier);\n\n    return {\n      gas,\n      simulationFails,\n    };\n  }\n\n  /**\n   * Updates an existing transaction in state.\n   *\n   * @param transactionMeta - The new transaction to store in state.\n   * @param note - A note or update reason to include in the transaction history.\n   */\n  updateTransaction(transactionMeta: TransactionMeta, note: string) {\n    const { id: transactionId } = transactionMeta;\n\n    this.#updateTransactionInternal(\n      { transactionId, note, skipHistory: this.isHistoryDisabled },\n      () => ({ ...transactionMeta }),\n    );\n  }\n\n  /**\n   * Update the security alert response for a transaction.\n   *\n   * @param transactionId - ID of the transaction.\n   * @param securityAlertResponse - The new security alert response for the transaction.\n   */\n  updateSecurityAlertResponse(\n    transactionId: string,\n    securityAlertResponse: SecurityAlertResponse,\n  ) {\n    if (!securityAlertResponse) {\n      throw new Error(\n        'updateSecurityAlertResponse: securityAlertResponse should not be null',\n      );\n    }\n    const transactionMeta = this.getTransaction(transactionId);\n    if (!transactionMeta) {\n      throw new Error(\n        `Cannot update security alert response as no transaction metadata found`,\n      );\n    }\n    const updatedTransactionMeta = {\n      ...transactionMeta,\n      securityAlertResponse,\n    };\n    this.updateTransaction(\n      updatedTransactionMeta,\n      `${controllerName}:updatesecurityAlertResponse - securityAlertResponse updated`,\n    );\n  }\n\n  /**\n   * Removes all transactions from state, optionally based on the current network.\n   *\n   * @param ignoreNetwork - Determines whether to wipe all transactions, or just those on the\n   * current network. If `true`, all transactions are wiped.\n   * @param address - If specified, only transactions originating from this address will be\n   * wiped on current network.\n   */\n  wipeTransactions(ignoreNetwork?: boolean, address?: string) {\n    /* istanbul ignore next */\n    if (ignoreNetwork && !address) {\n      this.update((state) => {\n        state.transactions = [];\n      });\n      return;\n    }\n    const currentChainId = this.getChainId();\n    const newTransactions = this.state.transactions.filter(\n      ({ chainId, txParams }) => {\n        const isMatchingNetwork = ignoreNetwork || chainId === currentChainId;\n\n        if (!isMatchingNetwork) {\n          return true;\n        }\n\n        const isMatchingAddress =\n          !address || txParams.from?.toLowerCase() === address.toLowerCase();\n\n        return !isMatchingAddress;\n      },\n    );\n\n    this.update((state) => {\n      state.transactions = this.trimTransactionsForState(newTransactions);\n    });\n  }\n\n  /**\n   * Adds external provided transaction to state as confirmed transaction.\n   *\n   * @param transactionMeta - TransactionMeta to add transactions.\n   * @param transactionReceipt - TransactionReceipt of the external transaction.\n   * @param baseFeePerGas - Base fee per gas of the external transaction.\n   */\n  async confirmExternalTransaction(\n    transactionMeta: TransactionMeta,\n    transactionReceipt: TransactionReceipt,\n    baseFeePerGas: Hex,\n  ) {\n    // Run validation and add external transaction to state.\n    const newTransactionMeta = this.addExternalTransaction(transactionMeta);\n\n    try {\n      const transactionId = newTransactionMeta.id;\n\n      // Make sure status is confirmed and define gasUsed as in receipt.\n      const updatedTransactionMeta = {\n        ...newTransactionMeta,\n        status: TransactionStatus.confirmed as const,\n        txReceipt: transactionReceipt,\n      };\n      if (baseFeePerGas) {\n        updatedTransactionMeta.baseFeePerGas = baseFeePerGas;\n      }\n\n      // Update same nonce local transactions as dropped and define replacedBy properties.\n      this.markNonceDuplicatesDropped(transactionId);\n\n      // Update external provided transaction with updated gas values and confirmed status.\n      this.updateTransaction(\n        updatedTransactionMeta,\n        `${controllerName}:confirmExternalTransaction - Add external transaction`,\n      );\n      this.onTransactionStatusChange(updatedTransactionMeta);\n\n      // Intentional given potential duration of process.\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.updatePostBalance(updatedTransactionMeta);\n\n      this.messagingSystem.publish(\n        `${controllerName}:transactionConfirmed`,\n        updatedTransactionMeta,\n      );\n    } catch (error) {\n      console.error('Failed to confirm external transaction', error);\n    }\n  }\n\n  /**\n   * Append new send flow history to a transaction.\n   *\n   * @param transactionID - The ID of the transaction to update.\n   * @param currentSendFlowHistoryLength - The length of the current sendFlowHistory array.\n   * @param sendFlowHistoryToAdd - The sendFlowHistory entries to add.\n   * @returns The updated transactionMeta.\n   */\n  updateTransactionSendFlowHistory(\n    transactionID: string,\n    currentSendFlowHistoryLength: number,\n    sendFlowHistoryToAdd: SendFlowHistoryEntry[],\n  ): TransactionMeta {\n    if (this.isSendFlowHistoryDisabled) {\n      throw new Error(\n        'Send flow history is disabled for the current transaction controller',\n      );\n    }\n\n    const transactionMeta = this.getTransaction(transactionID);\n\n    if (!transactionMeta) {\n      throw new Error(\n        `Cannot update send flow history as no transaction metadata found`,\n      );\n    }\n\n    validateIfTransactionUnapproved(\n      transactionMeta,\n      'updateTransactionSendFlowHistory',\n    );\n\n    const sendFlowHistory = transactionMeta.sendFlowHistory ?? [];\n    if (currentSendFlowHistoryLength === sendFlowHistory.length) {\n      const updatedTransactionMeta = {\n        ...transactionMeta,\n        sendFlowHistory: [...sendFlowHistory, ...sendFlowHistoryToAdd],\n      };\n      this.updateTransaction(\n        updatedTransactionMeta,\n        `${controllerName}:updateTransactionSendFlowHistory - sendFlowHistory updated`,\n      );\n    }\n\n    return this.getTransaction(transactionID) as TransactionMeta;\n  }\n\n  /**\n   * Update the gas values of a transaction.\n   *\n   * @param transactionId - The ID of the transaction to update.\n   * @param gasValues - Gas values to update.\n   * @param gasValues.gas - Same as transaction.gasLimit.\n   * @param gasValues.gasLimit - Maxmimum number of units of gas to use for this transaction.\n   * @param gasValues.gasPrice - Price per gas for legacy transactions.\n   * @param gasValues.maxPriorityFeePerGas - Maximum amount per gas to give to validator as incentive.\n   * @param gasValues.maxFeePerGas - Maximum amount per gas to pay for the transaction, including the priority fee.\n   * @param gasValues.estimateUsed - Which estimate level was used.\n   * @param gasValues.estimateSuggested - Which estimate level that the API suggested.\n   * @param gasValues.defaultGasEstimates - The default estimate for gas.\n   * @param gasValues.originalGasEstimate - Original estimate for gas.\n   * @param gasValues.userEditedGasLimit - The gas limit supplied by user.\n   * @param gasValues.userFeeLevel - Estimate level user selected.\n   * @returns The updated transactionMeta.\n   */\n  updateTransactionGasFees(\n    transactionId: string,\n    {\n      defaultGasEstimates,\n      estimateUsed,\n      estimateSuggested,\n      gas,\n      gasLimit,\n      gasPrice,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      originalGasEstimate,\n      userEditedGasLimit,\n      userFeeLevel,\n    }: {\n      defaultGasEstimates?: string;\n      estimateUsed?: string;\n      estimateSuggested?: string;\n      gas?: string;\n      gasLimit?: string;\n      gasPrice?: string;\n      maxPriorityFeePerGas?: string;\n      maxFeePerGas?: string;\n      originalGasEstimate?: string;\n      userEditedGasLimit?: boolean;\n      userFeeLevel?: string;\n    },\n  ): TransactionMeta {\n    const transactionMeta = this.getTransaction(transactionId);\n\n    if (!transactionMeta) {\n      throw new Error(\n        `Cannot update transaction as no transaction metadata found`,\n      );\n    }\n\n    validateIfTransactionUnapproved(\n      transactionMeta,\n      'updateTransactionGasFees',\n    );\n\n    let transactionGasFees = {\n      txParams: {\n        gas,\n        gasLimit,\n        gasPrice,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n      },\n      defaultGasEstimates,\n      estimateUsed,\n      estimateSuggested,\n      originalGasEstimate,\n      userEditedGasLimit,\n      userFeeLevel,\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any;\n\n    // only update what is defined\n    transactionGasFees.txParams = pickBy(transactionGasFees.txParams);\n    transactionGasFees = pickBy(transactionGasFees);\n\n    // merge updated gas values with existing transaction meta\n    const updatedMeta = merge({}, transactionMeta, transactionGasFees);\n\n    this.updateTransaction(\n      updatedMeta,\n      `${controllerName}:updateTransactionGasFees - gas values updated`,\n    );\n\n    return this.getTransaction(transactionId) as TransactionMeta;\n  }\n\n  /**\n   * Update the previous gas values of a transaction.\n   *\n   * @param transactionId - The ID of the transaction to update.\n   * @param previousGas - Previous gas values to update.\n   * @param previousGas.gasLimit - Maxmimum number of units of gas to use for this transaction.\n   * @param previousGas.maxFeePerGas - Maximum amount per gas to pay for the transaction, including the priority fee.\n   * @param previousGas.maxPriorityFeePerGas - Maximum amount per gas to give to validator as incentive.\n   * @returns The updated transactionMeta.\n   */\n  updatePreviousGasParams(\n    transactionId: string,\n    {\n      gasLimit,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    }: {\n      gasLimit?: string;\n      maxFeePerGas?: string;\n      maxPriorityFeePerGas?: string;\n    },\n  ): TransactionMeta {\n    const transactionMeta = this.getTransaction(transactionId);\n\n    if (!transactionMeta) {\n      throw new Error(\n        `Cannot update transaction as no transaction metadata found`,\n      );\n    }\n\n    validateIfTransactionUnapproved(transactionMeta, 'updatePreviousGasParams');\n\n    const transactionPreviousGas = {\n      previousGas: {\n        gasLimit,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n      },\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any;\n\n    // only update what is defined\n    transactionPreviousGas.previousGas = pickBy(\n      transactionPreviousGas.previousGas,\n    );\n\n    // merge updated previous gas values with existing transaction meta\n    const updatedMeta = merge({}, transactionMeta, transactionPreviousGas);\n\n    this.updateTransaction(\n      updatedMeta,\n      `${controllerName}:updatePreviousGasParams - Previous gas values updated`,\n    );\n\n    return this.getTransaction(transactionId) as TransactionMeta;\n  }\n\n  async getNonceLock(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NonceLock> {\n    return this.#multichainTrackingHelper.getNonceLock(\n      address,\n      networkClientId,\n    );\n  }\n\n  /**\n   * Updates the editable parameters of a transaction.\n   *\n   * @param txId - The ID of the transaction to update.\n   * @param params - The editable parameters to update.\n   * @param params.data - Data to pass with the transaction.\n   * @param params.gas - Maximum number of units of gas to use for the transaction.\n   * @param params.gasPrice - Price per gas for legacy transactions.\n   * @param params.from - Address to send the transaction from.\n   * @param params.to - Address to send the transaction to.\n   * @param params.value - Value associated with the transaction.\n   * @returns The updated transaction metadata.\n   */\n  async updateEditableParams(\n    txId: string,\n    {\n      data,\n      gas,\n      gasPrice,\n      from,\n      to,\n      value,\n    }: {\n      data?: string;\n      gas?: string;\n      gasPrice?: string;\n      from?: string;\n      to?: string;\n      value?: string;\n    },\n  ) {\n    const transactionMeta = this.getTransaction(txId);\n    if (!transactionMeta) {\n      throw new Error(\n        `Cannot update editable params as no transaction metadata found`,\n      );\n    }\n\n    validateIfTransactionUnapproved(transactionMeta, 'updateEditableParams');\n\n    const editableParams = {\n      txParams: {\n        data,\n        from,\n        to,\n        value,\n        gas,\n        gasPrice,\n      },\n    } as Partial<TransactionMeta>;\n\n    editableParams.txParams = pickBy(\n      editableParams.txParams,\n    ) as TransactionParams;\n\n    const updatedTransaction = merge({}, transactionMeta, editableParams);\n    const provider = this.#multichainTrackingHelper.getProvider({\n      chainId: transactionMeta.chainId,\n      networkClientId: transactionMeta.networkClientId,\n    });\n    const ethQuery = new EthQuery(provider);\n    const { type } = await determineTransactionType(\n      updatedTransaction.txParams,\n      ethQuery,\n    );\n    updatedTransaction.type = type;\n\n    await updateTransactionLayer1GasFee({\n      layer1GasFeeFlows: this.layer1GasFeeFlows,\n      provider,\n      transactionMeta: updatedTransaction,\n    });\n\n    this.updateTransaction(\n      updatedTransaction,\n      `Update Editable Params for ${txId}`,\n    );\n    return this.getTransaction(txId);\n  }\n\n  /**\n   * Signs and returns the raw transaction data for provided transaction params list.\n   *\n   * @param listOfTxParams - The list of transaction params to approve.\n   * @param opts - Options bag.\n   * @param opts.hasNonce - Whether the transactions already have a nonce.\n   * @returns The raw transactions.\n   */\n  async approveTransactionsWithSameNonce(\n    listOfTxParams: (TransactionParams & { chainId: Hex })[] = [],\n    { hasNonce }: { hasNonce?: boolean } = {},\n  ): Promise<string | string[]> {\n    log('Approving transactions with same nonce', {\n      transactions: listOfTxParams,\n    });\n\n    if (listOfTxParams.length === 0) {\n      return '';\n    }\n\n    const initialTx = listOfTxParams[0];\n    const common = this.getCommonConfiguration(initialTx.chainId);\n\n    // We need to ensure we get the nonce using the the NonceTracker on the chain matching\n    // the txParams. In this context we only have chainId available to us, but the\n    // NonceTrackers are keyed by networkClientId. To workaround this, we attempt to find\n    // a networkClientId that matches the chainId. As a fallback, the globally selected\n    // network's NonceTracker will be used instead.\n    let networkClientId: NetworkClientId | undefined;\n    try {\n      networkClientId = this.messagingSystem.call(\n        `NetworkController:findNetworkClientIdByChainId`,\n        initialTx.chainId,\n      );\n    } catch (err) {\n      log('failed to find networkClientId from chainId', err);\n    }\n\n    const initialTxAsEthTx = TransactionFactory.fromTxData(initialTx, {\n      common,\n    });\n    const initialTxAsSerializedHex = bufferToHex(initialTxAsEthTx.serialize());\n\n    if (this.inProcessOfSigning.has(initialTxAsSerializedHex)) {\n      return '';\n    }\n\n    this.inProcessOfSigning.add(initialTxAsSerializedHex);\n\n    let rawTransactions, nonceLock;\n    try {\n      // TODO: we should add a check to verify that all transactions have the same from address\n      const fromAddress = initialTx.from;\n      const requiresNonce = hasNonce !== true;\n\n      nonceLock = requiresNonce\n        ? await this.getNonceLock(fromAddress, networkClientId)\n        : undefined;\n\n      const nonce = nonceLock\n        ? add0x(nonceLock.nextNonce.toString(16))\n        : initialTx.nonce;\n\n      if (nonceLock) {\n        log('Using nonce from nonce tracker', nonce, nonceLock.nonceDetails);\n      }\n\n      rawTransactions = await Promise.all(\n        listOfTxParams.map((txParams) => {\n          txParams.nonce = nonce;\n          return this.signExternalTransaction(txParams.chainId, txParams);\n        }),\n      );\n    } catch (err) {\n      log('Error while signing transactions with same nonce', err);\n      // Must set transaction to submitted/failed before releasing lock\n      // continue with error chain\n      throw err;\n    } finally {\n      nonceLock?.releaseLock();\n      this.inProcessOfSigning.delete(initialTxAsSerializedHex);\n    }\n    return rawTransactions;\n  }\n\n  /**\n   * Update a custodial transaction.\n   *\n   * @param transactionId - The ID of the transaction to update.\n   * @param options - The custodial transaction options to update.\n   * @param options.errorMessage - The error message to be assigned in case transaction status update to failed.\n   * @param options.hash - The new hash value to be assigned.\n   * @param options.status - The new status value to be assigned.\n   */\n  updateCustodialTransaction(\n    transactionId: string,\n    {\n      errorMessage,\n      hash,\n      status,\n    }: {\n      errorMessage?: string;\n      hash?: string;\n      status?: TransactionStatus;\n    },\n  ) {\n    const transactionMeta = this.getTransaction(transactionId);\n\n    if (!transactionMeta) {\n      throw new Error(\n        `Cannot update custodial transaction as no transaction metadata found`,\n      );\n    }\n\n    if (!transactionMeta.custodyId) {\n      throw new Error('Transaction must be a custodian transaction');\n    }\n\n    if (\n      status &&\n      ![\n        TransactionStatus.submitted,\n        TransactionStatus.signed,\n        TransactionStatus.failed,\n      ].includes(status)\n    ) {\n      throw new Error(\n        `Cannot update custodial transaction with status: ${status}`,\n      );\n    }\n\n    const updatedTransactionMeta = merge(\n      {},\n      transactionMeta,\n      pickBy({ hash, status }),\n    );\n\n    if (status === TransactionStatus.submitted) {\n      updatedTransactionMeta.submittedTime = new Date().getTime();\n    }\n\n    if (status === TransactionStatus.failed) {\n      updatedTransactionMeta.error = normalizeTxError(new Error(errorMessage));\n    }\n\n    this.updateTransaction(\n      updatedTransactionMeta,\n      `${controllerName}:updateCustodialTransaction - Custodial transaction updated`,\n    );\n\n    if (\n      [TransactionStatus.submitted, TransactionStatus.failed].includes(\n        status as TransactionStatus,\n      )\n    ) {\n      this.messagingSystem.publish(\n        `${controllerName}:transactionFinished`,\n        updatedTransactionMeta,\n      );\n      this.#internalEvents.emit(\n        `${updatedTransactionMeta.id}:finished`,\n        updatedTransactionMeta,\n      );\n    }\n  }\n\n  /**\n   * Creates approvals for all unapproved transactions persisted.\n   */\n  initApprovals() {\n    const chainId = this.getChainId();\n    const unapprovedTxs = this.state.transactions.filter(\n      (transaction) =>\n        transaction.status === TransactionStatus.unapproved &&\n        transaction.chainId === chainId &&\n        !transaction.isUserOperation,\n    );\n\n    for (const txMeta of unapprovedTxs) {\n      this.processApproval(txMeta, {\n        shouldShowRequest: false,\n      }).catch((error) => {\n        if (error?.code === errorCodes.provider.userRejectedRequest) {\n          return;\n        }\n        console.error('Error during persisted transaction approval', error);\n      });\n    }\n  }\n\n  /**\n   * Search transaction metadata for matching entries.\n   *\n   * @param opts - Options bag.\n   * @param opts.searchCriteria - An object containing values or functions for transaction properties to filter transactions with.\n   * @param opts.initialList - The transactions to search. Defaults to the current state.\n   * @param opts.filterToCurrentNetwork - Whether to filter the results to the current network. Defaults to true.\n   * @param opts.limit - The maximum number of transactions to return. No limit by default.\n   * @returns An array of transactions matching the provided options.\n   */\n  getTransactions({\n    searchCriteria = {},\n    initialList,\n    filterToCurrentNetwork = true,\n    limit,\n  }: {\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    searchCriteria?: any;\n    initialList?: TransactionMeta[];\n    filterToCurrentNetwork?: boolean;\n    limit?: number;\n  } = {}): TransactionMeta[] {\n    const chainId = this.getChainId();\n    // searchCriteria is an object that might have values that aren't predicate\n    // methods. When providing any other value type (string, number, etc), we\n    // consider this shorthand for \"check the value at key for strict equality\n    // with the provided value\". To conform this object to be only methods, we\n    // mapValues (lodash) such that every value on the object is a method that\n    // returns a boolean.\n    const predicateMethods = mapValues(searchCriteria, (predicate) => {\n      return typeof predicate === 'function'\n        ? predicate\n        : // TODO: Replace `any` with type\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (v: any) => v === predicate;\n    });\n\n    const transactionsToFilter = initialList ?? this.state.transactions;\n\n    // Combine sortBy and pickBy to transform our state object into an array of\n    // matching transactions that are sorted by time.\n    const filteredTransactions = sortBy(\n      pickBy(transactionsToFilter, (transaction) => {\n        if (filterToCurrentNetwork && transaction.chainId !== chainId) {\n          return false;\n        }\n        // iterate over the predicateMethods keys to check if the transaction\n        // matches the searchCriteria\n        for (const [key, predicate] of Object.entries(predicateMethods)) {\n          // We return false early as soon as we know that one of the specified\n          // search criteria do not match the transaction. This prevents\n          // needlessly checking all criteria when we already know the criteria\n          // are not fully satisfied. We check both txParams and the base\n          // object as predicate keys can be either.\n          if (key in transaction.txParams) {\n            // TODO: Replace `any` with type\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (predicate((transaction.txParams as any)[key]) === false) {\n              return false;\n            }\n            // TODO: Replace `any` with type\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          } else if (predicate((transaction as any)[key]) === false) {\n            return false;\n          }\n        }\n\n        return true;\n      }),\n      'time',\n    );\n    if (limit !== undefined) {\n      // We need to have all transactions of a given nonce in order to display\n      // necessary details in the UI. We use the size of this set to determine\n      // whether we have reached the limit provided, thus ensuring that all\n      // transactions of nonces we include will be sent to the UI.\n      const nonces = new Set();\n      const txs = [];\n      // By default, the transaction list we filter from is sorted by time ASC.\n      // To ensure that filtered results prefers the newest transactions we\n      // iterate from right to left, inserting transactions into front of a new\n      // array. The original order is preserved, but we ensure that newest txs\n      // are preferred.\n      for (let i = filteredTransactions.length - 1; i > -1; i--) {\n        const txMeta = filteredTransactions[i];\n        const { nonce } = txMeta.txParams;\n        if (!nonces.has(nonce)) {\n          if (nonces.size < limit) {\n            nonces.add(nonce);\n          } else {\n            continue;\n          }\n        }\n        // Push transaction into the beginning of our array to ensure the\n        // original order is preserved.\n        txs.unshift(txMeta);\n      }\n      return txs;\n    }\n    return filteredTransactions;\n  }\n\n  /**\n   * Determine the layer 1 gas fee for the given transaction parameters.\n   *\n   * @param request - The request object.\n   * @param request.transactionParams - The transaction parameters to estimate the layer 1 gas fee for.\n   * @param request.chainId - The ID of the chain where the transaction will be executed.\n   * @param request.networkClientId - The ID of a specific network client to process the transaction.\n   */\n  async getLayer1GasFee({\n    transactionParams,\n    chainId,\n    networkClientId,\n  }: {\n    transactionParams: TransactionParams;\n    chainId?: Hex;\n    networkClientId?: NetworkClientId;\n  }): Promise<Hex | undefined> {\n    const provider = this.#multichainTrackingHelper.getProvider({\n      networkClientId,\n      chainId,\n    });\n\n    return await getTransactionLayer1GasFee({\n      layer1GasFeeFlows: this.layer1GasFeeFlows,\n      provider,\n      transactionMeta: {\n        txParams: transactionParams,\n        chainId,\n      } as TransactionMeta,\n    });\n  }\n\n  private async signExternalTransaction(\n    chainId: Hex,\n    transactionParams: TransactionParams,\n  ): Promise<string> {\n    if (!this.sign) {\n      throw new Error('No sign method defined.');\n    }\n\n    const normalizedTransactionParams =\n      normalizeTransactionParams(transactionParams);\n    const type = isEIP1559Transaction(normalizedTransactionParams)\n      ? TransactionEnvelopeType.feeMarket\n      : TransactionEnvelopeType.legacy;\n    const updatedTransactionParams = {\n      ...normalizedTransactionParams,\n      type,\n      gasLimit: normalizedTransactionParams.gas,\n      chainId,\n    };\n\n    const { from } = updatedTransactionParams;\n    const common = this.getCommonConfiguration(chainId);\n    const unsignedTransaction = TransactionFactory.fromTxData(\n      updatedTransactionParams,\n      { common },\n    );\n    const signedTransaction = await this.sign(unsignedTransaction, from);\n\n    const rawTransaction = bufferToHex(signedTransaction.serialize());\n    return rawTransaction;\n  }\n\n  /**\n   * Removes unapproved transactions from state.\n   */\n  clearUnapprovedTransactions() {\n    const transactions = this.state.transactions.filter(\n      ({ status }) => status !== TransactionStatus.unapproved,\n    );\n    this.update((state) => {\n      state.transactions = this.trimTransactionsForState(transactions);\n    });\n  }\n\n  /**\n   * Stop the signing process for a specific transaction.\n   * Throws an error causing the transaction status to be set to failed.\n   * @param transactionId - The ID of the transaction to stop signing.\n   */\n  abortTransactionSigning(transactionId: string) {\n    const transactionMeta = this.getTransaction(transactionId);\n\n    if (!transactionMeta) {\n      throw new Error(`Cannot abort signing as no transaction metadata found`);\n    }\n\n    const abortCallback = this.signAbortCallbacks.get(transactionId);\n\n    if (!abortCallback) {\n      throw new Error(\n        `Cannot abort signing as transaction is not waiting for signing`,\n      );\n    }\n\n    abortCallback();\n\n    this.signAbortCallbacks.delete(transactionId);\n  }\n\n  private addMetadata(transactionMeta: TransactionMeta) {\n    this.update((state) => {\n      state.transactions = this.trimTransactionsForState([\n        ...state.transactions,\n        transactionMeta,\n      ]);\n    });\n  }\n\n  private async updateGasProperties(transactionMeta: TransactionMeta) {\n    const isEIP1559Compatible =\n      (await this.getEIP1559Compatibility(transactionMeta.networkClientId)) &&\n      transactionMeta.txParams.type !== TransactionEnvelopeType.legacy;\n\n    const { networkClientId, chainId } = transactionMeta;\n\n    const isCustomNetwork = networkClientId\n      ? this.messagingSystem.call(\n          `NetworkController:getNetworkClientById`,\n          networkClientId,\n        ).configuration.type === NetworkClientType.Custom\n      : this.getNetworkState().providerConfig.type === NetworkType.rpc;\n\n    const ethQuery = this.#multichainTrackingHelper.getEthQuery({\n      networkClientId,\n      chainId,\n    });\n\n    const provider = this.#multichainTrackingHelper.getProvider({\n      networkClientId,\n      chainId,\n    });\n\n    await updateGas({\n      ethQuery,\n      chainId,\n      isCustomNetwork,\n      txMeta: transactionMeta,\n    });\n\n    await updateGasFees({\n      eip1559: isEIP1559Compatible,\n      ethQuery,\n      gasFeeFlows: this.gasFeeFlows,\n      getGasFeeEstimates: this.getGasFeeEstimates,\n      getSavedGasFees: this.getSavedGasFees.bind(this),\n      txMeta: transactionMeta,\n    });\n\n    await updateTransactionLayer1GasFee({\n      layer1GasFeeFlows: this.layer1GasFeeFlows,\n      provider,\n      transactionMeta,\n    });\n  }\n\n  private onBootCleanup() {\n    this.submitApprovedTransactions();\n  }\n\n  /**\n   * Force submit approved transactions for all chains.\n   */\n  private submitApprovedTransactions() {\n    const approvedTransactions = this.state.transactions.filter(\n      (transaction) => transaction.status === TransactionStatus.approved,\n    );\n\n    for (const transactionMeta of approvedTransactions) {\n      if (this.beforeApproveOnInit(transactionMeta)) {\n        this.approveTransaction(transactionMeta.id).catch((error) => {\n          /* istanbul ignore next */\n          console.error('Error while submitting persisted transaction', error);\n        });\n      }\n    }\n  }\n\n  private async processApproval(\n    transactionMeta: TransactionMeta,\n    {\n      isExisting = false,\n      requireApproval,\n      shouldShowRequest = true,\n      actionId,\n    }: {\n      isExisting?: boolean;\n      requireApproval?: boolean | undefined;\n      shouldShowRequest?: boolean;\n      actionId?: string;\n    },\n  ): Promise<string> {\n    const transactionId = transactionMeta.id;\n    let resultCallbacks: AcceptResultCallbacks | undefined;\n    const { meta, isCompleted } = this.isTransactionCompleted(transactionId);\n    const finishedPromise = isCompleted\n      ? Promise.resolve(meta)\n      : this.waitForTransactionFinished(transactionId);\n\n    if (meta && !isExisting && !isCompleted) {\n      try {\n        if (requireApproval !== false) {\n          const acceptResult = await this.requestApproval(transactionMeta, {\n            shouldShowRequest,\n          });\n          resultCallbacks = acceptResult.resultCallbacks;\n\n          const approvalValue = acceptResult.value as\n            | {\n                txMeta?: TransactionMeta;\n              }\n            | undefined;\n\n          const updatedTransaction = approvalValue?.txMeta;\n\n          if (updatedTransaction) {\n            log('Updating transaction with approval data', {\n              customNonce: updatedTransaction.customNonceValue,\n              params: updatedTransaction.txParams,\n            });\n\n            this.updateTransaction(\n              updatedTransaction,\n              'TransactionController#processApproval - Updated with approval data',\n            );\n          }\n        }\n\n        const { isCompleted: isTxCompleted } =\n          this.isTransactionCompleted(transactionId);\n\n        if (!isTxCompleted) {\n          const approvalResult = await this.approveTransaction(transactionId);\n          if (\n            approvalResult === ApprovalState.SkippedViaBeforePublishHook &&\n            resultCallbacks\n          ) {\n            resultCallbacks.success();\n          }\n          const updatedTransactionMeta = this.getTransaction(\n            transactionId,\n          ) as TransactionMeta;\n          this.messagingSystem.publish(\n            `${controllerName}:transactionApproved`,\n            {\n              transactionMeta: updatedTransactionMeta,\n              actionId,\n            },\n          );\n        }\n        // TODO: Replace `any` with type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (error: any) {\n        const { isCompleted: isTxCompleted } =\n          this.isTransactionCompleted(transactionId);\n        if (!isTxCompleted) {\n          if (error?.code === errorCodes.provider.userRejectedRequest) {\n            this.cancelTransaction(transactionId, actionId);\n\n            throw providerErrors.userRejectedRequest(\n              'MetaMask Tx Signature: User denied transaction signature.',\n            );\n          } else {\n            this.failTransaction(meta, error, actionId);\n          }\n        }\n      }\n    }\n\n    const finalMeta = await finishedPromise;\n\n    switch (finalMeta?.status) {\n      case TransactionStatus.failed:\n        resultCallbacks?.error(finalMeta.error);\n        throw rpcErrors.internal(finalMeta.error.message);\n\n      case TransactionStatus.submitted:\n        resultCallbacks?.success();\n        return finalMeta.hash as string;\n\n      default:\n        const internalError = rpcErrors.internal(\n          `MetaMask Tx Signature: Unknown problem: ${JSON.stringify(\n            finalMeta || transactionId,\n          )}`,\n        );\n\n        resultCallbacks?.error(internalError);\n        throw internalError;\n    }\n  }\n\n  /**\n   * Approves a transaction and updates it's status in state. If this is not a\n   * retry transaction, a nonce will be generated. The transaction is signed\n   * using the sign configuration property, then published to the blockchain.\n   * A `<tx.id>:finished` hub event is fired after success or failure.\n   *\n   * @param transactionId - The ID of the transaction to approve.\n   */\n  private async approveTransaction(transactionId: string) {\n    const { transactions } = this.state;\n    const releaseLock = await this.mutex.acquire();\n    const index = transactions.findIndex(({ id }) => transactionId === id);\n    const transactionMeta = transactions[index];\n    const updatedTransactionMeta = cloneDeep(transactionMeta);\n\n    const {\n      txParams: { from },\n      networkClientId,\n    } = transactionMeta;\n\n    let releaseNonceLock: (() => void) | undefined;\n\n    try {\n      if (!this.sign) {\n        releaseLock();\n        this.failTransaction(\n          transactionMeta,\n          new Error('No sign method defined.'),\n        );\n        return ApprovalState.NotApproved;\n      } else if (!transactionMeta.chainId) {\n        releaseLock();\n        this.failTransaction(transactionMeta, new Error('No chainId defined.'));\n        return ApprovalState.NotApproved;\n      }\n\n      if (this.inProcessOfSigning.has(transactionId)) {\n        log('Skipping approval as signing in progress', transactionId);\n        return ApprovalState.NotApproved;\n      }\n\n      const [nonce, releaseNonce] = await getNextNonce(\n        transactionMeta,\n        (address: string) =>\n          this.#multichainTrackingHelper.getNonceLock(address, networkClientId),\n      );\n\n      releaseNonceLock = releaseNonce;\n\n      updatedTransactionMeta.status = TransactionStatus.approved;\n      updatedTransactionMeta.txParams = {\n        ...updatedTransactionMeta.txParams,\n        nonce,\n        chainId: transactionMeta.chainId,\n      };\n\n      const baseTxParams = {\n        ...updatedTransactionMeta.txParams,\n        gasLimit: updatedTransactionMeta.txParams.gas,\n      };\n\n      this.updateTransaction(\n        updatedTransactionMeta,\n        'TransactionController#approveTransaction - Transaction approved',\n      );\n\n      this.onTransactionStatusChange(updatedTransactionMeta);\n\n      const isEIP1559 = isEIP1559Transaction(updatedTransactionMeta.txParams);\n\n      const txParams: TransactionParams = isEIP1559\n        ? {\n            ...baseTxParams,\n            estimatedBaseFee: updatedTransactionMeta.txParams.estimatedBaseFee,\n            type: TransactionEnvelopeType.feeMarket,\n          }\n        : baseTxParams;\n\n      const rawTx = await this.signTransaction(\n        updatedTransactionMeta,\n        txParams,\n      );\n\n      if (!this.beforePublish(updatedTransactionMeta)) {\n        log('Skipping publishing transaction based on hook');\n        this.messagingSystem.publish(\n          `${controllerName}:transactionPublishingSkipped`,\n          updatedTransactionMeta,\n        );\n        return ApprovalState.SkippedViaBeforePublishHook;\n      }\n\n      if (!rawTx) {\n        return ApprovalState.NotApproved;\n      }\n\n      const ethQuery = this.#multichainTrackingHelper.getEthQuery({\n        networkClientId: transactionMeta.networkClientId,\n        chainId: transactionMeta.chainId,\n      });\n\n      if (transactionMeta.type === TransactionType.swap) {\n        log('Determining pre-transaction balance');\n\n        const preTxBalance = await query(ethQuery, 'getBalance', [from]);\n\n        updatedTransactionMeta.preTxBalance = preTxBalance;\n\n        log(\n          'Updated pre-transaction balance',\n          updatedTransactionMeta.preTxBalance,\n        );\n      }\n\n      log('Publishing transaction', txParams);\n\n      let { transactionHash: hash } = await this.publish(\n        updatedTransactionMeta,\n        rawTx,\n      );\n\n      if (hash === undefined) {\n        hash = await this.publishTransaction(ethQuery, rawTx);\n      }\n\n      log('Publish successful', hash);\n\n      updatedTransactionMeta.hash = hash;\n      updatedTransactionMeta.status = TransactionStatus.submitted;\n      updatedTransactionMeta.submittedTime = new Date().getTime();\n\n      this.updateTransaction(\n        updatedTransactionMeta,\n        'TransactionController#approveTransaction - Transaction submitted',\n      );\n\n      this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {\n        transactionMeta: updatedTransactionMeta,\n      });\n\n      this.messagingSystem.publish(\n        `${controllerName}:transactionFinished`,\n        updatedTransactionMeta,\n      );\n      this.#internalEvents.emit(\n        `${updatedTransactionMeta.id}:finished`,\n        updatedTransactionMeta,\n      );\n\n      this.onTransactionStatusChange(updatedTransactionMeta);\n      return ApprovalState.Approved;\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (error: any) {\n      this.failTransaction(transactionMeta, error);\n      return ApprovalState.NotApproved;\n    } finally {\n      this.inProcessOfSigning.delete(transactionId);\n      // must set transaction to submitted/failed before releasing lock\n      releaseNonceLock?.();\n      releaseLock();\n    }\n  }\n\n  private async publishTransaction(\n    ethQuery: EthQuery,\n    rawTransaction: string,\n  ): Promise<string> {\n    return await query(ethQuery, 'sendRawTransaction', [rawTransaction]);\n  }\n\n  /**\n   * Cancels a transaction based on its ID by setting its status to \"rejected\"\n   * and emitting a `<tx.id>:finished` hub event.\n   *\n   * @param transactionId - The ID of the transaction to cancel.\n   * @param actionId - The actionId passed from UI\n   */\n  private cancelTransaction(transactionId: string, actionId?: string) {\n    const transactionMeta = this.state.transactions.find(\n      ({ id }) => id === transactionId,\n    );\n    if (!transactionMeta) {\n      return;\n    }\n    this.update((state) => {\n      const transactions = state.transactions.filter(\n        ({ id }) => id !== transactionId,\n      );\n      state.transactions = this.trimTransactionsForState(transactions);\n    });\n    const updatedTransactionMeta = {\n      ...transactionMeta,\n      status: TransactionStatus.rejected as const,\n    };\n    this.messagingSystem.publish(\n      `${controllerName}:transactionFinished`,\n      updatedTransactionMeta,\n    );\n    this.#internalEvents.emit(\n      `${transactionMeta.id}:finished`,\n      updatedTransactionMeta,\n    );\n    this.messagingSystem.publish(`${controllerName}:transactionRejected`, {\n      transactionMeta: updatedTransactionMeta,\n      actionId,\n    });\n    this.onTransactionStatusChange(updatedTransactionMeta);\n  }\n\n  /**\n   * Trim the amount of transactions that are set on the state. Checks\n   * if the length of the tx history is longer then desired persistence\n   * limit and then if it is removes the oldest confirmed or rejected tx.\n   * Pending or unapproved transactions will not be removed by this\n   * operation. For safety of presenting a fully functional transaction UI\n   * representation, this function will not break apart transactions with the\n   * same nonce, created on the same day, per network. Not accounting for\n   * transactions of the same nonce, same day and network combo can result in\n   * confusing or broken experiences in the UI.\n   *\n   * @param transactions - The transactions to be applied to the state.\n   * @returns The trimmed list of transactions.\n   */\n  private trimTransactionsForState(\n    transactions: TransactionMeta[],\n  ): TransactionMeta[] {\n    const nonceNetworkSet = new Set();\n\n    const txsToKeep = [...transactions]\n      .sort((a, b) => (a.time > b.time ? -1 : 1)) // Descending time order\n      .filter((tx) => {\n        const { chainId, status, txParams, time } = tx;\n\n        if (txParams) {\n          const key = `${String(txParams.nonce)}-${convertHexToDecimal(\n            chainId,\n          )}-${new Date(time).toDateString()}`;\n\n          if (nonceNetworkSet.has(key)) {\n            return true;\n          } else if (\n            nonceNetworkSet.size < this.#transactionHistoryLimit ||\n            !this.isFinalState(status)\n          ) {\n            nonceNetworkSet.add(key);\n            return true;\n          }\n        }\n\n        return false;\n      });\n\n    txsToKeep.reverse(); // Ascending time order\n    return txsToKeep;\n  }\n\n  /**\n   * Determines if the transaction is in a final state.\n   *\n   * @param status - The transaction status.\n   * @returns Whether the transaction is in a final state.\n   */\n  private isFinalState(status: TransactionStatus): boolean {\n    return (\n      status === TransactionStatus.rejected ||\n      status === TransactionStatus.confirmed ||\n      status === TransactionStatus.failed\n    );\n  }\n\n  /**\n   * Whether the transaction has at least completed all local processing.\n   *\n   * @param status - The transaction status.\n   * @returns Whether the transaction is in a final state.\n   */\n  private isLocalFinalState(status: TransactionStatus): boolean {\n    return [\n      TransactionStatus.confirmed,\n      TransactionStatus.failed,\n      TransactionStatus.rejected,\n      TransactionStatus.submitted,\n    ].includes(status);\n  }\n\n  private async requestApproval(\n    txMeta: TransactionMeta,\n    { shouldShowRequest }: { shouldShowRequest: boolean },\n  ): Promise<AddResult> {\n    const id = this.getApprovalId(txMeta);\n    const { origin } = txMeta;\n    const type = ApprovalType.Transaction;\n    const requestData = { txId: txMeta.id };\n\n    return (await this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id,\n        origin: origin || ORIGIN_METAMASK,\n        type,\n        requestData,\n        expectsResult: true,\n      },\n      shouldShowRequest,\n    )) as Promise<AddResult>;\n  }\n\n  private getTransaction(transactionId: string): TransactionMeta | undefined {\n    const { transactions } = this.state;\n    return transactions.find(({ id }) => id === transactionId);\n  }\n\n  private getApprovalId(txMeta: TransactionMeta) {\n    return String(txMeta.id);\n  }\n\n  private isTransactionCompleted(transactionId: string): {\n    meta?: TransactionMeta;\n    isCompleted: boolean;\n  } {\n    const transaction = this.getTransaction(transactionId);\n\n    if (!transaction) {\n      return { meta: undefined, isCompleted: false };\n    }\n\n    const isCompleted = this.isLocalFinalState(transaction.status);\n\n    return { meta: transaction, isCompleted };\n  }\n\n  private getChainId(networkClientId?: NetworkClientId): Hex {\n    if (networkClientId) {\n      return this.messagingSystem.call(\n        `NetworkController:getNetworkClientById`,\n        networkClientId,\n      ).configuration.chainId;\n    }\n    const { providerConfig } = this.getNetworkState();\n    return providerConfig.chainId;\n  }\n\n  private prepareUnsignedEthTx(\n    chainId: Hex,\n    txParams: TransactionParams,\n  ): TypedTransaction {\n    return TransactionFactory.fromTxData(txParams, {\n      freeze: false,\n      common: this.getCommonConfiguration(chainId),\n    });\n  }\n\n  /**\n   * `@ethereumjs/tx` uses `@ethereumjs/common` as a configuration tool for\n   * specifying which chain, network, hardfork and EIPs to support for\n   * a transaction. By referencing this configuration, and analyzing the fields\n   * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718\n   * transaction type to use.\n   *\n   * @param chainId - The chainId to use for the configuration.\n   * @returns common configuration object\n   */\n  private getCommonConfiguration(chainId: Hex): Common {\n    const customChainParams: Partial<ChainConfig> = {\n      chainId: parseInt(chainId, 16),\n      defaultHardfork: HARDFORK,\n    };\n\n    return Common.custom(customChainParams);\n  }\n\n  private onIncomingTransactions({\n    added,\n    updated,\n  }: {\n    added: TransactionMeta[];\n    updated: TransactionMeta[];\n  }) {\n    this.update((state) => {\n      const { transactions: currentTransactions } = state;\n      const updatedTransactions = [\n        ...added,\n        ...currentTransactions.map((originalTransaction) => {\n          const updatedTransaction = updated.find(\n            ({ hash }) => hash === originalTransaction.hash,\n          );\n\n          return updatedTransaction ?? originalTransaction;\n        }),\n      ];\n\n      state.transactions = this.trimTransactionsForState(updatedTransactions);\n    });\n  }\n\n  private onUpdatedLastFetchedBlockNumbers({\n    lastFetchedBlockNumbers,\n    blockNumber,\n  }: {\n    lastFetchedBlockNumbers: {\n      [key: string]: number;\n    };\n    blockNumber: number;\n  }) {\n    this.update((state) => {\n      state.lastFetchedBlockNumbers = lastFetchedBlockNumbers;\n    });\n    this.messagingSystem.publish(\n      `${controllerName}:incomingTransactionBlockReceived`,\n      blockNumber,\n    );\n  }\n\n  private generateDappSuggestedGasFees(\n    txParams: TransactionParams,\n    origin?: string,\n  ): DappSuggestedGasFees | undefined {\n    if (!origin || origin === ORIGIN_METAMASK) {\n      return undefined;\n    }\n\n    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas, gas } = txParams;\n\n    if (\n      gasPrice === undefined &&\n      maxFeePerGas === undefined &&\n      maxPriorityFeePerGas === undefined &&\n      gas === undefined\n    ) {\n      return undefined;\n    }\n\n    const dappSuggestedGasFees: DappSuggestedGasFees = {};\n\n    if (gasPrice !== undefined) {\n      dappSuggestedGasFees.gasPrice = gasPrice;\n    } else if (\n      maxFeePerGas !== undefined ||\n      maxPriorityFeePerGas !== undefined\n    ) {\n      dappSuggestedGasFees.maxFeePerGas = maxFeePerGas;\n      dappSuggestedGasFees.maxPriorityFeePerGas = maxPriorityFeePerGas;\n    }\n\n    if (gas !== undefined) {\n      dappSuggestedGasFees.gas = gas;\n    }\n\n    return dappSuggestedGasFees;\n  }\n\n  /**\n   * Validates and adds external provided transaction to state.\n   *\n   * @param transactionMeta - Nominated external transaction to be added to state.\n   * @returns The new transaction.\n   */\n  private addExternalTransaction(transactionMeta: TransactionMeta) {\n    const { chainId } = transactionMeta;\n    const { transactions } = this.state;\n    const fromAddress = transactionMeta?.txParams?.from;\n    const sameFromAndNetworkTransactions = transactions.filter(\n      (transaction) =>\n        transaction.txParams.from === fromAddress &&\n        transaction.chainId === chainId,\n    );\n    const confirmedTxs = sameFromAndNetworkTransactions.filter(\n      (transaction) => transaction.status === TransactionStatus.confirmed,\n    );\n    const pendingTxs = sameFromAndNetworkTransactions.filter(\n      (transaction) => transaction.status === TransactionStatus.submitted,\n    );\n\n    validateConfirmedExternalTransaction(\n      transactionMeta,\n      confirmedTxs,\n      pendingTxs,\n    );\n\n    // Make sure provided external transaction has non empty history array\n    const newTransactionMeta =\n      (transactionMeta.history ?? []).length === 0 && !this.isHistoryDisabled\n        ? addInitialHistorySnapshot(transactionMeta)\n        : transactionMeta;\n\n    this.update((state) => {\n      state.transactions = this.trimTransactionsForState([\n        ...state.transactions,\n        newTransactionMeta,\n      ]);\n    });\n\n    return newTransactionMeta;\n  }\n\n  /**\n   * Sets other txMeta statuses to dropped if the txMeta that has been confirmed has other transactions\n   * in the transactions have the same nonce.\n   *\n   * @param transactionId - Used to identify original transaction.\n   */\n  private markNonceDuplicatesDropped(transactionId: string) {\n    const transactionMeta = this.getTransaction(transactionId);\n    if (!transactionMeta) {\n      return;\n    }\n    const nonce = transactionMeta.txParams?.nonce;\n    const from = transactionMeta.txParams?.from;\n    const { chainId } = transactionMeta;\n\n    const sameNonceTransactions = this.state.transactions.filter(\n      (transaction) =>\n        transaction.id !== transactionId &&\n        transaction.txParams.from === from &&\n        transaction.txParams.nonce === nonce &&\n        transaction.chainId === chainId &&\n        transaction.type !== TransactionType.incoming,\n    );\n    const sameNonceTransactionIds = sameNonceTransactions.map(\n      (transaction) => transaction.id,\n    );\n\n    if (sameNonceTransactions.length === 0) {\n      return;\n    }\n\n    this.update((state) => {\n      for (const transaction of state.transactions) {\n        if (sameNonceTransactionIds.includes(transaction.id)) {\n          transaction.replacedBy = transactionMeta?.hash;\n          transaction.replacedById = transactionMeta?.id;\n        }\n      }\n    });\n\n    for (const transaction of this.state.transactions) {\n      if (\n        sameNonceTransactionIds.includes(transaction.id) &&\n        transaction.status !== TransactionStatus.failed\n      ) {\n        this.setTransactionStatusDropped(transaction);\n      }\n    }\n  }\n\n  /**\n   * Method to set transaction status to dropped.\n   *\n   * @param transactionMeta - TransactionMeta of transaction to be marked as dropped.\n   */\n  private setTransactionStatusDropped(transactionMeta: TransactionMeta) {\n    const updatedTransactionMeta = {\n      ...transactionMeta,\n      status: TransactionStatus.dropped as const,\n    };\n    this.messagingSystem.publish(`${controllerName}:transactionDropped`, {\n      transactionMeta: updatedTransactionMeta,\n    });\n    this.updateTransaction(\n      updatedTransactionMeta,\n      'TransactionController#setTransactionStatusDropped - Transaction dropped',\n    );\n    this.onTransactionStatusChange(updatedTransactionMeta);\n  }\n\n  /**\n   * Get transaction with provided actionId.\n   *\n   * @param actionId - Unique ID to prevent duplicate requests\n   * @returns the filtered transaction\n   */\n  private getTransactionWithActionId(actionId?: string) {\n    return this.state.transactions.find(\n      (transaction) => actionId && transaction.actionId === actionId,\n    );\n  }\n\n  private async waitForTransactionFinished(\n    transactionId: string,\n  ): Promise<TransactionMeta> {\n    return new Promise((resolve) => {\n      this.#internalEvents.once(`${transactionId}:finished`, (txMeta) => {\n        resolve(txMeta);\n      });\n    });\n  }\n\n  /**\n   * Updates the r, s, and v properties of a TransactionMeta object\n   * with values from a signed transaction.\n   *\n   * @param transactionMeta - The TransactionMeta object to update.\n   * @param signedTx - The encompassing type for all transaction types containing r, s, and v values.\n   */\n  private async updateTransactionMetaRSV(\n    transactionMeta: TransactionMeta,\n    signedTx: TypedTransaction,\n  ): Promise<TransactionMeta> {\n    const transactionMetaWithRsv = cloneDeep(transactionMeta);\n\n    for (const key of ['r', 's', 'v'] as const) {\n      const value = signedTx[key];\n\n      if (value === undefined || value === null) {\n        continue;\n      }\n\n      transactionMetaWithRsv[key] = add0x(value.toString(16));\n    }\n\n    return transactionMetaWithRsv;\n  }\n\n  private async getEIP1559Compatibility(networkClientId?: NetworkClientId) {\n    const currentNetworkIsEIP1559Compatible =\n      await this.getCurrentNetworkEIP1559Compatibility(networkClientId);\n\n    const currentAccountIsEIP1559Compatible =\n      await this.getCurrentAccountEIP1559Compatibility();\n\n    return (\n      currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible\n    );\n  }\n\n  private async signTransaction(\n    transactionMeta: TransactionMeta,\n    txParams: TransactionParams,\n  ): Promise<string | undefined> {\n    log('Signing transaction', txParams);\n\n    const unsignedEthTx = this.prepareUnsignedEthTx(\n      transactionMeta.chainId,\n      txParams,\n    );\n\n    this.inProcessOfSigning.add(transactionMeta.id);\n\n    const signedTx = await new Promise<TypedTransaction>((resolve, reject) => {\n      this.sign?.(\n        unsignedEthTx,\n        txParams.from,\n        ...this.getAdditionalSignArguments(transactionMeta),\n      ).then(resolve, reject);\n\n      this.signAbortCallbacks.set(transactionMeta.id, () =>\n        reject(new Error('Signing aborted by user')),\n      );\n    });\n\n    this.signAbortCallbacks.delete(transactionMeta.id);\n\n    if (!signedTx) {\n      log('Skipping signed status as no signed transaction');\n      return undefined;\n    }\n\n    if (!this.afterSign(transactionMeta, signedTx)) {\n      this.updateTransaction(\n        transactionMeta,\n        'TransactionController#signTransaction - Update after sign',\n      );\n\n      log('Skipping signed status based on hook');\n\n      return undefined;\n    }\n\n    const transactionMetaWithRsv = {\n      ...(await this.updateTransactionMetaRSV(transactionMeta, signedTx)),\n      status: TransactionStatus.signed as const,\n    };\n\n    this.updateTransaction(\n      transactionMetaWithRsv,\n      'TransactionController#approveTransaction - Transaction signed',\n    );\n\n    this.onTransactionStatusChange(transactionMetaWithRsv);\n\n    const rawTx = bufferToHex(signedTx.serialize());\n\n    const transactionMetaWithRawTx = merge({}, transactionMetaWithRsv, {\n      rawTx,\n    });\n\n    this.updateTransaction(\n      transactionMetaWithRawTx,\n      'TransactionController#approveTransaction - RawTransaction added',\n    );\n\n    return rawTx;\n  }\n\n  private onTransactionStatusChange(transactionMeta: TransactionMeta) {\n    this.messagingSystem.publish(`${controllerName}:transactionStatusUpdated`, {\n      transactionMeta,\n    });\n  }\n\n  private getNonceTrackerTransactions(\n    status: TransactionStatus,\n    address: string,\n    chainId: string = this.getChainId(),\n  ) {\n    return getAndFormatTransactionsForNonceTracker(\n      chainId,\n      address,\n      status,\n      this.state.transactions,\n    );\n  }\n\n  private onConfirmedTransaction(transactionMeta: TransactionMeta) {\n    log('Processing confirmed transaction', transactionMeta.id);\n\n    this.markNonceDuplicatesDropped(transactionMeta.id);\n\n    this.messagingSystem.publish(\n      `${controllerName}:transactionConfirmed`,\n      transactionMeta,\n    );\n\n    this.onTransactionStatusChange(transactionMeta);\n\n    // Intentional given potential duration of process.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.updatePostBalance(transactionMeta);\n  }\n\n  private async updatePostBalance(transactionMeta: TransactionMeta) {\n    try {\n      if (transactionMeta.type !== TransactionType.swap) {\n        return;\n      }\n\n      const ethQuery = this.#multichainTrackingHelper.getEthQuery({\n        networkClientId: transactionMeta.networkClientId,\n        chainId: transactionMeta.chainId,\n      });\n      const { updatedTransactionMeta, approvalTransactionMeta } =\n        await updatePostTransactionBalance(transactionMeta, {\n          ethQuery,\n          getTransaction: this.getTransaction.bind(this),\n          updateTransaction: this.updateTransaction.bind(this),\n        });\n\n      this.messagingSystem.publish(\n        `${controllerName}:postTransactionBalanceUpdated`,\n        {\n          transactionMeta: updatedTransactionMeta,\n          approvalTransactionMeta,\n        },\n      );\n    } catch (error) {\n      /* istanbul ignore next */\n      log('Error while updating post transaction balance', error);\n    }\n  }\n\n  #createNonceTracker({\n    provider,\n    blockTracker,\n    chainId,\n  }: {\n    provider: Provider;\n    blockTracker: BlockTracker;\n    chainId?: Hex;\n  }): NonceTracker {\n    return new NonceTracker({\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      provider: provider as any,\n      blockTracker,\n      getPendingTransactions: this.#getNonceTrackerPendingTransactions.bind(\n        this,\n        chainId,\n      ),\n      getConfirmedTransactions: this.getNonceTrackerTransactions.bind(\n        this,\n        TransactionStatus.confirmed,\n      ),\n    });\n  }\n\n  #createIncomingTransactionHelper({\n    blockTracker,\n    etherscanRemoteTransactionSource,\n    chainId,\n  }: {\n    blockTracker: BlockTracker;\n    etherscanRemoteTransactionSource: EtherscanRemoteTransactionSource;\n    chainId?: Hex;\n  }): IncomingTransactionHelper {\n    const incomingTransactionHelper = new IncomingTransactionHelper({\n      blockTracker,\n      getCurrentAccount: this.getSelectedAddress,\n      getLastFetchedBlockNumbers: () => this.state.lastFetchedBlockNumbers,\n      getChainId: chainId ? () => chainId : this.getChainId.bind(this),\n      isEnabled: this.#incomingTransactionOptions.isEnabled,\n      queryEntireHistory: this.#incomingTransactionOptions.queryEntireHistory,\n      remoteTransactionSource: etherscanRemoteTransactionSource,\n      transactionLimit: this.#transactionHistoryLimit,\n      updateTransactions: this.#incomingTransactionOptions.updateTransactions,\n    });\n\n    this.#addIncomingTransactionHelperListeners(incomingTransactionHelper);\n\n    return incomingTransactionHelper;\n  }\n\n  #createPendingTransactionTracker({\n    provider,\n    blockTracker,\n    chainId,\n  }: {\n    provider: Provider;\n    blockTracker: BlockTracker;\n    chainId?: Hex;\n  }): PendingTransactionTracker {\n    const ethQuery = new EthQuery(provider);\n    const getChainId = chainId ? () => chainId : this.getChainId.bind(this);\n\n    const pendingTransactionTracker = new PendingTransactionTracker({\n      approveTransaction: async (transactionId: string) => {\n        await this.approveTransaction(transactionId);\n      },\n      blockTracker,\n      getChainId,\n      getEthQuery: () => ethQuery,\n      getTransactions: () => this.state.transactions,\n      isResubmitEnabled: this.#pendingTransactionOptions.isResubmitEnabled,\n      getGlobalLock: () =>\n        this.#multichainTrackingHelper.acquireNonceLockForChainIdKey({\n          chainId: getChainId(),\n        }),\n      publishTransaction: this.publishTransaction.bind(this),\n      hooks: {\n        beforeCheckPendingTransaction:\n          this.beforeCheckPendingTransaction.bind(this),\n        beforePublish: this.beforePublish.bind(this),\n      },\n    });\n\n    this.#addPendingTransactionTrackerListeners(pendingTransactionTracker);\n\n    return pendingTransactionTracker;\n  }\n\n  #checkForPendingTransactionAndStartPolling = () => {\n    // PendingTransactionTracker reads state through its getTransactions hook\n    this.pendingTransactionTracker.startIfPendingTransactions();\n    this.#multichainTrackingHelper.checkForPendingTransactionAndStartPolling();\n  };\n\n  #stopAllTracking() {\n    this.pendingTransactionTracker.stop();\n    this.#removePendingTransactionTrackerListeners(\n      this.pendingTransactionTracker,\n    );\n    this.incomingTransactionHelper.stop();\n    this.#removeIncomingTransactionHelperListeners(\n      this.incomingTransactionHelper,\n    );\n\n    this.#multichainTrackingHelper.stopAllTracking();\n  }\n\n  #removeIncomingTransactionHelperListeners(\n    incomingTransactionHelper: IncomingTransactionHelper,\n  ) {\n    incomingTransactionHelper.hub.removeAllListeners('transactions');\n    incomingTransactionHelper.hub.removeAllListeners(\n      'updatedLastFetchedBlockNumbers',\n    );\n  }\n\n  #addIncomingTransactionHelperListeners(\n    incomingTransactionHelper: IncomingTransactionHelper,\n  ) {\n    incomingTransactionHelper.hub.on(\n      'transactions',\n      this.onIncomingTransactions.bind(this),\n    );\n    incomingTransactionHelper.hub.on(\n      'updatedLastFetchedBlockNumbers',\n      this.onUpdatedLastFetchedBlockNumbers.bind(this),\n    );\n  }\n\n  #removePendingTransactionTrackerListeners(\n    pendingTransactionTracker: PendingTransactionTracker,\n  ) {\n    pendingTransactionTracker.hub.removeAllListeners('transaction-confirmed');\n    pendingTransactionTracker.hub.removeAllListeners('transaction-dropped');\n    pendingTransactionTracker.hub.removeAllListeners('transaction-failed');\n    pendingTransactionTracker.hub.removeAllListeners('transaction-updated');\n  }\n\n  #addPendingTransactionTrackerListeners(\n    pendingTransactionTracker: PendingTransactionTracker,\n  ) {\n    pendingTransactionTracker.hub.on(\n      'transaction-confirmed',\n      this.onConfirmedTransaction.bind(this),\n    );\n\n    pendingTransactionTracker.hub.on(\n      'transaction-dropped',\n      this.setTransactionStatusDropped.bind(this),\n    );\n\n    pendingTransactionTracker.hub.on(\n      'transaction-failed',\n      this.failTransaction.bind(this),\n    );\n\n    pendingTransactionTracker.hub.on(\n      'transaction-updated',\n      this.updateTransaction.bind(this),\n    );\n  }\n\n  #getNonceTrackerPendingTransactions(\n    chainId: string | undefined,\n    address: string,\n  ) {\n    const standardPendingTransactions = this.getNonceTrackerTransactions(\n      TransactionStatus.submitted,\n      address,\n      chainId,\n    );\n\n    const externalPendingTransactions = this.getExternalPendingTransactions(\n      address,\n      chainId,\n    );\n    return [...standardPendingTransactions, ...externalPendingTransactions];\n  }\n\n  private async publishTransactionForRetry(\n    ethQuery: EthQuery,\n    rawTx: string,\n    transactionMeta: TransactionMeta,\n  ): Promise<string> {\n    try {\n      const hash = await this.publishTransaction(ethQuery, rawTx);\n      return hash;\n    } catch (error: unknown) {\n      if (this.isTransactionAlreadyConfirmedError(error as Error)) {\n        await this.pendingTransactionTracker.forceCheckTransaction(\n          transactionMeta,\n        );\n        throw new Error('Previous transaction is already confirmed');\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Ensures that error is a nonce issue\n   *\n   * @param error - The error to check\n   * @returns Whether or not the error is a nonce issue\n   */\n  // TODO: Replace `any` with type\n  // Some networks are returning original error in the data field\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private isTransactionAlreadyConfirmedError(error: any): boolean {\n    return (\n      error?.message?.includes('nonce too low') ||\n      error?.data?.message?.includes('nonce too low')\n    );\n  }\n\n  #getGasFeeFlows(): GasFeeFlow[] {\n    return [new LineaGasFeeFlow(), new DefaultGasFeeFlow()];\n  }\n\n  #getLayer1GasFeeFlows(): Layer1GasFeeFlow[] {\n    return [new OptimismLayer1GasFeeFlow(), new ScrollLayer1GasFeeFlow()];\n  }\n\n  #updateTransactionInternal(\n    {\n      transactionId,\n      note,\n      skipHistory,\n    }: { transactionId: string; note?: string; skipHistory?: boolean },\n    callback: (transactionMeta: TransactionMeta) => TransactionMeta | void,\n  ) {\n    let updatedTransactionParams: (keyof TransactionParams)[] = [];\n\n    this.update((state) => {\n      const index = state.transactions.findIndex(\n        ({ id }) => id === transactionId,\n      );\n\n      let transactionMeta = state.transactions[index];\n\n      // eslint-disable-next-line n/callback-return\n      transactionMeta = callback(transactionMeta) ?? transactionMeta;\n\n      transactionMeta.txParams = normalizeTransactionParams(\n        transactionMeta.txParams,\n      );\n\n      validateTxParams(transactionMeta.txParams);\n\n      updatedTransactionParams =\n        this.#checkIfTransactionParamsUpdated(transactionMeta);\n\n      if (skipHistory !== true) {\n        transactionMeta = updateTransactionHistory(\n          transactionMeta,\n          note ?? 'Transaction updated',\n        );\n      }\n\n      state.transactions[index] = transactionMeta;\n    });\n\n    const transactionMeta = this.getTransaction(\n      transactionId,\n    ) as TransactionMeta;\n\n    if (updatedTransactionParams.length > 0) {\n      this.#onTransactionParamsUpdated(\n        transactionMeta,\n        updatedTransactionParams,\n      );\n    }\n  }\n\n  #checkIfTransactionParamsUpdated(newTransactionMeta: TransactionMeta) {\n    const { id: transactionId, txParams: newParams } = newTransactionMeta;\n\n    const originalParams = this.getTransaction(transactionId)?.txParams;\n\n    if (!originalParams || isEqual(originalParams, newParams)) {\n      return [];\n    }\n\n    const params = Object.keys(newParams) as (keyof TransactionParams)[];\n\n    const updatedProperties = params.filter(\n      (param) => newParams[param] !== originalParams[param],\n    );\n\n    log(\n      'Transaction parameters have been updated',\n      transactionId,\n      updatedProperties,\n      originalParams,\n      newParams,\n    );\n\n    return updatedProperties;\n  }\n\n  #onTransactionParamsUpdated(\n    transactionMeta: TransactionMeta,\n    updatedParams: (keyof TransactionParams)[],\n  ) {\n    if (\n      (['to', 'value', 'data'] as const).some((param) =>\n        updatedParams.includes(param),\n      )\n    ) {\n      log('Updating simulation data due to transaction parameter update');\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.#updateSimulationData(transactionMeta);\n    }\n  }\n\n  async #updateSimulationData(transactionMeta: TransactionMeta) {\n    const { id: transactionId, chainId, txParams } = transactionMeta;\n    const { from, to, value, data } = txParams;\n\n    let simulationData: SimulationData = {\n      error: {\n        code: SimulationErrorCode.Disabled,\n        message: 'Simulation disabled',\n      },\n      tokenBalanceChanges: [],\n    };\n\n    if (this.#isSimulationEnabled()) {\n      this.#updateTransactionInternal(\n        { transactionId, skipHistory: true },\n        (txMeta) => {\n          txMeta.simulationData = undefined;\n        },\n      );\n\n      simulationData = await getSimulationData({\n        chainId,\n        from: from as Hex,\n        to: to as Hex,\n        value: value as Hex,\n        data: data as Hex,\n      });\n    }\n\n    const finalTransactionMeta = this.getTransaction(transactionId);\n\n    if (!finalTransactionMeta) {\n      log(\n        'Cannot update simulation data as transaction not found',\n        transactionId,\n        simulationData,\n      );\n\n      return;\n    }\n\n    this.#updateTransactionInternal(\n      {\n        transactionId,\n        note: 'TransactionController#updateSimulationData - Update simulation data',\n      },\n      (txMeta) => {\n        txMeta.simulationData = simulationData;\n      },\n    );\n\n    log('Updated simulation data', transactionId, simulationData);\n  }\n\n  #onGasFeePollerTransactionUpdate({\n    transactionId,\n    gasFeeEstimates,\n    gasFeeEstimatesLoaded,\n    layer1GasFee,\n  }: {\n    transactionId: string;\n    gasFeeEstimates?: GasFeeEstimates;\n    gasFeeEstimatesLoaded?: boolean;\n    layer1GasFee?: Hex;\n  }) {\n    this.#updateTransactionInternal(\n      { transactionId, skipHistory: true },\n      (txMeta) => {\n        if (gasFeeEstimates) {\n          txMeta.gasFeeEstimates = gasFeeEstimates;\n        }\n\n        if (gasFeeEstimatesLoaded !== undefined) {\n          txMeta.gasFeeEstimatesLoaded = gasFeeEstimatesLoaded;\n        }\n\n        if (layer1GasFee) {\n          txMeta.layer1GasFee = layer1GasFee;\n        }\n      },\n    );\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAS,UAAU,cAAgC;AAEnD,SAAS,0BAA0B;AACnC,SAAS,mBAAmB;AAW5B,SAAS,sBAAsB;AAC/B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,OAAO,cAAc;AAYrB,SAAS,yBAAyB;AAClC,SAAS,YAAY,WAAW,sBAAsB;AAEtD,SAAS,aAAa;AACtB,SAAS,aAAa;AACtB,SAAS,sBAAsB;AAC/B,SAAS,oBAAoB;AAC7B,SAAS,WAAW,WAAW,OAAO,QAAQ,QAAQ,eAAe;AACrE,SAAS,oBAAoB;AAK7B,SAAS,MAAM,cAAc;AA4E7B,IAAM,WAAW;AAAA,EACf,cAAc;AAAA,IACZ,SAAS;AAAA,IACT,WAAW;AAAA,EACb;AAAA,EACA,YAAY;AAAA,IACV,SAAS;AAAA,IACT,WAAW;AAAA,EACb;AAAA,EACA,yBAAyB;AAAA,IACvB,SAAS;AAAA,IACT,WAAW;AAAA,EACb;AACF;AAEO,IAAM,WAAW,SAAS;AAyE1B,IAAM,cAAc;AAKpB,IAAM,gBAAgB;AAiH7B,IAAM,iBAAiB;AAgNhB,IAAK,gBAAL,kBAAKA,mBAAL;AACL,EAAAA,eAAA,cAAW;AACX,EAAAA,eAAA,iBAAc;AACd,EAAAA,eAAA,iCAA8B;AAHpB,SAAAA;AAAA,GAAA;AAWZ,SAAS,uCAAmE;AAC1E,SAAO;AAAA,IACL,YAAY,CAAC;AAAA,IACb,cAAc,CAAC;AAAA,IACf,yBAAyB,CAAC;AAAA,EAC5B;AACF;AA1iBA;AA+iBO,IAAM,wBAAN,cAAoC,eAIzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoKA,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,uBAAuB,CAAC;AAAA,IACxB,sBAAsB;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,IACA,sBAAsB,CAAC;AAAA,IACvB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,0BAA0B;AAAA,IAC1B;AAAA,EACF,GAAiC;AAC/B,UAAM;AAAA,MACJ,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,OAAO;AAAA,QACL,GAAG,qCAAqC;AAAA,QACxC,GAAG;AAAA,MACL;AAAA,IACF,CAAC;AA6/EH;AAyBA;AA0BA;AA4CA;AAaA;AASA;AAaA;AASA;AAwBA;AAoDA;AAIA;AAIA;AAmDA;AA0BA;AAeA,uBAAM;AAsDN;AApjGA,wCAAkB,IAAI,aAAa;AAQnC,SAAiB,qBAAkC,oBAAI,IAAI;AAM3D,SAAiB,QAAQ,IAAI,MAAM;AA2BnC,uBAAS,6BAAT;AAMA,uBAAS,4BAAT;AAIA,SAAiB,qBAA8C,oBAAI,IAAI;AAEvE;AAEA;AAmEA;AAkqFA,mEAA6C,MAAM;AAEjD,WAAK,0BAA0B,2BAA2B;AAC1D,yBAAK,2BAA0B,0CAA0C;AAAA,IAC3E;AAxlFE,SAAK,kBAAkB;AACvB,SAAK,kBAAkB;AACvB,SAAK,4BAA4B,0BAA0B;AAC3D,SAAK,oBAAoB,kBAAkB;AAC3C,SAAK,kBAAkB,gBAAgB;AACvC,uBAAK,sBAAuB,wBAAwB,MAAM;AAE1D,SAAK,WAAW,IAAI,eAAe,EAAE,SAAS,CAAC;AAC/C,SAAK,kBAAkB,oBAAoB,CAAC,aAAa;AACzD,SAAK,wCACH,0CAA0C,MAAM,QAAQ,QAAQ,IAAI;AACtE,SAAK,wCACH;AACF,SAAK,qBACH,uBAAuB,MAAM,QAAQ,QAAQ,CAAC,CAAgB;AAChE,SAAK,uBAAuB;AAC5B,SAAK,qBAAqB;AAC1B,SAAK,iCACH,mCAAmC,MAAM,CAAC;AAC5C,SAAK,0BAA0B;AAC/B,uBAAK,6BAA8B;AACnC,uBAAK,4BAA6B;AAClC,uBAAK,0BAA2B;AAChC,SAAK,OAAO;AAEZ,SAAK,YAAY,OAAO,cAAc,MAAM;AAC5C,SAAK,sBAAsB,OAAO,wBAAwB,MAAM;AAChE,SAAK,gCACH,OAAO;AAAA,KAEN,MAAM;AACT,SAAK,gBAAgB,OAAO,kBAAkB,MAAM;AACpD,SAAK,6BACH,OAAO,+BAA+B,MAAM,CAAC;AAC/C,SAAK,UACH,OAAO,YAAY,MAAM,QAAQ,QAAQ,EAAE,iBAAiB,OAAU,CAAC;AAEzE,SAAK,eAAe,sBAAK,4CAAL,WAAyB;AAAA,MAC3C;AAAA,MACA;AAAA,IACF;AAEA,uBAAK,2BAA4B,IAAI,yBAAyB;AAAA,MAC5D;AAAA,MACA;AAAA,MACA,cAAc,KAAK;AAAA,MACnB,4BAA4B;AAAA,MAC5B,8BAA8B,CAAC,YAAiB;AAC9C,eAAO,KAAK,gBAAgB;AAAA,UAC1B;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,MACA,sBAAuB,CAAC,oBAAqC;AAC3D,eAAO,KAAK,gBAAgB;AAAA,UAC1B;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,MACA;AAAA,MACA,0CACE,sBAAK,wFAA0C,KAAK,IAAI;AAAA,MAC1D,0CACE,sBAAK,wFAA0C,KAAK,IAAI;AAAA,MAC1D,oBAAoB,sBAAK,4CAAoB,KAAK,IAAI;AAAA,MACtD,iCACE,sBAAK,sEAAiC,KAAK,IAAI;AAAA,MACjD,iCACE,sBAAK,sEAAiC,KAAK,IAAI;AAAA,MACjD,sBAAsB,CAAC,aAAa;AAClC,aAAK,gBAAgB;AAAA,UACnB;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AACD,uBAAK,2BAA0B,WAAW;AAE1C,UAAM,mCACJ,IAAI,iCAAiC;AAAA,MACnC,uBAAuB,qBAAqB;AAAA,IAC9C,CAAC;AAEH,SAAK,4BAA4B,sBAAK,sEAAL,WAAsC;AAAA,MACrE;AAAA,MACA;AAAA,IACF;AAEA,SAAK,4BAA4B,sBAAK,sEAAL,WAAsC;AAAA,MACrE;AAAA,MACA;AAAA,IACF;AAEA,SAAK,cAAc,sBAAK,oCAAL;AACnB,SAAK,oBAAoB,sBAAK,gDAAL;AAEzB,UAAM,eAAe,IAAI,aAAa;AAAA;AAAA,MAEpC,aAAa,KAAK,YAAY,MAAM,GAAG,EAAE;AAAA,MACzC,8BAA8B,KAAK;AAAA,MACnC,aAAa,CAAC,SAAS,oBACrB,mBAAK,2BAA0B,YAAY;AAAA,QACzC;AAAA,QACA;AAAA,MACF,CAAC;AAAA,MACH,iBAAiB,MAAM,KAAK,MAAM;AAAA,MAClC,mBAAmB,KAAK;AAAA,MACxB,eAAe,CAAC,aAAa;AAC3B,aAAK,gBAAgB;AAAA,UACnB;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAED,iBAAa,IAAI;AAAA,MACf;AAAA,MACA,sBAAK,sEAAiC,KAAK,IAAI;AAAA,IACjD;AAIA,SAAK,gBAAgB;AAAA,MACnB;AAAA,MACA,mBAAK;AAAA,IACP;AAIA,yBAAqB,MAAM;AACzB,oBAAI,2BAA2B,KAAK,WAAW,CAAC;AAChD,WAAK,0BAA0B,2BAA2B;AAC1D,WAAK,cAAc;AAAA,IACrB,CAAC;AAED,SAAK,cAAc;AACnB,uBAAK,4CAAL;AAAA,EACF;AAAA,EAhQQ,gBACN,iBACA,OACA,UACA;AACA,UAAM,qBAAqB,MAAM,CAAC,GAAG,iBAAiB;AAAA,MACpD,OAAO,iBAAiB,KAAK;AAAA,MAC7B;AAAA,IACF,CAAC;AACD,SAAK,gBAAgB,QAAQ,GAAG,cAAc,sBAAsB;AAAA,MAClE;AAAA,MACA,OAAO,MAAM;AAAA,MACb,iBAAiB;AAAA,IACnB,CAAC;AACD,SAAK;AAAA,MACH;AAAA,MACA;AAAA,IACF;AACA,SAAK,0BAA0B,kBAAkB;AACjD,SAAK,gBAAgB;AAAA,MACnB,GAAG,cAAc;AAAA,MACjB;AAAA,IACF;AACA,uBAAK,iBAAgB;AAAA,MACnB,GAAG,gBAAgB,EAAE;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAc,eAAe,gBAA6C;AACxE,UAAM,iBAAiB,MAAM,KAAK,SAAS,OAAO,cAAc;AAChE,QAAI,CAAC,gBAAgB;AACnB,aAAO;AAAA,QACL,gBAAgB;AAAA,QAChB,sBAAsB,EAAE,MAAM,QAAW,MAAM,OAAU;AAAA,MAC3D;AAAA,IACF;AACA,UAAM,uBAAuB,KAAK,SAAS,MAAM,cAAc;AAC/D,WAAO,EAAE,gBAAgB,qBAAqB;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EA8NA,UAAU;AACR,0BAAK,sCAAL;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,iBAAiB,gBAA6C;AAClE,UAAM,cAAc,MAAM,KAAK,MAAM,QAAQ;AAC7C,QAAI;AACF,YAAM,EAAE,WAAW,IAAI,KAAK;AAC5B,YAAM,cAAc,OAAO,KAAK,UAAU,EAAE;AAAA,QAC1C,CAAC,wBAAwB,mBAAmB;AAAA,MAC9C;AACA,UAAI,aAAa;AACf,eAAO,WAAW,cAAc;AAAA,MAClC;AACA,YAAM,WAAW,MAAM,KAAK,eAAe,cAAc;AACzD,WAAK,OAAO,CAAC,UAAU;AACrB,cAAM,WAAW,cAAc,IAAI;AAAA,MACrC,CAAC;AACD,aAAO;AAAA,IACT,UAAE;AACA,kBAAY;AAAA,IACd;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBA,MAAM,eACJ,UACA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAQ,CAAC;AAAA,IACT;AAAA,IACA;AAAA,EACF,IAcI,CAAC,GACY;AACjB,kBAAI,sBAAsB,QAAQ;AAElC,eAAW,2BAA2B,QAAQ;AAC9C,QACE,mBACA,CAAC,mBAAK,2BAA0B,IAAI,eAAe,GACnD;AACA,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,UAAM,sBAAsB,MAAM,KAAK;AAAA,MACrC;AAAA,IACF;AAEA,qBAAiB,UAAU,mBAAmB;AAE9C,QAAI,QAAQ;AACV,YAAM;AAAA,QACJ,MAAM,KAAK,qBAAqB,MAAM;AAAA,QACtC,KAAK,mBAAmB;AAAA,QACxB,SAAS;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAEA,UAAM,uBAAuB,KAAK;AAAA,MAChC;AAAA,MACA;AAAA,IACF;AAEA,UAAM,UAAU,KAAK,WAAW,eAAe;AAC/C,UAAM,WAAW,mBAAK,2BAA0B,YAAY;AAAA,MAC1D;AAAA,MACA;AAAA,IACF,CAAC;AAED,UAAM,kBACJ,SAAS,MAAM,yBAAyB,UAAU,QAAQ,GAAG;AAE/D,UAAM,0BAA0B,KAAK,2BAA2B,QAAQ;AAGxE,QAAI,uBAAuB,0BACvB,UAAU,uBAAuB,IACjC;AAAA;AAAA,MAEE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,IAAI,OAAO;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,MACA,MAAM,KAAK,IAAI;AAAA,MACf;AAAA,MACA,oBAAoB;AAAA,MACpB,sBAAsB;AAAA,MACtB,MAAM;AAAA,MACN;AAAA,IACF;AAEJ,UAAM,KAAK,oBAAoB,oBAAoB;AAGnD,QAAI,CAAC,yBAAyB;AAE5B,UAAI,UAAU,KAAK,yBAAyB;AAC1C,cAAM,2BAA2B,MAAM,KAAK;AAAA,UAC1C;AAAA,UACA;AAAA,QACF;AACA,6BAAqB,2BACnB;AAAA,MACJ;AAEA,UAAI,CAAC,KAAK,2BAA2B;AACnC,6BAAqB,kBAAkB,mBAAmB,CAAC;AAAA,MAC7D;AAEA,UAAI,CAAC,KAAK,mBAAmB;AAC3B,+BAAuB,0BAA0B,oBAAoB;AAAA,MACvE;AAEA,6BAAuB;AAAA,QACrB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,UACE,iBAAiB,KAAK;AAAA,UACtB,mBAAmB,KAAK,kBAAkB,KAAK,IAAI;AAAA,UACnD,WAAW,KAAK;AAAA,QAClB;AAAA,MACF;AAEA,WAAK,YAAY,oBAAoB;AAErC,UAAI,oBAAoB,OAAO;AAE7B,8BAAK,gDAAL,WAA2B;AAAA,MAC7B,OAAO;AACL,sBAAI,8CAA8C;AAAA,MACpD;AAEA,WAAK,gBAAgB;AAAA,QACnB,GAAG,cAAc;AAAA,QACjB;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,MACL,QAAQ,KAAK,gBAAgB,sBAAsB;AAAA,QACjD,YAAY,QAAQ,uBAAuB;AAAA,QAC3C;AAAA,QACA;AAAA,MACF,CAAC;AAAA,MACD,iBAAiB;AAAA,IACnB;AAAA,EACF;AAAA,EAEA,gCAAgC,mBAAsC,CAAC,GAAG;AACxE,QAAI,iBAAiB,WAAW,GAAG;AACjC,WAAK,0BAA0B,MAAM;AACrC;AAAA,IACF;AACA,uBAAK,2BAA0B;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAAA,EAEA,+BAA+B,mBAAsC,CAAC,GAAG;AACvE,QAAI,iBAAiB,WAAW,GAAG;AACjC,WAAK,0BAA0B,KAAK;AACpC;AAAA,IACF;AACA,uBAAK,2BAA0B;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAAA,EAEA,oCAAoC;AAClC,SAAK,0BAA0B,KAAK;AACpC,uBAAK,2BAA0B,kCAAkC;AAAA,EACnE;AAAA,EAEA,MAAM,2BAA2B,mBAAsC,CAAC,GAAG;AACzE,QAAI,iBAAiB,WAAW,GAAG;AACjC,YAAM,KAAK,0BAA0B,OAAO;AAC5C;AAAA,IACF;AACA,UAAM,mBAAK,2BAA0B;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,gBACJ,eACA,WACA;AAAA,IACE;AAAA,IACA;AAAA,EACF,IAAsD,CAAC,GACvD;AAEA,QAAI,KAAK,2BAA2B,QAAQ,GAAG;AAC7C;AAAA,IACF;AAEA,QAAI,WAAW;AAEb,kBAAY,sBAAsB,SAAS;AAC3C,wBAAkB,SAAS;AAAA,IAC7B;AAEA,kBAAI,+BAA+B,eAAe,SAAS;AAE3D,UAAM,kBAAkB,KAAK,eAAe,aAAa;AACzD,QAAI,CAAC,iBAAiB;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,MAAM;AACd,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC3C;AAGA,UAAM,cAAc;AAAA,MAClB,gBAAgB,SAAS;AAAA,MACzB;AAAA,IACF;AAEA,UAAM,qBAAqB,gBAAgB,SAAS,KAAK,UAAU;AAEnE,UAAM,cACH,sBACC,wBAAwB,oBAAoB,WAAW,KACzD;AAGF,UAAM,uBAAuB,gBAAgB,UAAU;AACvD,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,IACF;AACA,UAAM,qBACJ,yBAAyB,SAAS,KAAK,UAAU;AACnD,UAAM,kBACH,sBACC,wBAAwB,oBAAoB,eAAe,KAC5D,wBAAwB;AAG3B,UAAM,+BACJ,gBAAgB,UAAU;AAC5B,UAAM,0BAA0B;AAAA,MAC9B;AAAA,MACA;AAAA,IACF;AACA,UAAM,6BACJ,yBAAyB,SAAS,KAAK,UAAU;AACnD,UAAM,0BACH,8BACC;AAAA,MACE;AAAA,MACA;AAAA,IACF,KACD,gCAAgC;AAEnC,UAAM,cACJ,mBAAmB,0BACf;AAAA,MACE,MAAM,gBAAgB,SAAS;AAAA,MAC/B,UAAU,gBAAgB,SAAS;AAAA,MACnC,cAAc;AAAA,MACd,sBAAsB;AAAA,MACtB;AAAA,MACA,OAAO,gBAAgB,SAAS;AAAA,MAChC,IAAI,gBAAgB,SAAS;AAAA,MAC7B,OAAO;AAAA,IACT,IACA;AAAA,MACE,MAAM,gBAAgB,SAAS;AAAA,MAC/B,UAAU,gBAAgB,SAAS;AAAA,MACnC,UAAU;AAAA,MACV,OAAO,gBAAgB,SAAS;AAAA,MAChC,IAAI,gBAAgB,SAAS;AAAA,MAC7B,OAAO;AAAA,IACT;AAEN,UAAM,gBAAgB,KAAK;AAAA,MACzB,gBAAgB;AAAA,MAChB;AAAA,IACF;AAEA,UAAM,WAAW,MAAM,KAAK;AAAA,MAC1B;AAAA,MACA,gBAAgB,SAAS;AAAA,IAC3B;AAEA,UAAM,QAAQ,YAAY,SAAS,UAAU,CAAC;AAE9C,UAAM,SAAS,YAAY,gBAAgB,YAAY;AAEvD,UAAM,SAAS,YAAY,eACvB,gBAAgB,SAAS,eACzB,gBAAgB,SAAS;AAE7B,kBAAI,iCAAiC;AAAA,MACnC;AAAA,MACA;AAAA,MACA,UAAU;AAAA,IACZ,CAAC;AAED,UAAM,WAAW,mBAAK,2BAA0B,YAAY;AAAA,MAC1D,iBAAiB,gBAAgB;AAAA,MACjC,SAAS,gBAAgB;AAAA,IAC3B,CAAC;AACD,UAAM,OAAO,MAAM,KAAK;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAM,wBAAwB;AAAA,MAC5B;AAAA,MACA,SAAS,gBAAgB;AAAA,MACzB,iBAAiB,gBAAgB;AAAA,MACjC;AAAA,MACA;AAAA,MACA,IAAI,OAAO;AAAA,MACX,qBAAqB,gBAAgB,SAAS;AAAA,MAC9C;AAAA,MACA,MAAM,KAAK,IAAI;AAAA,MACf;AAAA,MACA,UAAU;AAAA,IACZ;AAEA,SAAK,YAAY,qBAAqB;AAGtC,SAAK,gBAAgB,QAAQ,GAAG,cAAc,wBAAwB;AAAA,MACpE,iBAAiB;AAAA,MACjB;AAAA,IACF,CAAC;AACD,SAAK,gBAAgB,QAAQ,GAAG,cAAc,yBAAyB;AAAA,MACrE,iBAAiB;AAAA,MACjB;AAAA,IACF,CAAC;AAED,SAAK,gBAAgB;AAAA,MACnB,GAAG,cAAc;AAAA,MACjB;AAAA,IACF;AACA,uBAAK,iBAAgB;AAAA,MACnB,GAAG,gBAAgB,EAAE;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,mBACJ,eACA,WACA;AAAA,IACE;AAAA,IACA;AAAA,EACF,IAAsD,CAAC,GACvD;AAEA,QAAI,KAAK,2BAA2B,QAAQ,GAAG;AAC7C;AAAA,IACF;AAEA,QAAI,WAAW;AAEb,kBAAY,sBAAsB,SAAS;AAC3C,wBAAkB,SAAS;AAAA,IAC7B;AAEA,kBAAI,iCAAiC,eAAe,SAAS;AAE7D,UAAM,kBAAkB,KAAK,MAAM,aAAa;AAAA,MAC9C,CAAC,EAAE,GAAG,MAAM,OAAO;AAAA,IACrB;AAEA,QAAI,CAAC,iBAAiB;AACpB;AAAA,IACF;AAGA,QAAI,CAAC,KAAK,MAAM;AACd,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC3C;AAGA,UAAM,cAAc;AAAA,MAClB,gBAAgB,SAAS;AAAA,MACzB;AAAA,IACF;AAEA,UAAM,qBAAqB,gBAAgB,SAAS,KAAK,UAAU;AAEnE,UAAM,cACH,sBACC,wBAAwB,oBAAoB,WAAW,KACzD;AAGF,UAAM,uBAAuB,gBAAgB,UAAU;AACvD,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,IACF;AACA,UAAM,qBACJ,yBAAyB,SAAS,KAAK,UAAU;AACnD,UAAM,kBACH,sBACC,wBAAwB,oBAAoB,eAAe,KAC5D,wBAAwB;AAG3B,UAAM,+BACJ,gBAAgB,UAAU;AAC5B,UAAM,0BAA0B;AAAA,MAC9B;AAAA,MACA;AAAA,IACF;AACA,UAAM,6BACJ,yBAAyB,SAAS,KAAK,UAAU;AACnD,UAAM,0BACH,8BACC;AAAA,MACE;AAAA,MACA;AAAA,IACF,KACD,gCAAgC;AAEnC,UAAM,WACJ,mBAAmB,0BACf;AAAA,MACE,GAAG,gBAAgB;AAAA,MACnB,UAAU,gBAAgB,SAAS;AAAA,MACnC,cAAc;AAAA,MACd,sBAAsB;AAAA,MACtB;AAAA,IACF,IACA;AAAA,MACE,GAAG,gBAAgB;AAAA,MACnB,UAAU,gBAAgB,SAAS;AAAA,MACnC,UAAU;AAAA,IACZ;AAEN,UAAM,gBAAgB,KAAK;AAAA,MACzB,gBAAgB;AAAA,MAChB;AAAA,IACF;AAEA,UAAM,WAAW,MAAM,KAAK;AAAA,MAC1B;AAAA,MACA,gBAAgB,SAAS;AAAA,IAC3B;AAEA,UAAM,yBAAyB,MAAM,KAAK;AAAA,MACxC;AAAA,MACA;AAAA,IACF;AACA,UAAM,QAAQ,YAAY,SAAS,UAAU,CAAC;AAE9C,UAAM,SAAS,SAAS,gBAAgB,SAAS;AAEjD,UAAM,SAAS,SAAS,eACpB,uBAAuB,SAAS,eAChC,uBAAuB,SAAS;AAEpC,kBAAI,mCAAmC,EAAE,QAAQ,QAAQ,SAAS,CAAC;AAEnE,UAAM,WAAW,mBAAK,2BAA0B,YAAY;AAAA,MAC1D,iBAAiB,gBAAgB;AAAA,MACjC,SAAS,gBAAgB;AAAA,IAC3B,CAAC;AACD,UAAM,OAAO,MAAM,KAAK;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAM,sBAAsB;AAAA,MAC1B,GAAG;AAAA,MACH;AAAA,MACA,IAAI,OAAO;AAAA,MACX,MAAM,KAAK,IAAI;AAAA,MACf;AAAA,MACA;AAAA,MACA,qBAAqB,gBAAgB,SAAS;AAAA,MAC9C;AAAA,MACA,cAAc,gBAAgB;AAAA,IAChC;AAEA,UAAM,qBACJ,mBAAmB,0BACf;AAAA,MACE,GAAG;AAAA,MACH,UAAU;AAAA,QACR,GAAG,gBAAgB;AAAA,QACnB,cAAc;AAAA,QACd,sBAAsB;AAAA,MACxB;AAAA,IACF,IACA;AAAA,MACE,GAAG;AAAA,MACH,UAAU;AAAA,QACR,GAAG,gBAAgB;AAAA,QACnB,UAAU;AAAA,MACZ;AAAA,IACF;AAEN,SAAK,YAAY,kBAAkB;AAGnC,SAAK,gBAAgB,QAAQ,GAAG,cAAc,wBAAwB;AAAA,MACpE,iBAAiB;AAAA,MACjB;AAAA,IACF,CAAC;AAED,SAAK,gBAAgB,QAAQ,GAAG,cAAc,yBAAyB;AAAA,MACrE,iBAAiB;AAAA,MACjB;AAAA,IACF,CAAC;AAED,SAAK,gBAAgB;AAAA,MACnB,GAAG,cAAc;AAAA,MACjB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,YACJ,aACA,iBACA;AACA,UAAM,WAAW,mBAAK,2BAA0B,YAAY;AAAA,MAC1D;AAAA,IACF,CAAC;AACD,UAAM,EAAE,cAAc,gBAAgB,IAAI,MAAM;AAAA,MAC9C;AAAA,MACA;AAAA,IACF;AAEA,WAAO,EAAE,KAAK,cAAc,gBAAgB;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,oBACJ,aACA,YACA,iBACA;AACA,UAAM,WAAW,mBAAK,2BAA0B,YAAY;AAAA,MAC1D;AAAA,IACF,CAAC;AACD,UAAM,EAAE,eAAe,cAAc,gBAAgB,IAAI,MAAM;AAAA,MAC7D;AAAA,MACA;AAAA,IACF;AAEA,UAAM,MAAM,aAAa,cAAc,eAAe,UAAU;AAEhE,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,kBAAkB,iBAAkC,MAAc;AAChE,UAAM,EAAE,IAAI,cAAc,IAAI;AAE9B,0BAAK,0DAAL,WACE,EAAE,eAAe,MAAM,aAAa,KAAK,kBAAkB,GAC3D,OAAO,EAAE,GAAG,gBAAgB;AAAA,EAEhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,4BACE,eACA,uBACA;AACA,QAAI,CAAC,uBAAuB;AAC1B,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,UAAM,kBAAkB,KAAK,eAAe,aAAa;AACzD,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,UAAM,yBAAyB;AAAA,MAC7B,GAAG;AAAA,MACH;AAAA,IACF;AACA,SAAK;AAAA,MACH;AAAA,MACA,GAAG,cAAc;AAAA,IACnB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,iBAAiB,eAAyB,SAAkB;AAE1D,QAAI,iBAAiB,CAAC,SAAS;AAC7B,WAAK,OAAO,CAAC,UAAU;AACrB,cAAM,eAAe,CAAC;AAAA,MACxB,CAAC;AACD;AAAA,IACF;AACA,UAAM,iBAAiB,KAAK,WAAW;AACvC,UAAM,kBAAkB,KAAK,MAAM,aAAa;AAAA,MAC9C,CAAC,EAAE,SAAS,SAAS,MAAM;AACzB,cAAM,oBAAoB,iBAAiB,YAAY;AAEvD,YAAI,CAAC,mBAAmB;AACtB,iBAAO;AAAA,QACT;AAEA,cAAM,oBACJ,CAAC,WAAW,SAAS,MAAM,YAAY,MAAM,QAAQ,YAAY;AAEnE,eAAO,CAAC;AAAA,MACV;AAAA,IACF;AAEA,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,eAAe,KAAK,yBAAyB,eAAe;AAAA,IACpE,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,2BACJ,iBACA,oBACA,eACA;AAEA,UAAM,qBAAqB,KAAK,uBAAuB,eAAe;AAEtE,QAAI;AACF,YAAM,gBAAgB,mBAAmB;AAGzC,YAAM,yBAAyB;AAAA,QAC7B,GAAG;AAAA,QACH;AAAA,QACA,WAAW;AAAA,MACb;AACA,UAAI,eAAe;AACjB,+BAAuB,gBAAgB;AAAA,MACzC;AAGA,WAAK,2BAA2B,aAAa;AAG7C,WAAK;AAAA,QACH;AAAA,QACA,GAAG,cAAc;AAAA,MACnB;AACA,WAAK,0BAA0B,sBAAsB;AAIrD,WAAK,kBAAkB,sBAAsB;AAE7C,WAAK,gBAAgB;AAAA,QACnB,GAAG,cAAc;AAAA,QACjB;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,0CAA0C,KAAK;AAAA,IAC/D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,iCACE,eACA,8BACA,sBACiB;AACjB,QAAI,KAAK,2BAA2B;AAClC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,UAAM,kBAAkB,KAAK,eAAe,aAAa;AAEzD,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA;AAAA,MACE;AAAA,MACA;AAAA,IACF;AAEA,UAAM,kBAAkB,gBAAgB,mBAAmB,CAAC;AAC5D,QAAI,iCAAiC,gBAAgB,QAAQ;AAC3D,YAAM,yBAAyB;AAAA,QAC7B,GAAG;AAAA,QACH,iBAAiB,CAAC,GAAG,iBAAiB,GAAG,oBAAoB;AAAA,MAC/D;AACA,WAAK;AAAA,QACH;AAAA,QACA,GAAG,cAAc;AAAA,MACnB;AAAA,IACF;AAEA,WAAO,KAAK,eAAe,aAAa;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBA,yBACE,eACA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAaiB;AACjB,UAAM,kBAAkB,KAAK,eAAe,aAAa;AAEzD,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA;AAAA,MACE;AAAA,MACA;AAAA,IACF;AAEA,QAAI,qBAAqB;AAAA,MACvB,UAAU;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA;AAAA,IAGF;AAGA,uBAAmB,WAAW,OAAO,mBAAmB,QAAQ;AAChE,yBAAqB,OAAO,kBAAkB;AAG9C,UAAM,cAAc,MAAM,CAAC,GAAG,iBAAiB,kBAAkB;AAEjE,SAAK;AAAA,MACH;AAAA,MACA,GAAG,cAAc;AAAA,IACnB;AAEA,WAAO,KAAK,eAAe,aAAa;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,wBACE,eACA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAKiB;AACjB,UAAM,kBAAkB,KAAK,eAAe,aAAa;AAEzD,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,oCAAgC,iBAAiB,yBAAyB;AAE1E,UAAM,yBAAyB;AAAA,MAC7B,aAAa;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA;AAAA;AAAA,IAGF;AAGA,2BAAuB,cAAc;AAAA,MACnC,uBAAuB;AAAA,IACzB;AAGA,UAAM,cAAc,MAAM,CAAC,GAAG,iBAAiB,sBAAsB;AAErE,SAAK;AAAA,MACH;AAAA,MACA,GAAG,cAAc;AAAA,IACnB;AAEA,WAAO,KAAK,eAAe,aAAa;AAAA,EAC1C;AAAA,EAEA,MAAM,aACJ,SACA,iBACoB;AACpB,WAAO,mBAAK,2BAA0B;AAAA,MACpC;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,MAAM,qBACJ,MACA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAQA;AACA,UAAM,kBAAkB,KAAK,eAAe,IAAI;AAChD,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,oCAAgC,iBAAiB,sBAAsB;AAEvE,UAAM,iBAAiB;AAAA,MACrB,UAAU;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,mBAAe,WAAW;AAAA,MACxB,eAAe;AAAA,IACjB;AAEA,UAAM,qBAAqB,MAAM,CAAC,GAAG,iBAAiB,cAAc;AACpE,UAAM,WAAW,mBAAK,2BAA0B,YAAY;AAAA,MAC1D,SAAS,gBAAgB;AAAA,MACzB,iBAAiB,gBAAgB;AAAA,IACnC,CAAC;AACD,UAAM,WAAW,IAAI,SAAS,QAAQ;AACtC,UAAM,EAAE,KAAK,IAAI,MAAM;AAAA,MACrB,mBAAmB;AAAA,MACnB;AAAA,IACF;AACA,uBAAmB,OAAO;AAE1B,UAAM,8BAA8B;AAAA,MAClC,mBAAmB,KAAK;AAAA,MACxB;AAAA,MACA,iBAAiB;AAAA,IACnB,CAAC;AAED,SAAK;AAAA,MACH;AAAA,MACA,8BAA8B,IAAI;AAAA,IACpC;AACA,WAAO,KAAK,eAAe,IAAI;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,iCACJ,iBAA2D,CAAC,GAC5D,EAAE,SAAS,IAA4B,CAAC,GACZ;AAC5B,kBAAI,0CAA0C;AAAA,MAC5C,cAAc;AAAA,IAChB,CAAC;AAED,QAAI,eAAe,WAAW,GAAG;AAC/B,aAAO;AAAA,IACT;AAEA,UAAM,YAAY,eAAe,CAAC;AAClC,UAAM,SAAS,KAAK,uBAAuB,UAAU,OAAO;AAO5D,QAAI;AACJ,QAAI;AACF,wBAAkB,KAAK,gBAAgB;AAAA,QACrC;AAAA,QACA,UAAU;AAAA,MACZ;AAAA,IACF,SAAS,KAAK;AACZ,oBAAI,+CAA+C,GAAG;AAAA,IACxD;AAEA,UAAM,mBAAmB,mBAAmB,WAAW,WAAW;AAAA,MAChE;AAAA,IACF,CAAC;AACD,UAAM,2BAA2B,YAAY,iBAAiB,UAAU,CAAC;AAEzE,QAAI,KAAK,mBAAmB,IAAI,wBAAwB,GAAG;AACzD,aAAO;AAAA,IACT;AAEA,SAAK,mBAAmB,IAAI,wBAAwB;AAEpD,QAAI,iBAAiB;AACrB,QAAI;AAEF,YAAM,cAAc,UAAU;AAC9B,YAAM,gBAAgB,aAAa;AAEnC,kBAAY,gBACR,MAAM,KAAK,aAAa,aAAa,eAAe,IACpD;AAEJ,YAAM,QAAQ,YACV,MAAM,UAAU,UAAU,SAAS,EAAE,CAAC,IACtC,UAAU;AAEd,UAAI,WAAW;AACb,sBAAI,kCAAkC,OAAO,UAAU,YAAY;AAAA,MACrE;AAEA,wBAAkB,MAAM,QAAQ;AAAA,QAC9B,eAAe,IAAI,CAAC,aAAa;AAC/B,mBAAS,QAAQ;AACjB,iBAAO,KAAK,wBAAwB,SAAS,SAAS,QAAQ;AAAA,QAChE,CAAC;AAAA,MACH;AAAA,IACF,SAAS,KAAK;AACZ,oBAAI,oDAAoD,GAAG;AAG3D,YAAM;AAAA,IACR,UAAE;AACA,iBAAW,YAAY;AACvB,WAAK,mBAAmB,OAAO,wBAAwB;AAAA,IACzD;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,2BACE,eACA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAKA;AACA,UAAM,kBAAkB,KAAK,eAAe,aAAa;AAEzD,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,gBAAgB,WAAW;AAC9B,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAEA,QACE,UACA,CAAC;AAAA;AAAA;AAAA;AAAA,IAID,EAAE,SAAS,MAAM,GACjB;AACA,YAAM,IAAI;AAAA,QACR,oDAAoD,MAAM;AAAA,MAC5D;AAAA,IACF;AAEA,UAAM,yBAAyB;AAAA,MAC7B,CAAC;AAAA,MACD;AAAA,MACA,OAAO,EAAE,MAAM,OAAO,CAAC;AAAA,IACzB;AAEA,QAAI,wCAAwC;AAC1C,6BAAuB,iBAAgB,oBAAI,KAAK,GAAE,QAAQ;AAAA,IAC5D;AAEA,QAAI,kCAAqC;AACvC,6BAAuB,QAAQ,iBAAiB,IAAI,MAAM,YAAY,CAAC;AAAA,IACzE;AAEA,SAAK;AAAA,MACH;AAAA,MACA,GAAG,cAAc;AAAA,IACnB;AAEA,QACE,mDAAsD,EAAE;AAAA,MACtD;AAAA,IACF,GACA;AACA,WAAK,gBAAgB;AAAA,QACnB,GAAG,cAAc;AAAA,QACjB;AAAA,MACF;AACA,yBAAK,iBAAgB;AAAA,QACnB,GAAG,uBAAuB,EAAE;AAAA,QAC5B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB;AACd,UAAM,UAAU,KAAK,WAAW;AAChC,UAAM,gBAAgB,KAAK,MAAM,aAAa;AAAA,MAC5C,CAAC,gBACC,YAAY,4CACZ,YAAY,YAAY,WACxB,CAAC,YAAY;AAAA,IACjB;AAEA,eAAW,UAAU,eAAe;AAClC,WAAK,gBAAgB,QAAQ;AAAA,QAC3B,mBAAmB;AAAA,MACrB,CAAC,EAAE,MAAM,CAAC,UAAU;AAClB,YAAI,OAAO,SAAS,WAAW,SAAS,qBAAqB;AAC3D;AAAA,QACF;AACA,gBAAQ,MAAM,+CAA+C,KAAK;AAAA,MACpE,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,gBAAgB;AAAA,IACd,iBAAiB,CAAC;AAAA,IAClB;AAAA,IACA,yBAAyB;AAAA,IACzB;AAAA,EACF,IAOI,CAAC,GAAsB;AACzB,UAAM,UAAU,KAAK,WAAW;AAOhC,UAAM,mBAAmB,UAAU,gBAAgB,CAAC,cAAc;AAChE,aAAO,OAAO,cAAc,aACxB;AAAA;AAAA;AAAA,QAGA,CAAC,MAAW,MAAM;AAAA;AAAA,IACxB,CAAC;AAED,UAAM,uBAAuB,eAAe,KAAK,MAAM;AAIvD,UAAM,uBAAuB;AAAA,MAC3B,OAAO,sBAAsB,CAAC,gBAAgB;AAC5C,YAAI,0BAA0B,YAAY,YAAY,SAAS;AAC7D,iBAAO;AAAA,QACT;AAGA,mBAAW,CAAC,KAAK,SAAS,KAAK,OAAO,QAAQ,gBAAgB,GAAG;AAM/D,cAAI,OAAO,YAAY,UAAU;AAG/B,gBAAI,UAAW,YAAY,SAAiB,GAAG,CAAC,MAAM,OAAO;AAC3D,qBAAO;AAAA,YACT;AAAA,UAGF,WAAW,UAAW,YAAoB,GAAG,CAAC,MAAM,OAAO;AACzD,mBAAO;AAAA,UACT;AAAA,QACF;AAEA,eAAO;AAAA,MACT,CAAC;AAAA,MACD;AAAA,IACF;AACA,QAAI,UAAU,QAAW;AAKvB,YAAM,SAAS,oBAAI,IAAI;AACvB,YAAM,MAAM,CAAC;AAMb,eAAS,IAAI,qBAAqB,SAAS,GAAG,IAAI,IAAI,KAAK;AACzD,cAAM,SAAS,qBAAqB,CAAC;AACrC,cAAM,EAAE,MAAM,IAAI,OAAO;AACzB,YAAI,CAAC,OAAO,IAAI,KAAK,GAAG;AACtB,cAAI,OAAO,OAAO,OAAO;AACvB,mBAAO,IAAI,KAAK;AAAA,UAClB,OAAO;AACL;AAAA,UACF;AAAA,QACF;AAGA,YAAI,QAAQ,MAAM;AAAA,MACpB;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,gBAAgB;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAI6B;AAC3B,UAAM,WAAW,mBAAK,2BAA0B,YAAY;AAAA,MAC1D;AAAA,MACA;AAAA,IACF,CAAC;AAED,WAAO,MAAM,2BAA2B;AAAA,MACtC,mBAAmB,KAAK;AAAA,MACxB;AAAA,MACA,iBAAiB;AAAA,QACf,UAAU;AAAA,QACV;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,wBACZ,SACA,mBACiB;AACjB,QAAI,CAAC,KAAK,MAAM;AACd,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC3C;AAEA,UAAM,8BACJ,2BAA2B,iBAAiB;AAC9C,UAAM,OAAO,qBAAqB,2BAA2B;AAG7D,UAAM,2BAA2B;AAAA,MAC/B,GAAG;AAAA,MACH;AAAA,MACA,UAAU,4BAA4B;AAAA,MACtC;AAAA,IACF;AAEA,UAAM,EAAE,KAAK,IAAI;AACjB,UAAM,SAAS,KAAK,uBAAuB,OAAO;AAClD,UAAM,sBAAsB,mBAAmB;AAAA,MAC7C;AAAA,MACA,EAAE,OAAO;AAAA,IACX;AACA,UAAM,oBAAoB,MAAM,KAAK,KAAK,qBAAqB,IAAI;AAEnE,UAAM,iBAAiB,YAAY,kBAAkB,UAAU,CAAC;AAChE,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,8BAA8B;AAC5B,UAAM,eAAe,KAAK,MAAM,aAAa;AAAA,MAC3C,CAAC,EAAE,OAAO,MAAM;AAAA,IAClB;AACA,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,eAAe,KAAK,yBAAyB,YAAY;AAAA,IACjE,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,wBAAwB,eAAuB;AAC7C,UAAM,kBAAkB,KAAK,eAAe,aAAa;AAEzD,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAEA,UAAM,gBAAgB,KAAK,mBAAmB,IAAI,aAAa;AAE/D,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,kBAAc;AAEd,SAAK,mBAAmB,OAAO,aAAa;AAAA,EAC9C;AAAA,EAEQ,YAAY,iBAAkC;AACpD,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,eAAe,KAAK,yBAAyB;AAAA,QACjD,GAAG,MAAM;AAAA,QACT;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,oBAAoB,iBAAkC;AAClE,UAAM,sBACH,MAAM,KAAK,wBAAwB,gBAAgB,eAAe,KACnE,gBAAgB,SAAS;AAE3B,UAAM,EAAE,iBAAiB,QAAQ,IAAI;AAErC,UAAM,kBAAkB,kBACpB,KAAK,gBAAgB;AAAA,MACnB;AAAA,MACA;AAAA,IACF,EAAE,cAAc,SAAS,kBAAkB,SAC3C,KAAK,gBAAgB,EAAE,eAAe,SAAS,YAAY;AAE/D,UAAM,WAAW,mBAAK,2BAA0B,YAAY;AAAA,MAC1D;AAAA,MACA;AAAA,IACF,CAAC;AAED,UAAM,WAAW,mBAAK,2BAA0B,YAAY;AAAA,MAC1D;AAAA,MACA;AAAA,IACF,CAAC;AAED,UAAM,UAAU;AAAA,MACd;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,IACV,CAAC;AAED,UAAM,cAAc;AAAA,MAClB,SAAS;AAAA,MACT;AAAA,MACA,aAAa,KAAK;AAAA,MAClB,oBAAoB,KAAK;AAAA,MACzB,iBAAiB,KAAK,gBAAgB,KAAK,IAAI;AAAA,MAC/C,QAAQ;AAAA,IACV,CAAC;AAED,UAAM,8BAA8B;AAAA,MAClC,mBAAmB,KAAK;AAAA,MACxB;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,gBAAgB;AACtB,SAAK,2BAA2B;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKQ,6BAA6B;AACnC,UAAM,uBAAuB,KAAK,MAAM,aAAa;AAAA,MACnD,CAAC,gBAAgB,YAAY;AAAA,IAC/B;AAEA,eAAW,mBAAmB,sBAAsB;AAClD,UAAI,KAAK,oBAAoB,eAAe,GAAG;AAC7C,aAAK,mBAAmB,gBAAgB,EAAE,EAAE,MAAM,CAAC,UAAU;AAE3D,kBAAQ,MAAM,gDAAgD,KAAK;AAAA,QACrE,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAc,gBACZ,iBACA;AAAA,IACE,aAAa;AAAA,IACb;AAAA,IACA,oBAAoB;AAAA,IACpB;AAAA,EACF,GAMiB;AACjB,UAAM,gBAAgB,gBAAgB;AACtC,QAAI;AACJ,UAAM,EAAE,MAAM,YAAY,IAAI,KAAK,uBAAuB,aAAa;AACvE,UAAM,kBAAkB,cACpB,QAAQ,QAAQ,IAAI,IACpB,KAAK,2BAA2B,aAAa;AAEjD,QAAI,QAAQ,CAAC,cAAc,CAAC,aAAa;AACvC,UAAI;AACF,YAAI,oBAAoB,OAAO;AAC7B,gBAAM,eAAe,MAAM,KAAK,gBAAgB,iBAAiB;AAAA,YAC/D;AAAA,UACF,CAAC;AACD,4BAAkB,aAAa;AAE/B,gBAAM,gBAAgB,aAAa;AAMnC,gBAAM,qBAAqB,eAAe;AAE1C,cAAI,oBAAoB;AACtB,0BAAI,2CAA2C;AAAA,cAC7C,aAAa,mBAAmB;AAAA,cAChC,QAAQ,mBAAmB;AAAA,YAC7B,CAAC;AAED,iBAAK;AAAA,cACH;AAAA,cACA;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,cAAM,EAAE,aAAa,cAAc,IACjC,KAAK,uBAAuB,aAAa;AAE3C,YAAI,CAAC,eAAe;AAClB,gBAAM,iBAAiB,MAAM,KAAK,mBAAmB,aAAa;AAClE,cACE,mBAAmB,uEACnB,iBACA;AACA,4BAAgB,QAAQ;AAAA,UAC1B;AACA,gBAAM,yBAAyB,KAAK;AAAA,YAClC;AAAA,UACF;AACA,eAAK,gBAAgB;AAAA,YACnB,GAAG,cAAc;AAAA,YACjB;AAAA,cACE,iBAAiB;AAAA,cACjB;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MAGF,SAAS,OAAY;AACnB,cAAM,EAAE,aAAa,cAAc,IACjC,KAAK,uBAAuB,aAAa;AAC3C,YAAI,CAAC,eAAe;AAClB,cAAI,OAAO,SAAS,WAAW,SAAS,qBAAqB;AAC3D,iBAAK,kBAAkB,eAAe,QAAQ;AAE9C,kBAAM,eAAe;AAAA,cACnB;AAAA,YACF;AAAA,UACF,OAAO;AACL,iBAAK,gBAAgB,MAAM,OAAO,QAAQ;AAAA,UAC5C;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,YAAY,MAAM;AAExB,YAAQ,WAAW,QAAQ;AAAA,MACzB;AACE,yBAAiB,MAAM,UAAU,KAAK;AACtC,cAAM,UAAU,SAAS,UAAU,MAAM,OAAO;AAAA,MAElD;AACE,yBAAiB,QAAQ;AACzB,eAAO,UAAU;AAAA,MAEnB;AACE,cAAM,gBAAgB,UAAU;AAAA,UAC9B,2CAA2C,KAAK;AAAA,YAC9C,aAAa;AAAA,UACf,CAAC;AAAA,QACH;AAEA,yBAAiB,MAAM,aAAa;AACpC,cAAM;AAAA,IACV;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAc,mBAAmB,eAAuB;AACtD,UAAM,EAAE,aAAa,IAAI,KAAK;AAC9B,UAAM,cAAc,MAAM,KAAK,MAAM,QAAQ;AAC7C,UAAM,QAAQ,aAAa,UAAU,CAAC,EAAE,GAAG,MAAM,kBAAkB,EAAE;AACrE,UAAM,kBAAkB,aAAa,KAAK;AAC1C,UAAM,yBAAyB,UAAU,eAAe;AAExD,UAAM;AAAA,MACJ,UAAU,EAAE,KAAK;AAAA,MACjB;AAAA,IACF,IAAI;AAEJ,QAAI;AAEJ,QAAI;AACF,UAAI,CAAC,KAAK,MAAM;AACd,oBAAY;AACZ,aAAK;AAAA,UACH;AAAA,UACA,IAAI,MAAM,yBAAyB;AAAA,QACrC;AACA,eAAO;AAAA,MACT,WAAW,CAAC,gBAAgB,SAAS;AACnC,oBAAY;AACZ,aAAK,gBAAgB,iBAAiB,IAAI,MAAM,qBAAqB,CAAC;AACtE,eAAO;AAAA,MACT;AAEA,UAAI,KAAK,mBAAmB,IAAI,aAAa,GAAG;AAC9C,sBAAI,4CAA4C,aAAa;AAC7D,eAAO;AAAA,MACT;AAEA,YAAM,CAAC,OAAO,YAAY,IAAI,MAAM;AAAA,QAClC;AAAA,QACA,CAAC,YACC,mBAAK,2BAA0B,aAAa,SAAS,eAAe;AAAA,MACxE;AAEA,yBAAmB;AAEnB,6BAAuB;AACvB,6BAAuB,WAAW;AAAA,QAChC,GAAG,uBAAuB;AAAA,QAC1B;AAAA,QACA,SAAS,gBAAgB;AAAA,MAC3B;AAEA,YAAM,eAAe;AAAA,QACnB,GAAG,uBAAuB;AAAA,QAC1B,UAAU,uBAAuB,SAAS;AAAA,MAC5C;AAEA,WAAK;AAAA,QACH;AAAA,QACA;AAAA,MACF;AAEA,WAAK,0BAA0B,sBAAsB;AAErD,YAAM,YAAY,qBAAqB,uBAAuB,QAAQ;AAEtE,YAAM,WAA8B,YAChC;AAAA,QACE,GAAG;AAAA,QACH,kBAAkB,uBAAuB,SAAS;AAAA,QAClD;AAAA,MACF,IACA;AAEJ,YAAM,QAAQ,MAAM,KAAK;AAAA,QACvB;AAAA,QACA;AAAA,MACF;AAEA,UAAI,CAAC,KAAK,cAAc,sBAAsB,GAAG;AAC/C,sBAAI,+CAA+C;AACnD,aAAK,gBAAgB;AAAA,UACnB,GAAG,cAAc;AAAA,UACjB;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAEA,UAAI,CAAC,OAAO;AACV,eAAO;AAAA,MACT;AAEA,YAAM,WAAW,mBAAK,2BAA0B,YAAY;AAAA,QAC1D,iBAAiB,gBAAgB;AAAA,QACjC,SAAS,gBAAgB;AAAA,MAC3B,CAAC;AAED,UAAI,gBAAgB,4BAA+B;AACjD,sBAAI,qCAAqC;AAEzC,cAAM,eAAe,MAAM,MAAM,UAAU,cAAc,CAAC,IAAI,CAAC;AAE/D,+BAAuB,eAAe;AAEtC;AAAA,UACE;AAAA,UACA,uBAAuB;AAAA,QACzB;AAAA,MACF;AAEA,oBAAI,0BAA0B,QAAQ;AAEtC,UAAI,EAAE,iBAAiB,KAAK,IAAI,MAAM,KAAK;AAAA,QACzC;AAAA,QACA;AAAA,MACF;AAEA,UAAI,SAAS,QAAW;AACtB,eAAO,MAAM,KAAK,mBAAmB,UAAU,KAAK;AAAA,MACtD;AAEA,oBAAI,sBAAsB,IAAI;AAE9B,6BAAuB,OAAO;AAC9B,6BAAuB;AACvB,6BAAuB,iBAAgB,oBAAI,KAAK,GAAE,QAAQ;AAE1D,WAAK;AAAA,QACH;AAAA,QACA;AAAA,MACF;AAEA,WAAK,gBAAgB,QAAQ,GAAG,cAAc,yBAAyB;AAAA,QACrE,iBAAiB;AAAA,MACnB,CAAC;AAED,WAAK,gBAAgB;AAAA,QACnB,GAAG,cAAc;AAAA,QACjB;AAAA,MACF;AACA,yBAAK,iBAAgB;AAAA,QACnB,GAAG,uBAAuB,EAAE;AAAA,QAC5B;AAAA,MACF;AAEA,WAAK,0BAA0B,sBAAsB;AACrD,aAAO;AAAA,IAGT,SAAS,OAAY;AACnB,WAAK,gBAAgB,iBAAiB,KAAK;AAC3C,aAAO;AAAA,IACT,UAAE;AACA,WAAK,mBAAmB,OAAO,aAAa;AAE5C,yBAAmB;AACnB,kBAAY;AAAA,IACd;AAAA,EACF;AAAA,EAEA,MAAc,mBACZ,UACA,gBACiB;AACjB,WAAO,MAAM,MAAM,UAAU,sBAAsB,CAAC,cAAc,CAAC;AAAA,EACrE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,kBAAkB,eAAuB,UAAmB;AAClE,UAAM,kBAAkB,KAAK,MAAM,aAAa;AAAA,MAC9C,CAAC,EAAE,GAAG,MAAM,OAAO;AAAA,IACrB;AACA,QAAI,CAAC,iBAAiB;AACpB;AAAA,IACF;AACA,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,eAAe,MAAM,aAAa;AAAA,QACtC,CAAC,EAAE,GAAG,MAAM,OAAO;AAAA,MACrB;AACA,YAAM,eAAe,KAAK,yBAAyB,YAAY;AAAA,IACjE,CAAC;AACD,UAAM,yBAAyB;AAAA,MAC7B,GAAG;AAAA,MACH;AAAA,IACF;AACA,SAAK,gBAAgB;AAAA,MACnB,GAAG,cAAc;AAAA,MACjB;AAAA,IACF;AACA,uBAAK,iBAAgB;AAAA,MACnB,GAAG,gBAAgB,EAAE;AAAA,MACrB;AAAA,IACF;AACA,SAAK,gBAAgB,QAAQ,GAAG,cAAc,wBAAwB;AAAA,MACpE,iBAAiB;AAAA,MACjB;AAAA,IACF,CAAC;AACD,SAAK,0BAA0B,sBAAsB;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBQ,yBACN,cACmB;AACnB,UAAM,kBAAkB,oBAAI,IAAI;AAEhC,UAAM,YAAY,CAAC,GAAG,YAAY,EAC/B,KAAK,CAAC,GAAG,MAAO,EAAE,OAAO,EAAE,OAAO,KAAK,CAAE,EACzC,OAAO,CAAC,OAAO;AACd,YAAM,EAAE,SAAS,QAAQ,UAAU,KAAK,IAAI;AAE5C,UAAI,UAAU;AACZ,cAAM,MAAM,GAAG,OAAO,SAAS,KAAK,CAAC,IAAI;AAAA,UACvC;AAAA,QACF,CAAC,IAAI,IAAI,KAAK,IAAI,EAAE,aAAa,CAAC;AAElC,YAAI,gBAAgB,IAAI,GAAG,GAAG;AAC5B,iBAAO;AAAA,QACT,WACE,gBAAgB,OAAO,mBAAK,6BAC5B,CAAC,KAAK,aAAa,MAAM,GACzB;AACA,0BAAgB,IAAI,GAAG;AACvB,iBAAO;AAAA,QACT;AAAA,MACF;AAEA,aAAO;AAAA,IACT,CAAC;AAEH,cAAU,QAAQ;AAClB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,aAAa,QAAoC;AACvD,WACE,wCACA,0CACA;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,kBAAkB,QAAoC;AAC5D,WAAO;AAAA;AAAA;AAAA;AAAA;AAAA,IAKP,EAAE,SAAS,MAAM;AAAA,EACnB;AAAA,EAEA,MAAc,gBACZ,QACA,EAAE,kBAAkB,GACA;AACpB,UAAM,KAAK,KAAK,cAAc,MAAM;AACpC,UAAM,EAAE,OAAO,IAAI;AACnB,UAAM,OAAO,aAAa;AAC1B,UAAM,cAAc,EAAE,MAAM,OAAO,GAAG;AAEtC,WAAQ,MAAM,KAAK,gBAAgB;AAAA,MACjC;AAAA,MACA;AAAA,QACE;AAAA,QACA,QAAQ,UAAU;AAAA,QAClB;AAAA,QACA;AAAA,QACA,eAAe;AAAA,MACjB;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,eAAe,eAAoD;AACzE,UAAM,EAAE,aAAa,IAAI,KAAK;AAC9B,WAAO,aAAa,KAAK,CAAC,EAAE,GAAG,MAAM,OAAO,aAAa;AAAA,EAC3D;AAAA,EAEQ,cAAc,QAAyB;AAC7C,WAAO,OAAO,OAAO,EAAE;AAAA,EACzB;AAAA,EAEQ,uBAAuB,eAG7B;AACA,UAAM,cAAc,KAAK,eAAe,aAAa;AAErD,QAAI,CAAC,aAAa;AAChB,aAAO,EAAE,MAAM,QAAW,aAAa,MAAM;AAAA,IAC/C;AAEA,UAAM,cAAc,KAAK,kBAAkB,YAAY,MAAM;AAE7D,WAAO,EAAE,MAAM,aAAa,YAAY;AAAA,EAC1C;AAAA,EAEQ,WAAW,iBAAwC;AACzD,QAAI,iBAAiB;AACnB,aAAO,KAAK,gBAAgB;AAAA,QAC1B;AAAA,QACA;AAAA,MACF,EAAE,cAAc;AAAA,IAClB;AACA,UAAM,EAAE,eAAe,IAAI,KAAK,gBAAgB;AAChD,WAAO,eAAe;AAAA,EACxB;AAAA,EAEQ,qBACN,SACA,UACkB;AAClB,WAAO,mBAAmB,WAAW,UAAU;AAAA,MAC7C,QAAQ;AAAA,MACR,QAAQ,KAAK,uBAAuB,OAAO;AAAA,IAC7C,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYQ,uBAAuB,SAAsB;AACnD,UAAM,oBAA0C;AAAA,MAC9C,SAAS,SAAS,SAAS,EAAE;AAAA,MAC7B,iBAAiB;AAAA,IACnB;AAEA,WAAO,OAAO,OAAO,iBAAiB;AAAA,EACxC;AAAA,EAEQ,uBAAuB;AAAA,IAC7B;AAAA,IACA;AAAA,EACF,GAGG;AACD,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,EAAE,cAAc,oBAAoB,IAAI;AAC9C,YAAM,sBAAsB;AAAA,QAC1B,GAAG;AAAA,QACH,GAAG,oBAAoB,IAAI,CAAC,wBAAwB;AAClD,gBAAM,qBAAqB,QAAQ;AAAA,YACjC,CAAC,EAAE,KAAK,MAAM,SAAS,oBAAoB;AAAA,UAC7C;AAEA,iBAAO,sBAAsB;AAAA,QAC/B,CAAC;AAAA,MACH;AAEA,YAAM,eAAe,KAAK,yBAAyB,mBAAmB;AAAA,IACxE,CAAC;AAAA,EACH;AAAA,EAEQ,iCAAiC;AAAA,IACvC;AAAA,IACA;AAAA,EACF,GAKG;AACD,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,0BAA0B;AAAA,IAClC,CAAC;AACD,SAAK,gBAAgB;AAAA,MACnB,GAAG,cAAc;AAAA,MACjB;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,6BACN,UACA,QACkC;AAClC,QAAI,CAAC,UAAU,WAAW,iBAAiB;AACzC,aAAO;AAAA,IACT;AAEA,UAAM,EAAE,UAAU,cAAc,sBAAsB,IAAI,IAAI;AAE9D,QACE,aAAa,UACb,iBAAiB,UACjB,yBAAyB,UACzB,QAAQ,QACR;AACA,aAAO;AAAA,IACT;AAEA,UAAM,uBAA6C,CAAC;AAEpD,QAAI,aAAa,QAAW;AAC1B,2BAAqB,WAAW;AAAA,IAClC,WACE,iBAAiB,UACjB,yBAAyB,QACzB;AACA,2BAAqB,eAAe;AACpC,2BAAqB,uBAAuB;AAAA,IAC9C;AAEA,QAAI,QAAQ,QAAW;AACrB,2BAAqB,MAAM;AAAA,IAC7B;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,uBAAuB,iBAAkC;AAC/D,UAAM,EAAE,QAAQ,IAAI;AACpB,UAAM,EAAE,aAAa,IAAI,KAAK;AAC9B,UAAM,cAAc,iBAAiB,UAAU;AAC/C,UAAM,iCAAiC,aAAa;AAAA,MAClD,CAAC,gBACC,YAAY,SAAS,SAAS,eAC9B,YAAY,YAAY;AAAA,IAC5B;AACA,UAAM,eAAe,+BAA+B;AAAA,MAClD,CAAC,gBAAgB,YAAY;AAAA,IAC/B;AACA,UAAM,aAAa,+BAA+B;AAAA,MAChD,CAAC,gBAAgB,YAAY;AAAA,IAC/B;AAEA;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAGA,UAAM,sBACH,gBAAgB,WAAW,CAAC,GAAG,WAAW,KAAK,CAAC,KAAK,oBAClD,0BAA0B,eAAe,IACzC;AAEN,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,eAAe,KAAK,yBAAyB;AAAA,QACjD,GAAG,MAAM;AAAA,QACT;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,2BAA2B,eAAuB;AACxD,UAAM,kBAAkB,KAAK,eAAe,aAAa;AACzD,QAAI,CAAC,iBAAiB;AACpB;AAAA,IACF;AACA,UAAM,QAAQ,gBAAgB,UAAU;AACxC,UAAM,OAAO,gBAAgB,UAAU;AACvC,UAAM,EAAE,QAAQ,IAAI;AAEpB,UAAM,wBAAwB,KAAK,MAAM,aAAa;AAAA,MACpD,CAAC,gBACC,YAAY,OAAO,iBACnB,YAAY,SAAS,SAAS,QAC9B,YAAY,SAAS,UAAU,SAC/B,YAAY,YAAY,WACxB,YAAY;AAAA,IAChB;AACA,UAAM,0BAA0B,sBAAsB;AAAA,MACpD,CAAC,gBAAgB,YAAY;AAAA,IAC/B;AAEA,QAAI,sBAAsB,WAAW,GAAG;AACtC;AAAA,IACF;AAEA,SAAK,OAAO,CAAC,UAAU;AACrB,iBAAW,eAAe,MAAM,cAAc;AAC5C,YAAI,wBAAwB,SAAS,YAAY,EAAE,GAAG;AACpD,sBAAY,aAAa,iBAAiB;AAC1C,sBAAY,eAAe,iBAAiB;AAAA,QAC9C;AAAA,MACF;AAAA,IACF,CAAC;AAED,eAAW,eAAe,KAAK,MAAM,cAAc;AACjD,UACE,wBAAwB,SAAS,YAAY,EAAE,KAC/C,YAAY,kCACZ;AACA,aAAK,4BAA4B,WAAW;AAAA,MAC9C;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,4BAA4B,iBAAkC;AACpE,UAAM,yBAAyB;AAAA,MAC7B,GAAG;AAAA,MACH;AAAA,IACF;AACA,SAAK,gBAAgB,QAAQ,GAAG,cAAc,uBAAuB;AAAA,MACnE,iBAAiB;AAAA,IACnB,CAAC;AACD,SAAK;AAAA,MACH;AAAA,MACA;AAAA,IACF;AACA,SAAK,0BAA0B,sBAAsB;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,2BAA2B,UAAmB;AACpD,WAAO,KAAK,MAAM,aAAa;AAAA,MAC7B,CAAC,gBAAgB,YAAY,YAAY,aAAa;AAAA,IACxD;AAAA,EACF;AAAA,EAEA,MAAc,2BACZ,eAC0B;AAC1B,WAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,yBAAK,iBAAgB,KAAK,GAAG,aAAa,aAAa,CAAC,WAAW;AACjE,gBAAQ,MAAM;AAAA,MAChB,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAc,yBACZ,iBACA,UAC0B;AAC1B,UAAM,yBAAyB,UAAU,eAAe;AAExD,eAAW,OAAO,CAAC,KAAK,KAAK,GAAG,GAAY;AAC1C,YAAM,QAAQ,SAAS,GAAG;AAE1B,UAAI,UAAU,UAAa,UAAU,MAAM;AACzC;AAAA,MACF;AAEA,6BAAuB,GAAG,IAAI,MAAM,MAAM,SAAS,EAAE,CAAC;AAAA,IACxD;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,wBAAwB,iBAAmC;AACvE,UAAM,oCACJ,MAAM,KAAK,sCAAsC,eAAe;AAElE,UAAM,oCACJ,MAAM,KAAK,sCAAsC;AAEnD,WACE,qCAAqC;AAAA,EAEzC;AAAA,EAEA,MAAc,gBACZ,iBACA,UAC6B;AAC7B,kBAAI,uBAAuB,QAAQ;AAEnC,UAAM,gBAAgB,KAAK;AAAA,MACzB,gBAAgB;AAAA,MAChB;AAAA,IACF;AAEA,SAAK,mBAAmB,IAAI,gBAAgB,EAAE;AAE9C,UAAM,WAAW,MAAM,IAAI,QAA0B,CAAC,SAAS,WAAW;AACxE,WAAK;AAAA,QACH;AAAA,QACA,SAAS;AAAA,QACT,GAAG,KAAK,2BAA2B,eAAe;AAAA,MACpD,EAAE,KAAK,SAAS,MAAM;AAEtB,WAAK,mBAAmB;AAAA,QAAI,gBAAgB;AAAA,QAAI,MAC9C,OAAO,IAAI,MAAM,yBAAyB,CAAC;AAAA,MAC7C;AAAA,IACF,CAAC;AAED,SAAK,mBAAmB,OAAO,gBAAgB,EAAE;AAEjD,QAAI,CAAC,UAAU;AACb,oBAAI,iDAAiD;AACrD,aAAO;AAAA,IACT;AAEA,QAAI,CAAC,KAAK,UAAU,iBAAiB,QAAQ,GAAG;AAC9C,WAAK;AAAA,QACH;AAAA,QACA;AAAA,MACF;AAEA,oBAAI,sCAAsC;AAE1C,aAAO;AAAA,IACT;AAEA,UAAM,yBAAyB;AAAA,MAC7B,GAAI,MAAM,KAAK,yBAAyB,iBAAiB,QAAQ;AAAA,MACjE;AAAA,IACF;AAEA,SAAK;AAAA,MACH;AAAA,MACA;AAAA,IACF;AAEA,SAAK,0BAA0B,sBAAsB;AAErD,UAAM,QAAQ,YAAY,SAAS,UAAU,CAAC;AAE9C,UAAM,2BAA2B,MAAM,CAAC,GAAG,wBAAwB;AAAA,MACjE;AAAA,IACF,CAAC;AAED,SAAK;AAAA,MACH;AAAA,MACA;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,0BAA0B,iBAAkC;AAClE,SAAK,gBAAgB,QAAQ,GAAG,cAAc,6BAA6B;AAAA,MACzE;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,4BACN,QACA,SACA,UAAkB,KAAK,WAAW,GAClC;AACA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK,MAAM;AAAA,IACb;AAAA,EACF;AAAA,EAEQ,uBAAuB,iBAAkC;AAC/D,kBAAI,oCAAoC,gBAAgB,EAAE;AAE1D,SAAK,2BAA2B,gBAAgB,EAAE;AAElD,SAAK,gBAAgB;AAAA,MACnB,GAAG,cAAc;AAAA,MACjB;AAAA,IACF;AAEA,SAAK,0BAA0B,eAAe;AAI9C,SAAK,kBAAkB,eAAe;AAAA,EACxC;AAAA,EAEA,MAAc,kBAAkB,iBAAkC;AAChE,QAAI;AACF,UAAI,gBAAgB,4BAA+B;AACjD;AAAA,MACF;AAEA,YAAM,WAAW,mBAAK,2BAA0B,YAAY;AAAA,QAC1D,iBAAiB,gBAAgB;AAAA,QACjC,SAAS,gBAAgB;AAAA,MAC3B,CAAC;AACD,YAAM,EAAE,wBAAwB,wBAAwB,IACtD,MAAM,6BAA6B,iBAAiB;AAAA,QAClD;AAAA,QACA,gBAAgB,KAAK,eAAe,KAAK,IAAI;AAAA,QAC7C,mBAAmB,KAAK,kBAAkB,KAAK,IAAI;AAAA,MACrD,CAAC;AAEH,WAAK,gBAAgB;AAAA,QACnB,GAAG,cAAc;AAAA,QACjB;AAAA,UACE,iBAAiB;AAAA,UACjB;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AAEd,oBAAI,iDAAiD,KAAK;AAAA,IAC5D;AAAA,EACF;AAAA,EAsLA,MAAc,2BACZ,UACA,OACA,iBACiB;AACjB,QAAI;AACF,YAAM,OAAO,MAAM,KAAK,mBAAmB,UAAU,KAAK;AAC1D,aAAO;AAAA,IACT,SAAS,OAAgB;AACvB,UAAI,KAAK,mCAAmC,KAAc,GAAG;AAC3D,cAAM,KAAK,0BAA0B;AAAA,UACnC;AAAA,QACF;AACA,cAAM,IAAI,MAAM,2CAA2C;AAAA,MAC7D;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWQ,mCAAmC,OAAqB;AAC9D,WACE,OAAO,SAAS,SAAS,eAAe,KACxC,OAAO,MAAM,SAAS,SAAS,eAAe;AAAA,EAElD;AAwLF;AAhlGE;AAyCS;AAMA;AAMT;AAEA;AAmEA;AAykFA;AAAA,wBAAmB,SAAC;AAAA,EAClB;AAAA,EACA;AAAA,EACA;AACF,GAIiB;AACf,SAAO,IAAI,aAAa;AAAA;AAAA;AAAA,IAGtB;AAAA,IACA;AAAA,IACA,wBAAwB,sBAAK,4EAAoC;AAAA,MAC/D;AAAA,MACA;AAAA,IACF;AAAA,IACA,0BAA0B,KAAK,4BAA4B;AAAA,MACzD;AAAA;AAAA,IAEF;AAAA,EACF,CAAC;AACH;AAEA;AAAA,qCAAgC,SAAC;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AACF,GAI8B;AAC5B,QAAM,4BAA4B,IAAI,0BAA0B;AAAA,IAC9D;AAAA,IACA,mBAAmB,KAAK;AAAA,IACxB,4BAA4B,MAAM,KAAK,MAAM;AAAA,IAC7C,YAAY,UAAU,MAAM,UAAU,KAAK,WAAW,KAAK,IAAI;AAAA,IAC/D,WAAW,mBAAK,6BAA4B;AAAA,IAC5C,oBAAoB,mBAAK,6BAA4B;AAAA,IACrD,yBAAyB;AAAA,IACzB,kBAAkB,mBAAK;AAAA,IACvB,oBAAoB,mBAAK,6BAA4B;AAAA,EACvD,CAAC;AAED,wBAAK,kFAAL,WAA4C;AAE5C,SAAO;AACT;AAEA;AAAA,qCAAgC,SAAC;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AACF,GAI8B;AAC5B,QAAM,WAAW,IAAI,SAAS,QAAQ;AACtC,QAAM,aAAa,UAAU,MAAM,UAAU,KAAK,WAAW,KAAK,IAAI;AAEtE,QAAM,4BAA4B,IAAI,0BAA0B;AAAA,IAC9D,oBAAoB,OAAO,kBAA0B;AACnD,YAAM,KAAK,mBAAmB,aAAa;AAAA,IAC7C;AAAA,IACA;AAAA,IACA;AAAA,IACA,aAAa,MAAM;AAAA,IACnB,iBAAiB,MAAM,KAAK,MAAM;AAAA,IAClC,mBAAmB,mBAAK,4BAA2B;AAAA,IACnD,eAAe,MACb,mBAAK,2BAA0B,8BAA8B;AAAA,MAC3D,SAAS,WAAW;AAAA,IACtB,CAAC;AAAA,IACH,oBAAoB,KAAK,mBAAmB,KAAK,IAAI;AAAA,IACrD,OAAO;AAAA,MACL,+BACE,KAAK,8BAA8B,KAAK,IAAI;AAAA,MAC9C,eAAe,KAAK,cAAc,KAAK,IAAI;AAAA,IAC7C;AAAA,EACF,CAAC;AAED,wBAAK,kFAAL,WAA4C;AAE5C,SAAO;AACT;AAEA;AAMA;AAAA,qBAAgB,WAAG;AACjB,OAAK,0BAA0B,KAAK;AACpC,wBAAK,wFAAL,WACE,KAAK;AAEP,OAAK,0BAA0B,KAAK;AACpC,wBAAK,wFAAL,WACE,KAAK;AAGP,qBAAK,2BAA0B,gBAAgB;AACjD;AAEA;AAAA,8CAAyC,SACvC,2BACA;AACA,4BAA0B,IAAI,mBAAmB,cAAc;AAC/D,4BAA0B,IAAI;AAAA,IAC5B;AAAA,EACF;AACF;AAEA;AAAA,2CAAsC,SACpC,2BACA;AACA,4BAA0B,IAAI;AAAA,IAC5B;AAAA,IACA,KAAK,uBAAuB,KAAK,IAAI;AAAA,EACvC;AACA,4BAA0B,IAAI;AAAA,IAC5B;AAAA,IACA,KAAK,iCAAiC,KAAK,IAAI;AAAA,EACjD;AACF;AAEA;AAAA,8CAAyC,SACvC,2BACA;AACA,4BAA0B,IAAI,mBAAmB,uBAAuB;AACxE,4BAA0B,IAAI,mBAAmB,qBAAqB;AACtE,4BAA0B,IAAI,mBAAmB,oBAAoB;AACrE,4BAA0B,IAAI,mBAAmB,qBAAqB;AACxE;AAEA;AAAA,2CAAsC,SACpC,2BACA;AACA,4BAA0B,IAAI;AAAA,IAC5B;AAAA,IACA,KAAK,uBAAuB,KAAK,IAAI;AAAA,EACvC;AAEA,4BAA0B,IAAI;AAAA,IAC5B;AAAA,IACA,KAAK,4BAA4B,KAAK,IAAI;AAAA,EAC5C;AAEA,4BAA0B,IAAI;AAAA,IAC5B;AAAA,IACA,KAAK,gBAAgB,KAAK,IAAI;AAAA,EAChC;AAEA,4BAA0B,IAAI;AAAA,IAC5B;AAAA,IACA,KAAK,kBAAkB,KAAK,IAAI;AAAA,EAClC;AACF;AAEA;AAAA,wCAAmC,SACjC,SACA,SACA;AACA,QAAM,8BAA8B,KAAK;AAAA;AAAA,IAEvC;AAAA,IACA;AAAA,EACF;AAEA,QAAM,8BAA8B,KAAK;AAAA,IACvC;AAAA,IACA;AAAA,EACF;AACA,SAAO,CAAC,GAAG,6BAA6B,GAAG,2BAA2B;AACxE;AAqCA;AAAA,oBAAe,WAAiB;AAC9B,SAAO,CAAC,IAAI,gBAAgB,GAAG,IAAI,kBAAkB,CAAC;AACxD;AAEA;AAAA,0BAAqB,WAAuB;AAC1C,SAAO,CAAC,IAAI,yBAAyB,GAAG,IAAI,uBAAuB,CAAC;AACtE;AAEA;AAAA,+BAA0B,SACxB;AAAA,EACE;AAAA,EACA;AAAA,EACA;AACF,GACA,UACA;AACA,MAAI,2BAAwD,CAAC;AAE7D,OAAK,OAAO,CAAC,UAAU;AACrB,UAAM,QAAQ,MAAM,aAAa;AAAA,MAC/B,CAAC,EAAE,GAAG,MAAM,OAAO;AAAA,IACrB;AAEA,QAAIC,mBAAkB,MAAM,aAAa,KAAK;AAG9C,IAAAA,mBAAkB,SAASA,gBAAe,KAAKA;AAE/C,IAAAA,iBAAgB,WAAW;AAAA,MACzBA,iBAAgB;AAAA,IAClB;AAEA,qBAAiBA,iBAAgB,QAAQ;AAEzC,+BACE,sBAAK,sEAAL,WAAsCA;AAExC,QAAI,gBAAgB,MAAM;AACxB,MAAAA,mBAAkB;AAAA,QAChBA;AAAA,QACA,QAAQ;AAAA,MACV;AAAA,IACF;AAEA,UAAM,aAAa,KAAK,IAAIA;AAAA,EAC9B,CAAC;AAED,QAAM,kBAAkB,KAAK;AAAA,IAC3B;AAAA,EACF;AAEA,MAAI,yBAAyB,SAAS,GAAG;AACvC,0BAAK,4DAAL,WACE,iBACA;AAAA,EAEJ;AACF;AAEA;AAAA,qCAAgC,SAAC,oBAAqC;AACpE,QAAM,EAAE,IAAI,eAAe,UAAU,UAAU,IAAI;AAEnD,QAAM,iBAAiB,KAAK,eAAe,aAAa,GAAG;AAE3D,MAAI,CAAC,kBAAkB,QAAQ,gBAAgB,SAAS,GAAG;AACzD,WAAO,CAAC;AAAA,EACV;AAEA,QAAM,SAAS,OAAO,KAAK,SAAS;AAEpC,QAAM,oBAAoB,OAAO;AAAA,IAC/B,CAAC,UAAU,UAAU,KAAK,MAAM,eAAe,KAAK;AAAA,EACtD;AAEA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AACT;AAEA;AAAA,gCAA2B,SACzB,iBACA,eACA;AACA,MACG,CAAC,MAAM,SAAS,MAAM,EAAY;AAAA,IAAK,CAAC,UACvC,cAAc,SAAS,KAAK;AAAA,EAC9B,GACA;AACA,kBAAI,8DAA8D;AAElE,0BAAK,gDAAL,WAA2B;AAAA,EAC7B;AACF;AAEM;AAAA,0BAAqB,eAAC,iBAAkC;AAC5D,QAAM,EAAE,IAAI,eAAe,SAAS,SAAS,IAAI;AACjD,QAAM,EAAE,MAAM,IAAI,OAAO,KAAK,IAAI;AAElC,MAAI,iBAAiC;AAAA,IACnC,OAAO;AAAA,MACL;AAAA,MACA,SAAS;AAAA,IACX;AAAA,IACA,qBAAqB,CAAC;AAAA,EACxB;AAEA,MAAI,mBAAK,sBAAL,YAA6B;AAC/B,0BAAK,0DAAL,WACE,EAAE,eAAe,aAAa,KAAK,GACnC,CAAC,WAAW;AACV,aAAO,iBAAiB;AAAA,IAC1B;AAGF,qBAAiB,MAAM,kBAAkB;AAAA,MACvC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAEA,QAAM,uBAAuB,KAAK,eAAe,aAAa;AAE9D,MAAI,CAAC,sBAAsB;AACzB;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA;AAAA,EACF;AAEA,wBAAK,0DAAL,WACE;AAAA,IACE;AAAA,IACA,MAAM;AAAA,EACR,GACA,CAAC,WAAW;AACV,WAAO,iBAAiB;AAAA,EAC1B;AAGF,gBAAI,2BAA2B,eAAe,cAAc;AAC9D;AAEA;AAAA,qCAAgC,SAAC;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAKG;AACD,wBAAK,0DAAL,WACE,EAAE,eAAe,aAAa,KAAK,GACnC,CAAC,WAAW;AACV,QAAI,iBAAiB;AACnB,aAAO,kBAAkB;AAAA,IAC3B;AAEA,QAAI,0BAA0B,QAAW;AACvC,aAAO,wBAAwB;AAAA,IACjC;AAEA,QAAI,cAAc;AAChB,aAAO,eAAe;AAAA,IACxB;AAAA,EACF;AAEJ;","names":["ApprovalState","transactionMeta"]}