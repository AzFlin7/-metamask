{"version":3,"sources":["../src/utils/swaps.ts"],"sourcesContent":["import { query } from '@metamask/controller-utils';\nimport type EthQuery from '@metamask/eth-query';\nimport { merge, pickBy } from 'lodash';\n\nimport { CHAIN_IDS } from '../constants';\nimport { createModuleLogger, projectLogger } from '../logger';\nimport type { TransactionControllerMessenger } from '../TransactionController';\nimport type { TransactionMeta } from '../types';\nimport { TransactionType } from '../types';\nimport { validateIfTransactionUnapproved } from './utils';\n\nconst log = createModuleLogger(projectLogger, 'swaps');\n\n/**\n * Interval in milliseconds between checks of post transaction balance\n */\nexport const UPDATE_POST_TX_BALANCE_TIMEOUT = 5000;\n\n/**\n * Retry attempts for checking post transaction balance\n */\nexport const UPDATE_POST_TX_BALANCE_ATTEMPTS = 6;\n\nconst SWAPS_TESTNET_CHAIN_ID = '0x539';\n\n/**\n * An address that the metaswap-api recognizes as the default token for the current network, in place of the token address that ERC-20 tokens have\n */\nexport const DEFAULT_TOKEN_ADDRESS =\n  '0x0000000000000000000000000000000000000000';\n\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\ninterface SwapsTokenObject {\n  /**\n   * The name for the network\n   */\n  name: string;\n  /**\n   * An address that the metaswap-api recognizes as the default token\n   */\n  address: string;\n  /**\n   * Number of digits after decimal point\n   */\n  decimals: number;\n}\n\nconst ETH_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  name: 'Ether',\n  address: DEFAULT_TOKEN_ADDRESS,\n  decimals: 18,\n};\n\nconst BNB_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  name: 'Binance Coin',\n  address: DEFAULT_TOKEN_ADDRESS,\n  decimals: 18,\n} as const;\n\nconst MATIC_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  name: 'Matic',\n  address: DEFAULT_TOKEN_ADDRESS,\n  decimals: 18,\n} as const;\n\nconst AVAX_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  name: 'Avalanche',\n  address: DEFAULT_TOKEN_ADDRESS,\n  decimals: 18,\n} as const;\n\nconst TEST_ETH_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  name: 'Test Ether',\n  address: DEFAULT_TOKEN_ADDRESS,\n  decimals: 18,\n} as const;\n\nconst GOERLI_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  name: 'Ether',\n  address: DEFAULT_TOKEN_ADDRESS,\n  decimals: 18,\n} as const;\n\nconst ARBITRUM_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  ...ETH_SWAPS_TOKEN_OBJECT,\n} as const;\n\nconst OPTIMISM_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  ...ETH_SWAPS_TOKEN_OBJECT,\n} as const;\n\nconst ZKSYNC_ERA_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  ...ETH_SWAPS_TOKEN_OBJECT,\n} as const;\n\nexport const SWAPS_CHAINID_DEFAULT_TOKEN_MAP = {\n  [CHAIN_IDS.MAINNET]: ETH_SWAPS_TOKEN_OBJECT,\n  [SWAPS_TESTNET_CHAIN_ID]: TEST_ETH_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.BSC]: BNB_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.POLYGON]: MATIC_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.GOERLI]: GOERLI_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.AVALANCHE]: AVAX_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.OPTIMISM]: OPTIMISM_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.ARBITRUM]: ARBITRUM_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.ZKSYNC_ERA]: ZKSYNC_ERA_SWAPS_TOKEN_OBJECT,\n} as const;\n\nexport const SWAP_TRANSACTION_TYPES = [\n  TransactionType.swap,\n  TransactionType.swapApproval,\n];\n\n/**\n * Updates the transaction meta object with the swap information\n *\n * @param transactionMeta - The transaction meta object to update\n * @param transactionType - The type of the transaction\n * @param swaps - The swaps object\n * @param swaps.hasApproveTx - Whether the swap has an approval transaction\n * @param swaps.meta - The swap meta object\n * @param updateSwapsTransactionRequest - Dependency bag\n * @param updateSwapsTransactionRequest.isSwapsDisabled - Whether swaps are disabled\n * @param updateSwapsTransactionRequest.cancelTransaction - Function to cancel a transaction\n * @param updateSwapsTransactionRequest.messenger - TransactionController messenger\n * @returns A copy of the transaction meta object with updates, or the same\n * transaction meta object if no updates were made.\n */\nexport function updateSwapsTransaction(\n  transactionMeta: TransactionMeta,\n  transactionType: TransactionType,\n  swaps: {\n    hasApproveTx?: boolean;\n    meta?: Partial<TransactionMeta>;\n  },\n  {\n    isSwapsDisabled,\n    cancelTransaction,\n    messenger,\n  }: {\n    isSwapsDisabled: boolean;\n    cancelTransaction: (transactionId: string) => void;\n    messenger: TransactionControllerMessenger;\n  },\n): TransactionMeta {\n  if (isSwapsDisabled || !SWAP_TRANSACTION_TYPES.includes(transactionType)) {\n    return transactionMeta;\n  }\n\n  // The simulationFails property is added if the estimateGas call fails. In cases\n  // when no swaps approval tx is required, this indicates that the swap will likely\n  // fail. There was an earlier estimateGas call made by the swaps controller,\n  // but it is possible that external conditions have change since then, and\n  // a previously succeeding estimate gas call could now fail. By checking for\n  // the `simulationFails` property here, we can reduce the number of swap\n  // transactions that get published to the blockchain only to fail and thereby\n  // waste the user's funds on gas.\n  if (\n    transactionType === TransactionType.swap &&\n    swaps?.hasApproveTx === false &&\n    transactionMeta.simulationFails\n  ) {\n    cancelTransaction(transactionMeta.id);\n    throw new Error('Simulation failed');\n  }\n\n  const swapsMeta = swaps?.meta as Partial<TransactionMeta>;\n\n  if (!swapsMeta) {\n    return transactionMeta;\n  }\n\n  let updatedTransactionMeta = transactionMeta;\n\n  if (transactionType === TransactionType.swapApproval) {\n    updatedTransactionMeta = updateSwapApprovalTransaction(\n      transactionMeta,\n      swapsMeta,\n    );\n    messenger.publish('TransactionController:transactionNewSwapApproval', {\n      transactionMeta: updatedTransactionMeta,\n    });\n  }\n\n  if (transactionType === TransactionType.swap) {\n    updatedTransactionMeta = updateSwapTransaction(transactionMeta, swapsMeta);\n    messenger.publish('TransactionController:transactionNewSwap', {\n      transactionMeta: updatedTransactionMeta,\n    });\n  }\n\n  return updatedTransactionMeta;\n}\n\n/**\n * Attempts to update the post transaction balance of the provided transaction\n *\n * @param transactionMeta - Transaction meta object to update\n * @param updatePostTransactionBalanceRequest - Dependency bag\n * @param updatePostTransactionBalanceRequest.ethQuery - EthQuery object\n * @param updatePostTransactionBalanceRequest.getTransaction - Reading function for the latest transaction state\n * @param updatePostTransactionBalanceRequest.updateTransaction - Updating transaction function\n */\nexport async function updatePostTransactionBalance(\n  transactionMeta: TransactionMeta,\n  {\n    ethQuery,\n    getTransaction,\n    updateTransaction,\n  }: {\n    ethQuery: EthQuery;\n    getTransaction: (transactionId: string) => TransactionMeta | undefined;\n    updateTransaction: (transactionMeta: TransactionMeta, note: string) => void;\n  },\n): Promise<{\n  updatedTransactionMeta: TransactionMeta;\n  approvalTransactionMeta?: TransactionMeta;\n}> {\n  log('Updating post transaction balance', transactionMeta.id);\n\n  const transactionId = transactionMeta.id;\n  let latestTransactionMeta: TransactionMeta | undefined;\n  let approvalTransactionMeta;\n\n  for (let i = 0; i < UPDATE_POST_TX_BALANCE_ATTEMPTS; i++) {\n    log('Querying balance', { attempt: i });\n\n    const postTransactionBalance = await query(ethQuery, 'getBalance', [\n      transactionMeta.txParams.from,\n    ]);\n\n    latestTransactionMeta = {\n      ...(getTransaction(transactionId) ?? ({} as TransactionMeta)),\n    };\n\n    approvalTransactionMeta = latestTransactionMeta.approvalTxId\n      ? getTransaction(latestTransactionMeta.approvalTxId)\n      : undefined;\n\n    latestTransactionMeta.postTxBalance = postTransactionBalance.toString(16);\n\n    const isDefaultTokenAddress = isSwapsDefaultTokenAddress(\n      transactionMeta.destinationTokenAddress as string,\n      transactionMeta.chainId,\n    );\n\n    if (\n      !isDefaultTokenAddress ||\n      transactionMeta.preTxBalance !== latestTransactionMeta.postTxBalance\n    ) {\n      log('Finishing post balance update', {\n        isDefaultTokenAddress,\n        preTxBalance: transactionMeta.preTxBalance,\n        postTxBalance: latestTransactionMeta.postTxBalance,\n      });\n\n      break;\n    }\n\n    log('Waiting for balance to update', {\n      delay: UPDATE_POST_TX_BALANCE_TIMEOUT,\n    });\n\n    await sleep(UPDATE_POST_TX_BALANCE_TIMEOUT);\n  }\n\n  updateTransaction(\n    latestTransactionMeta as TransactionMeta,\n    'TransactionController#updatePostTransactionBalance - Add post transaction balance',\n  );\n\n  log('Completed post balance update', latestTransactionMeta?.postTxBalance);\n\n  return {\n    updatedTransactionMeta: latestTransactionMeta as TransactionMeta,\n    approvalTransactionMeta,\n  };\n}\n\n/**\n * Updates the transaction meta object with the swap information\n *\n * @param transactionMeta - Transaction meta object to update\n * @param propsToUpdate - Properties to update\n * @param propsToUpdate.sourceTokenSymbol - Symbol of the token to be swapped\n * @param propsToUpdate.destinationTokenSymbol - Symbol of the token to be received\n * @param propsToUpdate.type - Type of the transaction\n * @param propsToUpdate.destinationTokenDecimals - Decimals of the token to be received\n * @param propsToUpdate.destinationTokenAddress - Address of the token to be received\n * @param propsToUpdate.swapMetaData - Metadata of the swap\n * @param propsToUpdate.swapTokenValue - Value of the token to be swapped\n * @param propsToUpdate.estimatedBaseFee - Estimated base fee of the transaction\n * @param propsToUpdate.approvalTxId - Transaction id of the approval transaction\n * @returns The updated transaction meta object.\n */\nfunction updateSwapTransaction(\n  transactionMeta: TransactionMeta,\n  {\n    sourceTokenSymbol,\n    destinationTokenSymbol,\n    type,\n    destinationTokenDecimals,\n    destinationTokenAddress,\n    swapMetaData,\n    swapTokenValue,\n    estimatedBaseFee,\n    approvalTxId,\n  }: Partial<TransactionMeta>,\n): TransactionMeta {\n  validateIfTransactionUnapproved(transactionMeta, 'updateSwapTransaction');\n\n  let swapTransaction = {\n    sourceTokenSymbol,\n    destinationTokenSymbol,\n    type,\n    destinationTokenDecimals,\n    destinationTokenAddress,\n    swapMetaData,\n    swapTokenValue,\n    estimatedBaseFee,\n    approvalTxId,\n  };\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  swapTransaction = pickBy(swapTransaction) as any;\n\n  return merge({}, transactionMeta, swapTransaction);\n}\n\n/**\n * Updates the transaction meta object with the swap approval information\n *\n * @param transactionMeta - Transaction meta object to update\n * @param propsToUpdate - Properties to update\n * @param propsToUpdate.type - Type of the transaction\n * @param propsToUpdate.sourceTokenSymbol - Symbol of the token to be swapped\n * @returns The updated transaction meta object.\n */\nfunction updateSwapApprovalTransaction(\n  transactionMeta: TransactionMeta,\n  { type, sourceTokenSymbol }: Partial<TransactionMeta>,\n): TransactionMeta {\n  validateIfTransactionUnapproved(\n    transactionMeta,\n    'updateSwapApprovalTransaction',\n  );\n\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let swapApprovalTransaction = { type, sourceTokenSymbol } as any;\n  swapApprovalTransaction = pickBy({\n    type,\n    sourceTokenSymbol,\n  }) as Partial<TransactionMeta>;\n\n  return merge({}, transactionMeta, swapApprovalTransaction);\n}\n\n/**\n * Checks whether the provided address is strictly equal to the address for\n * the default swaps token of the provided chain.\n *\n * @param address - The string to compare to the default token address\n * @param chainId - The hex encoded chain ID of the default swaps token to check\n * @returns Whether the address is the provided chain's default token address\n */\nfunction isSwapsDefaultTokenAddress(address: string, chainId: string) {\n  if (!address || !chainId) {\n    return false;\n  }\n\n  return (\n    address ===\n    SWAPS_CHAINID_DEFAULT_TOKEN_MAP[\n      chainId as keyof typeof SWAPS_CHAINID_DEFAULT_TOKEN_MAP\n    ]?.address\n  );\n}\n\n/**\n * Sleeps for the provided number of milliseconds\n *\n * @param ms - Number of milliseconds to sleep\n * @returns Promise that resolves after the provided number of milliseconds\n */\nfunction sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n"],"mappings":";;;;;;;;;;;;AAAA,SAAS,aAAa;AAEtB,SAAS,OAAO,cAAc;AAS9B,IAAM,MAAM,mBAAmB,eAAe,OAAO;AAK9C,IAAM,iCAAiC;AAKvC,IAAM,kCAAkC;AAE/C,IAAM,yBAAyB;AAKxB,IAAM,wBACX;AAmBF,IAAM,yBAA2C;AAAA,EAC/C,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AACZ;AAEA,IAAM,yBAA2C;AAAA,EAC/C,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AACZ;AAEA,IAAM,2BAA6C;AAAA,EACjD,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AACZ;AAEA,IAAM,0BAA4C;AAAA,EAChD,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AACZ;AAEA,IAAM,8BAAgD;AAAA,EACpD,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AACZ;AAEA,IAAM,4BAA8C;AAAA,EAClD,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AACZ;AAEA,IAAM,8BAAgD;AAAA,EACpD,GAAG;AACL;AAEA,IAAM,8BAAgD;AAAA,EACpD,GAAG;AACL;AAEA,IAAM,gCAAkD;AAAA,EACtD,GAAG;AACL;AAEO,IAAM,kCAAkC;AAAA,EAC7C,CAAC,UAAU,OAAO,GAAG;AAAA,EACrB,CAAC,sBAAsB,GAAG;AAAA,EAC1B,CAAC,UAAU,GAAG,GAAG;AAAA,EACjB,CAAC,UAAU,OAAO,GAAG;AAAA,EACrB,CAAC,UAAU,MAAM,GAAG;AAAA,EACpB,CAAC,UAAU,SAAS,GAAG;AAAA,EACvB,CAAC,UAAU,QAAQ,GAAG;AAAA,EACtB,CAAC,UAAU,QAAQ,GAAG;AAAA,EACtB,CAAC,UAAU,UAAU,GAAG;AAC1B;AAEO,IAAM,yBAAyB;AAAA;AAAA;AAGtC;AAiBO,SAAS,uBACd,iBACA,iBACA,OAIA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AACF,GAKiB;AACjB,MAAI,mBAAmB,CAAC,uBAAuB,SAAS,eAAe,GAAG;AACxE,WAAO;AAAA,EACT;AAUA,MACE,yCACA,OAAO,iBAAiB,SACxB,gBAAgB,iBAChB;AACA,sBAAkB,gBAAgB,EAAE;AACpC,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACrC;AAEA,QAAM,YAAY,OAAO;AAEzB,MAAI,CAAC,WAAW;AACd,WAAO;AAAA,EACT;AAEA,MAAI,yBAAyB;AAE7B,MAAI,uDAAkD;AACpD,6BAAyB;AAAA,MACvB;AAAA,MACA;AAAA,IACF;AACA,cAAU,QAAQ,oDAAoD;AAAA,MACpE,iBAAiB;AAAA,IACnB,CAAC;AAAA,EACH;AAEA,MAAI,uCAA0C;AAC5C,6BAAyB,sBAAsB,iBAAiB,SAAS;AACzE,cAAU,QAAQ,4CAA4C;AAAA,MAC5D,iBAAiB;AAAA,IACnB,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAWA,eAAsB,6BACpB,iBACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AACF,GAQC;AACD,MAAI,qCAAqC,gBAAgB,EAAE;AAE3D,QAAM,gBAAgB,gBAAgB;AACtC,MAAI;AACJ,MAAI;AAEJ,WAAS,IAAI,GAAG,IAAI,iCAAiC,KAAK;AACxD,QAAI,oBAAoB,EAAE,SAAS,EAAE,CAAC;AAEtC,UAAM,yBAAyB,MAAM,MAAM,UAAU,cAAc;AAAA,MACjE,gBAAgB,SAAS;AAAA,IAC3B,CAAC;AAED,4BAAwB;AAAA,MACtB,GAAI,eAAe,aAAa,KAAM,CAAC;AAAA,IACzC;AAEA,8BAA0B,sBAAsB,eAC5C,eAAe,sBAAsB,YAAY,IACjD;AAEJ,0BAAsB,gBAAgB,uBAAuB,SAAS,EAAE;AAExE,UAAM,wBAAwB;AAAA,MAC5B,gBAAgB;AAAA,MAChB,gBAAgB;AAAA,IAClB;AAEA,QACE,CAAC,yBACD,gBAAgB,iBAAiB,sBAAsB,eACvD;AACA,UAAI,iCAAiC;AAAA,QACnC;AAAA,QACA,cAAc,gBAAgB;AAAA,QAC9B,eAAe,sBAAsB;AAAA,MACvC,CAAC;AAED;AAAA,IACF;AAEA,QAAI,iCAAiC;AAAA,MACnC,OAAO;AAAA,IACT,CAAC;AAED,UAAM,MAAM,8BAA8B;AAAA,EAC5C;AAEA;AAAA,IACE;AAAA,IACA;AAAA,EACF;AAEA,MAAI,iCAAiC,uBAAuB,aAAa;AAEzE,SAAO;AAAA,IACL,wBAAwB;AAAA,IACxB;AAAA,EACF;AACF;AAkBA,SAAS,sBACP,iBACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GACiB;AACjB,kCAAgC,iBAAiB,uBAAuB;AAExE,MAAI,kBAAkB;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAGA,oBAAkB,OAAO,eAAe;AAExC,SAAO,MAAM,CAAC,GAAG,iBAAiB,eAAe;AACnD;AAWA,SAAS,8BACP,iBACA,EAAE,MAAM,kBAAkB,GACT;AACjB;AAAA,IACE;AAAA,IACA;AAAA,EACF;AAIA,MAAI,0BAA0B,EAAE,MAAM,kBAAkB;AACxD,4BAA0B,OAAO;AAAA,IAC/B;AAAA,IACA;AAAA,EACF,CAAC;AAED,SAAO,MAAM,CAAC,GAAG,iBAAiB,uBAAuB;AAC3D;AAUA,SAAS,2BAA2B,SAAiB,SAAiB;AACpE,MAAI,CAAC,WAAW,CAAC,SAAS;AACxB,WAAO;AAAA,EACT;AAEA,SACE,YACA,gCACE,OACF,GAAG;AAEP;AAQA,SAAS,MAAM,IAAY;AACzB,SAAO,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,EAAE,CAAC;AACzD;","names":[]}