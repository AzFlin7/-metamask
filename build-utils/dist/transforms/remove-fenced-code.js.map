{"version":3,"file":"remove-fenced-code.js","sourceRoot":"","sources":["../../src/transforms/remove-fenced-code.ts"],"names":[],"mappings":"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","sourcesContent":["import { hasProperty } from '@metamask/utils';\n\n/**\n * Two sets of feature labels, where:\n * - `active` is the set of labels that are active for the current build.\n * - `all` is the set of all labels that are declared in the codebase.\n *\n * For `ONLY_INCLUDE_IF` fences, the code fence removal transform will\n * include the fenced code if any of the specified labels are active. See\n * {@link removeFencedCode} for details.\n */\nexport type FeatureLabels = {\n  active: ReadonlySet<string>;\n  all: ReadonlySet<string>;\n};\n\nenum DirectiveTerminus {\n  BEGIN = 'BEGIN',\n  END = 'END',\n}\n\nexport enum DirectiveCommand {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ONLY_INCLUDE_IF = 'ONLY_INCLUDE_IF',\n}\n\n// Matches lines starting with \"///:\", and any preceding whitespace, except\n// newlines. We except newlines to avoid eating blank lines preceding a fenced\n// line.\n// Double-negative RegEx credit: https://stackoverflow.com/a/3469155\nconst linesWithFenceRegex = /^[^\\S\\r\\n]*\\/\\/\\/:.*$/gmu;\n\n// Matches the first \"///:\" in a string, and any preceding whitespace\nconst fenceSentinelRegex = /^\\s*\\/\\/\\/:/u;\n\n// Breaks a fence directive into its constituent components.\n// At this stage of parsing, we are looking for one of:\n// - TERMINUS:COMMAND(PARAMS)\n// - TERMINUS:COMMAND\nconst directiveParsingRegex =\n  /^([A-Z]+):([A-Z_]+)(?:\\(((?:\\w[-\\w]*,)*\\w[-\\w]*)\\))?$/u;\n\n/**\n * Removes fenced code from the given JavaScript source string. \"Fenced code\"\n * includes the entire fence lines, including their trailing newlines, and the\n * lines that they surround.\n *\n * A valid fence consists of two well-formed fence lines, separated by one or\n * more lines that should be excluded. The first line must contain a `BEGIN`\n * directive, and the second most contain an `END` directive. Both directives\n * must specify the same command.\n *\n * Here's an example of a valid fence:\n *\n * ```javascript\n *   ///: BEGIN:ONLY_INCLUDE_IF(build-flask)\n *   console.log('I am Flask.');\n *   ///: END:ONLY_INCLUDE_IF\n * ```\n *\n * For details, please see the documentation.\n *\n * @param filePath - The path to the file being transformed.\n * @param fileContent - The contents of the file being transformed.\n * @param featureLabels - FeatureLabels that are currently active.\n * @returns A tuple of the post-transform file contents and a boolean indicating\n * whether they were modified.\n */\nexport function removeFencedCode(\n  filePath: string,\n  fileContent: string,\n  featureLabels: FeatureLabels,\n): [string, boolean] {\n  // Do not modify the file if we detect an inline sourcemap. For reasons\n  // yet to be determined, the transform receives every file twice while in\n  // watch mode, the second after Babel has transpiled the file. Babel adds\n  // inline source maps to the file, something we will never do in our own\n  // source files, so we use the existence of inline source maps to determine\n  // whether we should ignore the file.\n  if (/^\\/\\/# sourceMappingURL=/gmu.test(fileContent)) {\n    return [fileContent, false];\n  }\n\n  // If we didn't match any lines, return the unmodified file contents.\n  const matchedLines = [...fileContent.matchAll(linesWithFenceRegex)];\n\n  if (matchedLines.length === 0) {\n    return [fileContent, false];\n  }\n\n  // Parse fence lines\n  const parsedDirectives = matchedLines.map((matchArray) => {\n    const line = matchArray[0];\n\n    /* istanbul ignore next: should be impossible */\n    if (\n      matchArray.index === undefined ||\n      !line ||\n      !fenceSentinelRegex.test(line)\n    ) {\n      throw new Error(\n        getInvalidFenceLineMessage(\n          filePath,\n          line ?? '',\n          `Fence sentinel may only appear at the start of a line, optionally preceded by whitespace.`,\n        ),\n      );\n    }\n\n    // Store the start and end indices of each line\n    // Increment the end index by 1 to including the trailing newline when\n    // performing string operations.\n    const indices: [number, number] = [\n      matchArray.index,\n      matchArray.index + line.length + 1,\n    ];\n\n    const lineWithoutSentinel = line.replace(fenceSentinelRegex, '');\n    if (!/^ \\w\\w+/u.test(lineWithoutSentinel)) {\n      throw new Error(\n        getInvalidFenceLineMessage(\n          filePath,\n          line,\n          `Fence sentinel must be followed by a single space and an alphabetical string of two or more characters.`,\n        ),\n      );\n    }\n\n    const directiveMatches = lineWithoutSentinel\n      .trim()\n      .match(directiveParsingRegex);\n\n    if (!directiveMatches) {\n      throw new Error(\n        getInvalidFenceLineMessage(\n          filePath,\n          line,\n          `Failed to parse fence directive.`,\n        ),\n      );\n    }\n\n    // The first element of a RegEx match array is the input.\n    // Typecast: If there's a match, the expected elements must exist.\n    const [, terminus, command, parameters] = directiveMatches as [\n      string,\n      string,\n      string,\n      string,\n    ];\n\n    if (!isValidTerminus(terminus)) {\n      throw new Error(\n        getInvalidFenceLineMessage(\n          filePath,\n          line,\n          `Line contains invalid directive terminus \"${terminus}\".`,\n        ),\n      );\n    }\n\n    if (!isValidCommand(command)) {\n      throw new Error(\n        getInvalidFenceLineMessage(\n          filePath,\n          line,\n          `Line contains invalid directive command \"${command}\".`,\n        ),\n      );\n    }\n\n    if (terminus === DirectiveTerminus.BEGIN) {\n      if (!parameters) {\n        throw new Error(\n          getInvalidParamsMessage(filePath, `No parameters specified.`),\n        );\n      }\n\n      return {\n        command,\n        indices,\n        line,\n        parameters: parameters.split(','),\n        terminus,\n      };\n    }\n    return { command, indices, line, terminus };\n  });\n\n  if (parsedDirectives.length % 2 !== 0) {\n    throw new Error(\n      getInvalidFenceStructureMessage(\n        filePath,\n        `A valid fence consists of two fence lines, but the file contains an uneven number, \"${parsedDirectives.length}\", of fence lines.`,\n      ),\n    );\n  }\n\n  // The below for-loop iterates over the parsed fence directives and performs\n  // the following work:\n  // - Ensures that the array of parsed directives consists of valid directive\n  //   pairs, as specified in the documentation.\n  // - For each directive pair, determines whether their fenced lines should be\n  //   removed for the current build, and if so, stores the indices we will use\n  //   to splice the file content string.\n\n  const splicingIndices: number[] = [];\n  let shouldSplice = false;\n  let currentCommand: string;\n\n  parsedDirectives.forEach((directive, i) => {\n    const { line, indices, terminus, command } = directive;\n\n    if (i % 2 === 0) {\n      if (terminus !== DirectiveTerminus.BEGIN) {\n        throw new Error(\n          getInvalidFencePairMessage(\n            filePath,\n            line,\n            `The first directive of a pair must be a \"BEGIN\" directive.`,\n          ),\n        );\n      }\n\n      const { parameters } = directive;\n      currentCommand = command;\n      validateCommand(command, parameters, filePath, featureLabels);\n\n      const blockIsActive = parameters.some((param) =>\n        featureLabels.active.has(param),\n      );\n\n      if (blockIsActive) {\n        shouldSplice = false;\n      } else {\n        shouldSplice = true;\n\n        // Add start index of BEGIN directive line to splicing indices\n        splicingIndices.push(indices[0]);\n      }\n    } else {\n      if (terminus !== DirectiveTerminus.END) {\n        throw new Error(\n          getInvalidFencePairMessage(\n            filePath,\n            line,\n            `The second directive of a pair must be an \"END\" directive.`,\n          ),\n        );\n      }\n\n      /* istanbul ignore next: impossible until there's more than one command */\n      if (command !== currentCommand) {\n        throw new Error(\n          getInvalidFencePairMessage(\n            filePath,\n            line,\n            `Expected \"END\" directive to have command \"${currentCommand}\" but found \"${command}\".`,\n          ),\n        );\n      }\n\n      // Forbid empty fences\n      const { line: previousLine, indices: previousIndices } =\n        // We're only in this case if i > 0, so this will always be defined.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        parsedDirectives[i - 1]!;\n      if (fileContent.substring(previousIndices[1], indices[0]).trim() === '') {\n        throw new Error(\n          `Empty fence found in file \"${filePath}\":\\n${previousLine}\\n${line}\\n`,\n        );\n      }\n\n      if (shouldSplice) {\n        // Add end index of END directive line to splicing indices\n        splicingIndices.push(indices[1]);\n      }\n    }\n  });\n\n  // This indicates that the present build type should include all fenced code,\n  // and so we just returned the unmodified file contents.\n  if (splicingIndices.length === 0) {\n    return [fileContent, false];\n  }\n\n  /* istanbul ignore next: should be impossible */\n  if (splicingIndices.length % 2 !== 0) {\n    throw new Error(\n      `Internal error while transforming file \"${filePath}\":\\nCollected an uneven number of splicing indices: \"${splicingIndices.length}\"`,\n    );\n  }\n\n  return [multiSplice(fileContent, splicingIndices), true];\n}\n\n/**\n * Returns a copy of the given string, without the character ranges specified\n * by the splicing indices array.\n *\n * The splicing indices must be a non-empty, even-length array of non-negative\n * integers, specifying the character ranges to remove from the given string, as\n * follows:\n *\n * `[ start, end, start, end, start, end, ... ]`\n *\n * Throws if the array is not an even-length array of non-negative integers.\n *\n * @param toSplice - The string to splice.\n * @param splicingIndices - Indices to splice at.\n * @returns The spliced string.\n */\nexport function multiSplice(\n  toSplice: string,\n  splicingIndices: number[],\n): string {\n  if (splicingIndices.length === 0 || splicingIndices.length % 2 !== 0) {\n    throw new Error('Expected non-empty, even-length array.');\n  }\n  if (splicingIndices.some((index) => !Number.isInteger(index) || index < 0)) {\n    throw new Error('Expected array of non-negative integers.');\n  }\n\n  const retainedSubstrings = [];\n\n  // Get the first part to be included\n  // The substring() call returns an empty string if splicingIndices[0] is 0,\n  // which is exactly what we want in that case.\n  retainedSubstrings.push(toSplice.substring(0, splicingIndices[0]));\n\n  // This loop gets us all parts of the string that should be retained, except\n  // the first and the last.\n  // It iterates over all \"end\" indices of the array except the last one, and\n  // pushes the substring between each \"end\" index and the next \"begin\" index\n  // to the array of retained substrings.\n  if (splicingIndices.length > 2) {\n    // Note the boundary index of \"splicingIndices.length - 1\". This loop must\n    // not iterate over the last element of the array, which is handled outside\n    // of this loop.\n    for (let i = 1; i < splicingIndices.length - 1; i += 2) {\n      retainedSubstrings.push(\n        // splicingIndices[i] refers to an element between the first and last\n        // elements of the array, and will always be defined.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        toSplice.substring(splicingIndices[i]!, splicingIndices[i + 1]),\n      );\n    }\n  }\n\n  // Get the last part to be included\n  retainedSubstrings.push(\n    // The last element of a non-empty array will always be defined.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    toSplice.substring(splicingIndices[splicingIndices.length - 1]!),\n  );\n  return retainedSubstrings.join('');\n}\n\n/**\n * Gets an invalid fence line error message.\n *\n * @param filePath - The path to the file that caused the error.\n * @param line - The contents of the line with the error.\n * @param details - An explanation of the error.\n * @returns The error message.\n */\nfunction getInvalidFenceLineMessage(\n  filePath: string,\n  line: string,\n  details: string,\n) {\n  return `Invalid fence line in file \"${filePath}\": \"${line}\":\\n${details}`;\n}\n\n/**\n * Gets an invalid fence structure error message.\n *\n * @param filePath - The path to the file that caused the error.\n * @param details - An explanation of the error.\n * @returns The error message.\n */\nfunction getInvalidFenceStructureMessage(filePath: string, details: string) {\n  return `Invalid fence structure in file \"${filePath}\":\\n${details}`;\n}\n\n/**\n * Gets an invalid fence pair error message.\n *\n * @param filePath - The path to the file that caused the error.\n * @param line - The contents of the line with the error.\n * @param details - An explanation of the error.\n * @returns The error message.\n */\nfunction getInvalidFencePairMessage(\n  filePath: string,\n  line: string,\n  details: string,\n) {\n  return `Invalid fence pair in file \"${filePath}\" due to line \"${line}\":\\n${details}`;\n}\n\n/**\n * Gets an invalid command params error message.\n *\n * @param filePath - The path to the file that caused the error.\n * @param details - An explanation of the error.\n * @param command - The command of the directive with the invalid parameters, if known.\n * @returns The error message.\n */\nfunction getInvalidParamsMessage(\n  filePath: string,\n  details: string,\n  command?: string,\n) {\n  return `Invalid code fence parameters in file \"${filePath}\"${\n    command ? `for command \"${command}\"` : ''\n  }:\\n${details}`;\n}\n\n/**\n * Checks whether the given terminus string is valid, i.e. one of `BEGIN` or `END`.\n *\n * @param terminus - The terminus string to validate.\n * @returns Whether the string is a valid terminus string.\n */\nfunction isValidTerminus(terminus: string): terminus is DirectiveTerminus {\n  return hasProperty(DirectiveTerminus, terminus);\n}\n\n/**\n * Checks whether the given command string is valid.\n *\n * @param command - The command string to validate.\n * @returns Whether the string is a valid command string.\n */\nfunction isValidCommand(command: string): command is DirectiveCommand {\n  return hasProperty(DirectiveCommand, command);\n}\n\n/**\n * Validates the specified command. Throws if validation fails.\n *\n * @param command - The command to validate.\n * @param params - The parameters of the command.\n * @param filePath - The path of the current file.\n * @param featureLabels - The possible feature labels.\n */\nexport function validateCommand(\n  command: unknown,\n  params: string[],\n  filePath: string,\n  featureLabels: FeatureLabels,\n): asserts command is DirectiveCommand {\n  switch (command) {\n    case DirectiveCommand.ONLY_INCLUDE_IF:\n      if (!params || params.length === 0) {\n        throw new Error(\n          getInvalidParamsMessage(\n            filePath,\n            `No parameters specified.`,\n            DirectiveCommand.ONLY_INCLUDE_IF,\n          ),\n        );\n      }\n\n      for (const param of params) {\n        if (!featureLabels.all.has(param)) {\n          throw new Error(\n            getInvalidParamsMessage(\n              filePath,\n              `\"${param}\" is not a declared build feature.`,\n              DirectiveCommand.ONLY_INCLUDE_IF,\n            ),\n          );\n        }\n      }\n      break;\n\n    default:\n      throw new Error(`Unrecognized command \"${String(command)}\".`);\n  }\n}\n"]}