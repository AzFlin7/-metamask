"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DEFAULT_NPM_REGISTRY: function() {
        return DEFAULT_NPM_REGISTRY;
    },
    BaseNpmLocation: function() {
        return BaseNpmLocation;
    },
    TARBALL_SIZE_SAFETY_LIMIT: function() {
        return TARBALL_SIZE_SAFETY_LIMIT;
    },
    NpmLocation: function() {
        return NpmLocation;
    },
    fetchNpmMetadata: function() {
        return fetchNpmMetadata;
    },
    getNpmCanonicalBasePath: function() {
        return getNpmCanonicalBasePath;
    }
});
const _snapsutils = require("@metamask/snaps-utils");
const _utils = require("@metamask/utils");
const _browserifyzlib = require("browserify-zlib");
const _concatstream = /*#__PURE__*/ _interop_require_default(require("concat-stream"));
const _getnpmtarballurl = /*#__PURE__*/ _interop_require_default(require("get-npm-tarball-url"));
const _readablestream = require("readable-stream");
const _readablewebtonodestream = require("readable-web-to-node-stream");
const _tarstream = require("tar-stream");
function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
function _class_private_method_get(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
function _class_private_method_init(obj, privateSet) {
    _check_private_redeclaration(obj, privateSet);
    privateSet.add(obj);
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const DEFAULT_NPM_REGISTRY = new URL('https://registry.npmjs.org');
var _validatedManifest = /*#__PURE__*/ new WeakMap(), _files = /*#__PURE__*/ new WeakMap(), _lazyInit = /*#__PURE__*/ new WeakSet();
class BaseNpmLocation {
    async manifest() {
        if (_class_private_field_get(this, _validatedManifest)) {
            return _class_private_field_get(this, _validatedManifest).clone();
        }
        const vfile = await this.fetch('snap.manifest.json');
        const result = (0, _snapsutils.parseJson)(vfile.toString());
        vfile.result = (0, _snapsutils.createSnapManifest)(result);
        _class_private_field_set(this, _validatedManifest, vfile);
        return this.manifest();
    }
    async fetch(path) {
        const relativePath = (0, _snapsutils.normalizeRelative)(path);
        if (!_class_private_field_get(this, _files)) {
            await _class_private_method_get(this, _lazyInit, lazyInit).call(this);
            (0, _utils.assert)(_class_private_field_get(this, _files) !== undefined);
        }
        const vfile = _class_private_field_get(this, _files).get(relativePath);
        (0, _utils.assert)(vfile !== undefined, new TypeError(`File "${path}" not found in package.`));
        return vfile.clone();
    }
    get packageName() {
        return this.meta.packageName;
    }
    get version() {
        (0, _utils.assert)(this.meta.version !== undefined, 'Tried to access version without first fetching NPM package.');
        return this.meta.version;
    }
    get registry() {
        return this.meta.registry;
    }
    get versionRange() {
        return this.meta.requestedRange;
    }
    constructor(url, opts = {}){
        _class_private_method_init(this, _lazyInit);
        _define_property(this, "meta", void 0);
        _class_private_field_init(this, _validatedManifest, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _files, {
            writable: true,
            value: void 0
        });
        const allowCustomRegistries = opts.allowCustomRegistries ?? false;
        const fetchFunction = opts.fetch ?? globalThis.fetch.bind(globalThis);
        const requestedRange = opts.versionRange ?? _snapsutils.DEFAULT_REQUESTED_SNAP_VERSION;
        const defaultResolve = async (range)=>range;
        const resolveVersion = opts.resolveVersion ?? defaultResolve;
        (0, _utils.assertStruct)(url.toString(), _snapsutils.NpmSnapIdStruct, 'Invalid Snap Id: ');
        let registry;
        if (url.host === '' && url.port === '' && url.username === '' && url.password === '') {
            registry = DEFAULT_NPM_REGISTRY;
        } else {
            registry = 'https://';
            if (url.username) {
                registry += url.username;
                if (url.password) {
                    registry += `:${url.password}`;
                }
                registry += '@';
            }
            registry += url.host;
            registry = new URL(registry);
            (0, _utils.assert)(allowCustomRegistries, new TypeError(`Custom NPM registries are disabled, tried to use "${registry.toString()}".`));
        }
        (0, _utils.assert)(registry.pathname === '/' && registry.search === '' && registry.hash === '');
        (0, _utils.assert)(url.pathname !== '' && url.pathname !== '/', new TypeError('The package name in NPM location is empty.'));
        let packageName = url.pathname;
        if (packageName.startsWith('/')) {
            packageName = packageName.slice(1);
        }
        this.meta = {
            requestedRange,
            registry,
            packageName,
            fetch: fetchFunction,
            resolveVersion
        };
    }
}
async function lazyInit() {
    (0, _utils.assert)(_class_private_field_get(this, _files) === undefined);
    const resolvedVersion = await this.meta.resolveVersion(this.meta.requestedRange);
    const { tarballURL, targetVersion } = await resolveNpmVersion(this.meta.packageName, resolvedVersion, this.meta.registry, this.meta.fetch);
    if (!(0, _snapsutils.isValidUrl)(tarballURL) || !tarballURL.toString().endsWith('.tgz')) {
        throw new Error(`Failed to find valid tarball URL in NPM metadata for package "${this.meta.packageName}".`);
    }
    // Override the tarball hostname/protocol with registryUrl hostname/protocol
    const newTarballUrl = new URL(tarballURL);
    newTarballUrl.hostname = this.meta.registry.hostname;
    newTarballUrl.protocol = this.meta.registry.protocol;
    const files = await this.fetchNpmTarball(newTarballUrl);
    _class_private_field_set(this, _files, files);
    this.meta.version = targetVersion;
}
const TARBALL_SIZE_SAFETY_LIMIT = 262144000;
class NpmLocation extends BaseNpmLocation {
    /**
   * Fetches and unpacks the tarball (`.tgz` file) from the specified URL.
   *
   * @param tarballUrl - The tarball URL to fetch and unpack.
   * @returns A the files for the package tarball.
   * @throws If fetching the tarball fails.
   */ async fetchNpmTarball(tarballUrl) {
        // Perform a raw fetch because we want the Response object itself.
        const tarballResponse = await this.meta.fetch(tarballUrl.toString());
        if (!tarballResponse.ok || !tarballResponse.body) {
            throw new Error(`Failed to fetch tarball for package "${this.meta.packageName}".`);
        }
        // We assume that NPM is a good actor and provides us with a valid `content-length` header.
        const tarballSizeString = tarballResponse.headers.get('content-length');
        (0, _utils.assert)(tarballSizeString, 'Snap tarball has invalid content-length');
        const tarballSize = parseInt(tarballSizeString, 10);
        (0, _utils.assert)(tarballSize <= TARBALL_SIZE_SAFETY_LIMIT, 'Snap tarball exceeds size limit');
        return new Promise((resolve, reject)=>{
            const files = new Map();
            // The "gz" in "tgz" stands for "gzip". The tarball needs to be decompressed
            // before we can actually grab any files from it.
            // To prevent recursion-based zip bombs, we should not allow recursion here.
            (0, _readablestream.pipeline)(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            getNodeStream(tarballResponse.body), (0, _browserifyzlib.createGunzip)(), createTarballStream(getNpmCanonicalBasePath(this.meta.registry, this.meta.packageName), files), (error)=>{
                error ? reject(error) : resolve(files);
            });
        });
    }
}
async function fetchNpmMetadata(packageName, registryUrl, fetchFunction) {
    const packageResponse = await fetchFunction(new URL(packageName, registryUrl).toString(), {
        headers: {
            // Corgi format is slightly smaller: https://github.com/npm/pacote/blob/main/lib/registry.js#L71
            accept: isNPM(registryUrl) ? 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*' : 'application/json'
        }
    });
    if (!packageResponse.ok) {
        throw new Error(`Failed to fetch NPM registry entry. Status code: ${packageResponse.status}.`);
    }
    const packageMetadata = await packageResponse.json();
    if (!(0, _utils.isObject)(packageMetadata)) {
        throw new Error(`Failed to fetch package "${packageName}" metadata from npm.`);
    }
    return packageMetadata;
}
function getNpmCanonicalBasePath(registryUrl, packageName) {
    let canonicalBase = 'npm://';
    if (registryUrl.username !== '') {
        canonicalBase += registryUrl.username;
        if (registryUrl.password !== '') {
            canonicalBase += `:${registryUrl.password}`;
        }
        canonicalBase += '@';
    }
    return `${canonicalBase}${registryUrl.host}/${packageName}/`;
}
/**
 * Determine if a registry URL is NPM.
 *
 * @param registryUrl - A registry url.
 * @returns True if the registry is the NPM registry, otherwise false.
 */ function isNPM(registryUrl) {
    return registryUrl.toString() === DEFAULT_NPM_REGISTRY.toString();
}
/**
 * Resolves a version range to a version using the NPM registry.
 *
 * Unless the version range is already a version, then the NPM registry is skipped.
 *
 * @param packageName - The name of the package whose metadata to fetch.
 * @param versionRange - The version range of the package.
 * @param registryUrl - The URL of the npm registry to fetch the metadata from.
 * @param fetchFunction - The fetch function to use. Defaults to the global
 * {@link fetch}. Useful for Node.js compatibility.
 * @returns An object containing the resolved version and a URL for its tarball.
 * @throws If fetching the metadata fails.
 */ async function resolveNpmVersion(packageName, versionRange, registryUrl, fetchFunction) {
    // If the version range is already a static version we don't need to look for the metadata.
    if (isNPM(registryUrl) && (0, _utils.isValidSemVerVersion)(versionRange)) {
        return {
            tarballURL: (0, _getnpmtarballurl.default)(packageName, versionRange),
            targetVersion: versionRange
        };
    }
    const packageMetadata = await fetchNpmMetadata(packageName, registryUrl, fetchFunction);
    const versions = Object.keys(packageMetadata?.versions ?? {}).map((version)=>{
        (0, _utils.assertIsSemVerVersion)(version);
        return version;
    });
    const targetVersion = (0, _snapsutils.getTargetVersion)(versions, versionRange);
    if (targetVersion === null) {
        throw new Error(`Failed to find a matching version in npm metadata for package "${packageName}" and requested semver range "${versionRange}".`);
    }
    const tarballURL = packageMetadata?.versions?.[targetVersion]?.dist?.tarball;
    return {
        tarballURL,
        targetVersion
    };
}
/**
 * The paths of files within npm tarballs appear to always be prefixed with
 * "package/".
 */ const NPM_TARBALL_PATH_PREFIX = /^package\//u;
/**
 * Converts a {@link ReadableStream} to a Node.js {@link Readable}
 * stream. Returns the stream directly if it is already a Node.js stream.
 * We can't use the native Web {@link ReadableStream} directly because the
 * other stream libraries we use expect Node.js streams.
 *
 * @param stream - The stream to convert.
 * @returns The given stream as a Node.js Readable stream.
 */ function getNodeStream(stream) {
    if (typeof stream.getReader !== 'function') {
        return stream;
    }
    return new _readablewebtonodestream.ReadableWebToNodeStream(stream);
}
/**
 * Creates a `tar-stream` that will get the necessary files from an npm Snap
 * package tarball (`.tgz` file).
 *
 * @param canonicalBase - A base URI as specified in {@link https://github.com/MetaMask/SIPs/blob/main/SIPS/sip-8.md SIP-8}. Starting with 'npm:'. Will be used for canonicalPath vfile argument.
 * @param files - An object to write target file contents to.
 * @returns The {@link Writable} tarball extraction stream.
 */ function createTarballStream(canonicalBase, files) {
    (0, _utils.assert)(canonicalBase.endsWith('/'), "Base needs to end with '/' for relative paths to be added as children instead of siblings.");
    (0, _utils.assert)(canonicalBase.startsWith('npm:'), 'Protocol mismatch, expected "npm:".');
    // `tar-stream` is pretty old-school, so we create it first and then
    // instrument it by adding event listeners.
    const extractStream = (0, _tarstream.extract)();
    let totalSize = 0;
    // "entry" is fired for every discreet entity in the tarball. This includes
    // files and folders.
    extractStream.on('entry', (header, entryStream, next)=>{
        const { name: headerName, type: headerType } = header;
        if (headerType === 'file') {
            // The name is a path if the header type is "file".
            const path = headerName.replace(NPM_TARBALL_PATH_PREFIX, '');
            return entryStream.pipe((0, _concatstream.default)({
                encoding: 'uint8array'
            }, (data)=>{
                try {
                    totalSize += data.byteLength;
                    // To prevent zip bombs, we set a safety limit for the total size of tarballs.
                    (0, _utils.assert)(totalSize < TARBALL_SIZE_SAFETY_LIMIT, `Snap tarball exceeds limit of ${TARBALL_SIZE_SAFETY_LIMIT} bytes.`);
                    const vfile = new _snapsutils.VirtualFile({
                        value: data,
                        path,
                        data: {
                            canonicalPath: new URL(path, canonicalBase).toString()
                        }
                    });
                    // We disallow files having identical paths as it may confuse our checksum calculations.
                    (0, _utils.assert)(!files.has(path), 'Malformed tarball, multiple files with the same path.');
                    files.set(path, vfile);
                    return next();
                } catch (error) {
                    return extractStream.destroy(error);
                }
            }));
        }
        // If we get here, the entry is not a file, and we want to ignore. The entry
        // stream must be drained, or the extractStream will stop reading. This is
        // effectively a no-op for the current entry.
        entryStream.on('end', ()=>next());
        return entryStream.resume();
    });
    return extractStream;
}

//# sourceMappingURL=npm.js.map