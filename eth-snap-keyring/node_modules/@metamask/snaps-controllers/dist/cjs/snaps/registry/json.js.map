{"version":3,"sources":["../../../../src/snaps/registry/json.ts"],"sourcesContent":["import type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { SnapsRegistryDatabase } from '@metamask/snaps-registry';\nimport { verify } from '@metamask/snaps-registry';\nimport { getTargetVersion } from '@metamask/snaps-utils';\nimport type { Hex, SemVerRange, SemVerVersion } from '@metamask/utils';\nimport {\n  assert,\n  assertIsSemVerRange,\n  Duration,\n  inMilliseconds,\n  satisfiesVersionRange,\n} from '@metamask/utils';\n\nimport type {\n  SnapsRegistry,\n  SnapsRegistryInfo,\n  SnapsRegistryMetadata,\n  SnapsRegistryRequest,\n  SnapsRegistryResult,\n} from './registry';\nimport { SnapsRegistryStatus } from './registry';\n\n// TODO: Replace with a Codefi URL\nconst SNAP_REGISTRY_URL =\n  'https://cdn.jsdelivr.net/gh/MetaMask/snaps-registry@gh-pages/latest/registry.json';\n\nconst SNAP_REGISTRY_SIGNATURE_URL =\n  'https://cdn.jsdelivr.net/gh/MetaMask/snaps-registry@gh-pages/latest/signature.json';\n\ntype JsonSnapsRegistryUrl = {\n  registry: string;\n  signature: string;\n};\n\nexport type JsonSnapsRegistryArgs = {\n  messenger: SnapsRegistryMessenger;\n  state?: SnapsRegistryState;\n  fetchFunction?: typeof fetch;\n  url?: JsonSnapsRegistryUrl;\n  recentFetchThreshold?: number;\n  refetchOnAllowlistMiss?: boolean;\n  failOnUnavailableRegistry?: boolean;\n  publicKey?: Hex;\n};\n\nexport type GetResult = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapsRegistry['get'];\n};\n\nexport type ResolveVersion = {\n  type: `${typeof controllerName}:resolveVersion`;\n  handler: SnapsRegistry['resolveVersion'];\n};\n\nexport type GetMetadata = {\n  type: `${typeof controllerName}:getMetadata`;\n  handler: SnapsRegistry['getMetadata'];\n};\n\nexport type Update = {\n  type: `${typeof controllerName}:update`;\n  handler: SnapsRegistry['update'];\n};\n\nexport type SnapsRegistryActions =\n  | GetResult\n  | GetMetadata\n  | Update\n  | ResolveVersion;\n\nexport type SnapsRegistryEvents = never;\n\nexport type SnapsRegistryMessenger = RestrictedControllerMessenger<\n  'SnapsRegistry',\n  SnapsRegistryActions,\n  SnapsRegistryEvents,\n  SnapsRegistryActions['type'],\n  SnapsRegistryEvents['type']\n>;\n\nexport type SnapsRegistryState = {\n  database: SnapsRegistryDatabase | null;\n  lastUpdated: number | null;\n};\n\nconst controllerName = 'SnapsRegistry';\n\nconst defaultState = {\n  database: null,\n  lastUpdated: null,\n};\n\nexport class JsonSnapsRegistry extends BaseController<\n  typeof controllerName,\n  SnapsRegistryState,\n  SnapsRegistryMessenger\n> {\n  #url: JsonSnapsRegistryUrl;\n\n  #publicKey?: Hex;\n\n  #fetchFunction: typeof fetch;\n\n  #recentFetchThreshold: number;\n\n  #refetchOnAllowlistMiss: boolean;\n\n  #failOnUnavailableRegistry: boolean;\n\n  #currentUpdate: Promise<void> | null;\n\n  constructor({\n    messenger,\n    state,\n    url = {\n      registry: SNAP_REGISTRY_URL,\n      signature: SNAP_REGISTRY_SIGNATURE_URL,\n    },\n    publicKey,\n    fetchFunction = globalThis.fetch.bind(globalThis),\n    recentFetchThreshold = inMilliseconds(5, Duration.Minute),\n    failOnUnavailableRegistry = true,\n    refetchOnAllowlistMiss = true,\n  }: JsonSnapsRegistryArgs) {\n    super({\n      messenger,\n      metadata: {\n        database: { persist: true, anonymous: false },\n        lastUpdated: { persist: true, anonymous: false },\n      },\n      name: controllerName,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n    this.#url = url;\n    this.#publicKey = publicKey;\n    this.#fetchFunction = fetchFunction;\n    this.#recentFetchThreshold = recentFetchThreshold;\n    this.#refetchOnAllowlistMiss = refetchOnAllowlistMiss;\n    this.#failOnUnavailableRegistry = failOnUnavailableRegistry;\n    this.#currentUpdate = null;\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:get',\n      async (...args) => this.#get(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:getMetadata',\n      async (...args) => this.#getMetadata(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:resolveVersion',\n      async (...args) => this.#resolveVersion(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:update',\n      async () => this.#triggerUpdate(),\n    );\n  }\n\n  #wasRecentlyFetched() {\n    return (\n      this.state.lastUpdated &&\n      Date.now() - this.state.lastUpdated < this.#recentFetchThreshold\n    );\n  }\n\n  /**\n   * Triggers an update of the registry database.\n   *\n   * If an existing update is in progress this function will await that update.\n   */\n  async #triggerUpdate() {\n    // If an update is ongoing, wait for that.\n    if (this.#currentUpdate) {\n      await this.#currentUpdate;\n      return;\n    }\n    // If no update exists, create promise and store globally.\n    if (this.#currentUpdate === null) {\n      this.#currentUpdate = this.#update();\n    }\n    await this.#currentUpdate;\n    this.#currentUpdate = null;\n  }\n\n  /**\n   * Updates the registry database if the registry hasn't been updated recently.\n   *\n   * NOTE: SHOULD NOT be called directly, instead `triggerUpdate` should be used.\n   */\n  async #update() {\n    // No-op if we recently fetched the registry.\n    if (this.#wasRecentlyFetched()) {\n      return;\n    }\n\n    try {\n      const database = await this.#safeFetch(this.#url.registry);\n\n      if (this.#publicKey) {\n        const signature = await this.#safeFetch(this.#url.signature);\n        this.#verifySignature(database, signature);\n      }\n\n      this.update((state) => {\n        state.database = JSON.parse(database);\n        state.lastUpdated = Date.now();\n      });\n    } catch {\n      // Ignore\n    }\n  }\n\n  async #getDatabase(): Promise<SnapsRegistryDatabase | null> {\n    if (this.state.database === null) {\n      await this.#triggerUpdate();\n    }\n\n    // If the database is still null and we require it, throw.\n    if (this.#failOnUnavailableRegistry && this.state.database === null) {\n      throw new Error('Snaps registry is unavailable, installation blocked.');\n    }\n    return this.state.database;\n  }\n\n  async #getSingle(\n    snapId: string,\n    snapInfo: SnapsRegistryInfo,\n    refetch = false,\n  ): Promise<SnapsRegistryResult> {\n    const database = await this.#getDatabase();\n\n    const blockedEntry = database?.blockedSnaps.find((blocked) => {\n      if ('id' in blocked) {\n        return (\n          blocked.id === snapId &&\n          satisfiesVersionRange(snapInfo.version, blocked.versionRange)\n        );\n      }\n\n      return blocked.checksum === snapInfo.checksum;\n    });\n\n    if (blockedEntry) {\n      return {\n        status: SnapsRegistryStatus.Blocked,\n        reason: blockedEntry.reason,\n      };\n    }\n\n    const verified = database?.verifiedSnaps[snapId];\n    const version = verified?.versions?.[snapInfo.version];\n    if (version && version.checksum === snapInfo.checksum) {\n      return { status: SnapsRegistryStatus.Verified };\n    }\n    // For now, if we have an allowlist miss, we can refetch once and try again.\n    if (this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#getSingle(snapId, snapInfo, true);\n    }\n    return { status: SnapsRegistryStatus.Unverified };\n  }\n\n  async #get(\n    snaps: SnapsRegistryRequest,\n  ): Promise<Record<string, SnapsRegistryResult>> {\n    return Object.entries(snaps).reduce<\n      Promise<Record<string, SnapsRegistryResult>>\n    >(async (previousPromise, [snapId, snapInfo]) => {\n      const result = await this.#getSingle(snapId, snapInfo);\n      const acc = await previousPromise;\n      acc[snapId] = result;\n      return acc;\n    }, Promise.resolve({}));\n  }\n\n  /**\n   * Find an allowlisted version within a specified version range.\n   *\n   * @param snapId - The ID of the snap we are trying to resolve a version for.\n   * @param versionRange - The version range.\n   * @param refetch - An optional flag used to determine if we are refetching the registry.\n   * @returns An allowlisted version within the specified version range.\n   * @throws If an allowlisted version does not exist within the version range.\n   */\n  async #resolveVersion(\n    snapId: string,\n    versionRange: SemVerRange,\n    refetch = false,\n  ): Promise<SemVerRange> {\n    const database = await this.#getDatabase();\n    const versions = database?.verifiedSnaps[snapId]?.versions ?? null;\n\n    if (!versions && this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#resolveVersion(snapId, versionRange, true);\n    }\n\n    assert(versions, 'The snap is not on the allowlist');\n\n    const targetVersion = getTargetVersion(\n      Object.keys(versions) as SemVerVersion[],\n      versionRange,\n    );\n\n    if (!targetVersion && this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#resolveVersion(snapId, versionRange, true);\n    }\n\n    assert(\n      targetVersion,\n      'No matching versions of the snap are on the allowlist',\n    );\n\n    // A semver version is technically also a valid semver range.\n    assertIsSemVerRange(targetVersion);\n    return targetVersion;\n  }\n\n  /**\n   * Get metadata for the given snap ID.\n   *\n   * @param snapId - The ID of the snap to get metadata for.\n   * @returns The metadata for the given snap ID, or `null` if the snap is not\n   * verified.\n   */\n  async #getMetadata(snapId: string): Promise<SnapsRegistryMetadata | null> {\n    const database = await this.#getDatabase();\n    return database?.verifiedSnaps[snapId]?.metadata ?? null;\n  }\n\n  /**\n   * Verify the signature of the registry.\n   *\n   * @param database - The registry database.\n   * @param signature - The signature of the registry.\n   * @throws If the signature is invalid.\n   * @private\n   */\n  #verifySignature(database: string, signature: string) {\n    assert(this.#publicKey, 'No public key provided.');\n\n    const valid = verify({\n      registry: database,\n      signature: JSON.parse(signature),\n      publicKey: this.#publicKey,\n    });\n\n    assert(valid, 'Invalid registry signature.');\n  }\n\n  /**\n   * Fetch the given URL, throwing if the response is not OK.\n   *\n   * @param url - The URL to fetch.\n   * @returns The response body.\n   * @private\n   */\n  async #safeFetch(url: string) {\n    const response = await this.#fetchFunction(url);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${url}.`);\n    }\n\n    return await response.text();\n  }\n}\n"],"names":["JsonSnapsRegistry","SNAP_REGISTRY_URL","SNAP_REGISTRY_SIGNATURE_URL","controllerName","defaultState","database","lastUpdated","BaseController","constructor","messenger","state","url","registry","signature","publicKey","fetchFunction","globalThis","fetch","bind","recentFetchThreshold","inMilliseconds","Duration","Minute","failOnUnavailableRegistry","refetchOnAllowlistMiss","metadata","persist","anonymous","name","currentUpdate","messagingSystem","registerActionHandler","args","get","getMetadata","resolveVersion","triggerUpdate","Date","now","update","wasRecentlyFetched","safeFetch","verifySignature","JSON","parse","Error","snapId","snapInfo","refetch","getDatabase","blockedEntry","blockedSnaps","find","blocked","id","satisfiesVersionRange","version","versionRange","checksum","status","SnapsRegistryStatus","Blocked","reason","verified","verifiedSnaps","versions","Verified","getSingle","Unverified","snaps","Object","entries","reduce","previousPromise","result","acc","Promise","resolve","assert","targetVersion","getTargetVersion","keys","assertIsSemVerRange","valid","verify","response","ok","text"],"mappings":"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"}