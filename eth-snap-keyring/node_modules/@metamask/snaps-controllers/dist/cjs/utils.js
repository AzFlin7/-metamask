"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    setDiff: function() {
        return setDiff;
    },
    delay: function() {
        return delay;
    },
    delayWithTimer: function() {
        return delayWithTimer;
    },
    hasTimedOut: function() {
        return hasTimedOut;
    },
    withTimeout: function() {
        return withTimeout;
    },
    getSnapFiles: function() {
        return getSnapFiles;
    },
    fetchSnap: function() {
        return fetchSnap;
    }
});
const _snapssdk = require("@metamask/snaps-sdk");
const _snapsutils = require("@metamask/snaps-utils");
const _Timer = require("./snaps/Timer");
function setDiff(objectA, objectB) {
    return Object.entries(objectA).reduce((acc, [key, value])=>{
        if (!(key in objectB)) {
            acc[key] = value;
        }
        return acc;
    }, {});
}
function delay(ms, result) {
    return delayWithTimer(new _Timer.Timer(ms), result);
}
function delayWithTimer(timer, result) {
    let rejectFunc;
    const promise = new Promise((resolve, reject)=>{
        timer.start(()=>{
            result === undefined ? resolve() : resolve(result);
        });
        rejectFunc = reject;
    });
    promise.cancel = ()=>{
        if (timer.status !== 'finished') {
            timer.cancel();
            rejectFunc(new Error('The delay has been canceled.'));
        }
    };
    return promise;
}
const hasTimedOut = Symbol('Used to check if the requested promise has timeout (see withTimeout)');
async function withTimeout(promise, timerOrMs) {
    const timer = typeof timerOrMs === 'number' ? new _Timer.Timer(timerOrMs) : timerOrMs;
    const delayPromise = delayWithTimer(timer, hasTimedOut);
    try {
        return await Promise.race([
            promise,
            delayPromise
        ]);
    } finally{
        delayPromise.cancel();
    }
}
async function getSnapFiles(location, files) {
    if (!files || files.length === 0) {
        return [];
    }
    return await Promise.all(files.map(async (filePath)=>location.fetch(filePath)));
}
async function fetchSnap(snapId, location) {
    try {
        const manifest = await location.manifest();
        const sourceCode = await location.fetch(manifest.result.source.location.npm.filePath);
        const { iconPath } = manifest.result.source.location.npm;
        const svgIcon = iconPath ? await location.fetch(iconPath) : undefined;
        const auxiliaryFiles = await getSnapFiles(location, manifest.result.source.files);
        await Promise.all(auxiliaryFiles.map(async (file)=>{
            // This should still be safe
            // eslint-disable-next-line require-atomic-updates
            file.data.base64 = await (0, _snapsutils.encodeBase64)(file);
        }));
        const localizationFiles = await getSnapFiles(location, manifest.result.source.locales);
        const validatedLocalizationFiles = (0, _snapsutils.getValidatedLocalizationFiles)(localizationFiles);
        const files = {
            manifest,
            sourceCode,
            svgIcon,
            auxiliaryFiles,
            localizationFiles: validatedLocalizationFiles
        };
        await (0, _snapsutils.validateFetchedSnap)(files);
        return files;
    } catch (error) {
        throw new Error(`Failed to fetch snap "${snapId}": ${(0, _snapssdk.getErrorMessage)(error)}.`);
    }
}

//# sourceMappingURL=utils.js.map