{"version":3,"sources":["../../../src/snaps/SnapController.ts"],"sourcesContent":["import type {\n  AddApprovalRequest,\n  UpdateRequestState,\n} from '@metamask/approval-controller';\nimport type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type {\n  Caveat,\n  GetEndowments,\n  GetPermissions,\n  GetSubjectMetadata,\n  AddSubjectMetadata,\n  GetSubjects,\n  GrantPermissions,\n  HasPermission,\n  HasPermissions,\n  PermissionConstraint,\n  PermissionsRequest,\n  RequestedPermissions,\n  RevokeAllPermissions,\n  RevokePermissionForAllSubjects,\n  RevokePermissions,\n  SubjectPermissions,\n  UpdateCaveat,\n  ValidPermission,\n} from '@metamask/permission-controller';\nimport { SubjectType } from '@metamask/permission-controller';\nimport type {\n  MaybeUpdateState,\n  TestOrigin,\n} from '@metamask/phishing-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { BlockReason } from '@metamask/snaps-registry';\nimport { WALLET_SNAP_PERMISSION_KEY } from '@metamask/snaps-rpc-methods';\nimport type {\n  RequestSnapsParams,\n  RequestSnapsResult,\n  SnapId,\n} from '@metamask/snaps-sdk';\nimport { AuxiliaryFileEncoding, getErrorMessage } from '@metamask/snaps-sdk';\nimport type {\n  FetchedSnapFiles,\n  InitialConnections,\n  PersistedSnap,\n  Snap,\n  SnapManifest,\n  SnapRpcHook,\n  SnapRpcHookArgs,\n  StatusContext,\n  StatusEvents,\n  StatusStates,\n  TruncatedSnap,\n  TruncatedSnapFields,\n} from '@metamask/snaps-utils';\nimport {\n  validateComponentLinks,\n  assertIsSnapManifest,\n  assertIsValidSnapId,\n  DEFAULT_ENDOWMENTS,\n  DEFAULT_REQUESTED_SNAP_VERSION,\n  encodeAuxiliaryFile,\n  HandlerType,\n  isOriginAllowed,\n  logError,\n  normalizeRelative,\n  OnTransactionResponseStruct,\n  OnSignatureResponseStruct,\n  resolveVersionRange,\n  SnapCaveatType,\n  SnapStatus,\n  SnapStatusEvents,\n  unwrapError,\n  OnHomePageResponseStruct,\n  getValidatedLocalizationFiles,\n  VirtualFile,\n  NpmSnapFileNames,\n} from '@metamask/snaps-utils';\nimport type { Json, NonEmptyArray, SemVerRange } from '@metamask/utils';\nimport {\n  assert,\n  assertIsJsonRpcRequest,\n  assertStruct,\n  Duration,\n  gtRange,\n  gtVersion,\n  hasProperty,\n  inMilliseconds,\n  isNonEmptyArray,\n  isValidSemVerRange,\n  satisfiesVersionRange,\n  timeSince,\n} from '@metamask/utils';\nimport type { StateMachine } from '@xstate/fsm';\nimport { createMachine, interpret } from '@xstate/fsm';\nimport type { Patch } from 'immer';\nimport { nanoid } from 'nanoid';\n\nimport { forceStrict, validateMachine } from '../fsm';\nimport { log } from '../logging';\nimport type {\n  ExecuteSnapAction,\n  ExecutionServiceEvents,\n  HandleRpcRequestAction,\n  SnapErrorJson,\n  TerminateAllSnapsAction,\n  TerminateSnapAction,\n} from '../services';\nimport { fetchSnap, hasTimedOut, setDiff, withTimeout } from '../utils';\nimport { handlerEndowments, SnapEndowments } from './endowments';\nimport { getKeyringCaveatOrigins } from './endowments/keyring';\nimport { getRpcCaveatOrigins } from './endowments/rpc';\nimport type { SnapLocation } from './location';\nimport { detectSnapLocation } from './location';\nimport { processSnapPermissions } from './permissions';\nimport type {\n  GetMetadata,\n  GetResult,\n  ResolveVersion,\n  SnapsRegistryInfo,\n  SnapsRegistryMetadata,\n  SnapsRegistryRequest,\n  Update,\n} from './registry';\nimport { SnapsRegistryStatus } from './registry';\nimport { RequestQueue } from './RequestQueue';\nimport { Timer } from './Timer';\n\nexport const controllerName = 'SnapController';\n\n// TODO: Figure out how to name these\nexport const SNAP_APPROVAL_INSTALL = 'wallet_installSnap';\nexport const SNAP_APPROVAL_UPDATE = 'wallet_updateSnap';\nexport const SNAP_APPROVAL_RESULT = 'wallet_installSnapResult';\n\nconst TRUNCATED_SNAP_PROPERTIES = new Set<TruncatedSnapFields>([\n  'initialPermissions',\n  'id',\n  'version',\n  'enabled',\n  'blocked',\n]);\n\nexport type PendingRequest = {\n  requestId: unknown;\n  timer: Timer;\n};\n\nexport interface PreinstalledSnapFile {\n  path: string;\n  value: string | Uint8Array;\n}\n\nexport interface PreinstalledSnap {\n  snapId: SnapId;\n  manifest: SnapManifest;\n  files: PreinstalledSnapFile[];\n  removable?: boolean;\n}\n\n/**\n * A wrapper type for any data stored during runtime of Snaps.\n * It is not persisted in state as it contains non-serializable data and is only relevant for the\n * current session.\n */\nexport interface SnapRuntimeData {\n  /**\n   * A promise that resolves when the Snap has finished installing\n   */\n  installPromise: null | Promise<PersistedSnap>;\n\n  /**\n   * A Unix timestamp for the last time the Snap received an RPC request\n   */\n  lastRequest: null | number;\n\n  /**\n   * The current number of active references where this Snap is being used\n   */\n  activeReferences: number;\n\n  /**\n   * The current pending inbound requests, meaning requests that are processed by snaps.\n   */\n  pendingInboundRequests: PendingRequest[];\n\n  /**\n   * The current pending outbound requests, meaning requests made from snaps towards the MetaMask\n   * extension.\n   */\n  pendingOutboundRequests: number;\n\n  /**\n   * RPC handler designated for the Snap\n   */\n  rpcHandler: null | SnapRpcHook;\n\n  /**\n   * The finite state machine interpreter for possible states that the Snap can be in such as\n   * stopped, running, blocked\n   *\n   * @see {@link SnapController:constructor}\n   */\n  interpreter: StateMachine.Service<StatusContext, StatusEvents, StatusStates>;\n}\n\nexport type SnapError = {\n  message: string;\n  code: number;\n  data?: Json;\n};\n\n// Types that probably should be defined elsewhere in prod\ntype CloseAllConnectionsFunction = (origin: string) => void;\ntype StoredSnaps = Record<SnapId, Snap>;\n\nexport type SnapControllerState = {\n  snaps: StoredSnaps;\n  snapStates: Record<SnapId, string | null>;\n  unencryptedSnapStates: Record<SnapId, string | null>;\n};\n\nexport type PersistedSnapControllerState = SnapControllerState & {\n  snaps: Record<SnapId, PersistedSnap>;\n  snapStates: Record<SnapId, string>;\n};\n\ntype RollbackSnapshot = {\n  statePatches: Patch[];\n  permissions: {\n    revoked?: SubjectPermissions<ValidPermission<string, Caveat<string, any>>>;\n    granted?: RequestedPermissions;\n    requestData?: Record<string, unknown>;\n  };\n  newVersion: string;\n};\n\ntype PendingApproval = {\n  id: string;\n  promise: Promise<unknown>;\n};\n\n// Controller Messenger Actions\n\n/**\n * Gets the specified Snap from state.\n */\nexport type GetSnap = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapController['get'];\n};\n\n/**\n * Handles sending an inbound request to a snap and returns its result.\n */\nexport type HandleSnapRequest = {\n  type: `${typeof controllerName}:handleRequest`;\n  handler: SnapController['handleRequest'];\n};\n\n/**\n * Gets the specified Snap's persisted state.\n */\nexport type GetSnapState = {\n  type: `${typeof controllerName}:getSnapState`;\n  handler: SnapController['getSnapState'];\n};\n\n/**\n * Checks if the specified snap exists in state.\n */\nexport type HasSnap = {\n  type: `${typeof controllerName}:has`;\n  handler: SnapController['has'];\n};\n\n/**\n * Updates the specified Snap's persisted state.\n */\nexport type UpdateSnapState = {\n  type: `${typeof controllerName}:updateSnapState`;\n  handler: SnapController['updateSnapState'];\n};\n\n/**\n * Clears the specified Snap's persisted state.\n */\nexport type ClearSnapState = {\n  type: `${typeof controllerName}:clearSnapState`;\n  handler: SnapController['clearSnapState'];\n};\n\n/**\n * Checks all installed snaps against the blocklist.\n */\nexport type UpdateBlockedSnaps = {\n  type: `${typeof controllerName}:updateBlockedSnaps`;\n  handler: SnapController['updateBlockedSnaps'];\n};\n\nexport type EnableSnap = {\n  type: `${typeof controllerName}:enable`;\n  handler: SnapController['enableSnap'];\n};\n\nexport type DisableSnap = {\n  type: `${typeof controllerName}:disable`;\n  handler: SnapController['disableSnap'];\n};\n\nexport type RemoveSnap = {\n  type: `${typeof controllerName}:remove`;\n  handler: SnapController['removeSnap'];\n};\n\nexport type GetPermittedSnaps = {\n  type: `${typeof controllerName}:getPermitted`;\n  handler: SnapController['getPermittedSnaps'];\n};\n\nexport type GetAllSnaps = {\n  type: `${typeof controllerName}:getAll`;\n  handler: SnapController['getAllSnaps'];\n};\n\nexport type IncrementActiveReferences = {\n  type: `${typeof controllerName}:incrementActiveReferences`;\n  handler: SnapController['incrementActiveReferences'];\n};\n\nexport type DecrementActiveReferences = {\n  type: `${typeof controllerName}:decrementActiveReferences`;\n  handler: SnapController['decrementActiveReferences'];\n};\n\nexport type InstallSnaps = {\n  type: `${typeof controllerName}:install`;\n  handler: SnapController['installSnaps'];\n};\n\nexport type GetRegistryMetadata = {\n  type: `${typeof controllerName}:getRegistryMetadata`;\n  handler: SnapController['getRegistryMetadata'];\n};\n\nexport type DisconnectOrigin = {\n  type: `${typeof controllerName}:disconnectOrigin`;\n  handler: SnapController['removeSnapFromSubject'];\n};\n\nexport type RevokeDynamicPermissions = {\n  type: `${typeof controllerName}:revokeDynamicPermissions`;\n  handler: SnapController['revokeDynamicSnapPermissions'];\n};\n\nexport type GetSnapFile = {\n  type: `${typeof controllerName}:getFile`;\n  handler: SnapController['getSnapFile'];\n};\n\nexport type SnapControllerActions =\n  | ClearSnapState\n  | GetSnap\n  | GetSnapState\n  | HandleSnapRequest\n  | HasSnap\n  | UpdateBlockedSnaps\n  | UpdateSnapState\n  | EnableSnap\n  | DisableSnap\n  | RemoveSnap\n  | GetPermittedSnaps\n  | InstallSnaps\n  | GetAllSnaps\n  | IncrementActiveReferences\n  | DecrementActiveReferences\n  | GetRegistryMetadata\n  | DisconnectOrigin\n  | RevokeDynamicPermissions\n  | GetSnapFile;\n\n// Controller Messenger Events\n\nexport type SnapStateChange = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [SnapControllerState, Patch[]];\n};\n\n/**\n * Emitted when an installed snap has been blocked.\n */\nexport type SnapBlocked = {\n  type: `${typeof controllerName}:snapBlocked`;\n  payload: [snapId: string, blockedSnapInfo?: BlockReason];\n};\n\n/**\n * Emitted when a snap installation or update is started.\n */\nexport type SnapInstallStarted = {\n  type: `${typeof controllerName}:snapInstallStarted`;\n  payload: [snapId: SnapId, origin: string, isUpdate: boolean];\n};\n\n/**\n * Emitted when a snap installation or update failed.\n */\nexport type SnapInstallFailed = {\n  type: `${typeof controllerName}:snapInstallFailed`;\n  payload: [snapId: SnapId, origin: string, isUpdate: boolean, error: string];\n};\n\n/**\n * Emitted when a snap has been started after being added and authorized during\n * installation.\n */\nexport type SnapInstalled = {\n  type: `${typeof controllerName}:snapInstalled`;\n  payload: [snap: TruncatedSnap, origin: string];\n};\n\n/**\n * Emitted when a snap that has previously been fully installed, is uninstalled.\n */\nexport type SnapUninstalled = {\n  type: `${typeof controllerName}:snapUninstalled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when an installed snap has been unblocked.\n */\nexport type SnapUnblocked = {\n  type: `${typeof controllerName}:snapUnblocked`;\n  payload: [snapId: string];\n};\n\n/**\n * Emitted when a snap is updated.\n */\nexport type SnapUpdated = {\n  type: `${typeof controllerName}:snapUpdated`;\n  payload: [snap: TruncatedSnap, oldVersion: string, origin: string];\n};\n\n/**\n * Emitted when a snap is rolled back.\n */\nexport type SnapRolledback = {\n  type: `${typeof controllerName}:snapRolledback`;\n  payload: [snap: TruncatedSnap, failedVersion: string];\n};\n\n/**\n * Emitted when a Snap is terminated. This is different from the snap being\n * stopped as it can also be triggered when a snap fails initialization.\n */\nexport type SnapTerminated = {\n  type: `${typeof controllerName}:snapTerminated`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a Snap is enabled by a user.\n * This is not emitted by default when installing a snap.\n */\nexport type SnapEnabled = {\n  type: `${typeof controllerName}:snapEnabled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a Snap is disabled by a user.\n */\nexport type SnapDisabled = {\n  type: `${typeof controllerName}:snapDisabled`;\n  payload: [snap: TruncatedSnap];\n};\n\nexport type SnapControllerEvents =\n  | SnapBlocked\n  | SnapInstalled\n  | SnapUninstalled\n  | SnapInstallStarted\n  | SnapInstallFailed\n  | SnapStateChange\n  | SnapUnblocked\n  | SnapUpdated\n  | SnapRolledback\n  | SnapTerminated\n  | SnapEnabled\n  | SnapDisabled;\n\nexport type AllowedActions =\n  | GetEndowments\n  | GetPermissions\n  | GetSubjects\n  | GetSubjectMetadata\n  | AddSubjectMetadata\n  | HasPermission\n  | HasPermissions\n  | RevokePermissions\n  | RevokeAllPermissions\n  | RevokePermissionForAllSubjects\n  | GrantPermissions\n  | AddApprovalRequest\n  | HandleRpcRequestAction\n  | ExecuteSnapAction\n  | TerminateAllSnapsAction\n  | TerminateSnapAction\n  | UpdateCaveat\n  | UpdateRequestState\n  | GetResult\n  | GetMetadata\n  | Update\n  | ResolveVersion\n  | TestOrigin\n  | MaybeUpdateState;\n\nexport type AllowedEvents =\n  | ExecutionServiceEvents\n  | SnapInstalled\n  | SnapUpdated;\n\ntype SnapControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  SnapControllerActions | AllowedActions,\n  SnapControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\ntype FeatureFlags = {\n  requireAllowlist?: boolean;\n  allowLocalSnaps?: boolean;\n};\n\ntype SnapControllerArgs = {\n  /**\n   * A teardown function that allows the host to clean up its instrumentation\n   * for a running snap.\n   */\n  closeAllConnections?: CloseAllConnectionsFunction;\n\n  /**\n   * A list of permissions that are allowed to be dynamic, meaning they can be revoked from the snap whenever.\n   */\n  dynamicPermissions?: string[];\n\n  /**\n   * The names of endowment permissions whose values are the names of JavaScript\n   * APIs that will be added to the snap execution environment at runtime.\n   */\n  environmentEndowmentPermissions?: string[];\n\n  /**\n   * Excluded permissions with its associated error message used to forbid certain permssions.\n   */\n  excludedPermissions?: Record<string, string>;\n\n  /**\n   * The function that will be used by the controller fo make network requests.\n   * Should be compatible with {@link fetch}.\n   */\n  fetchFunction?: typeof fetch;\n\n  /**\n   * Flags that enable or disable features in the controller.\n   * See {@link FeatureFlags}.\n   */\n  featureFlags: FeatureFlags;\n\n  /**\n   * How frequently to check whether a snap is idle.\n   */\n  idleTimeCheckInterval?: number;\n\n  /**\n   * The maximum amount of time that a snap may be idle.\n   */\n  maxIdleTime?: number;\n\n  /**\n   * The controller messenger.\n   */\n  messenger: SnapControllerMessenger;\n\n  /**\n   * The maximum amount of time a snap may take to process an RPC request,\n   * unless it is permitted to take longer.\n   */\n  maxRequestTime?: number;\n\n  /**\n   * The npm registry URL that will be used to fetch published snaps.\n   */\n  npmRegistryUrl?: string;\n\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: PersistedSnapControllerState;\n\n  /**\n   * A function that takes Snap Id and converts it into a class that fetches files.\n   *\n   * Used for test overrides.\n   */\n  detectSnapLocation?: typeof detectSnapLocation;\n\n  /**\n   * A list of snaps to be preinstalled into the SnapController state on initialization.\n   */\n  preinstalledSnaps?: PreinstalledSnap[];\n};\ntype AddSnapArgs = {\n  id: SnapId;\n  origin: string;\n  location: SnapLocation;\n  versionRange: SemVerRange;\n};\n\n// When we set a snap, we need all required properties to be present and\n// validated.\ntype SetSnapArgs = Omit<AddSnapArgs, 'location' | 'versionRange'> & {\n  files: FetchedSnapFiles;\n  isUpdate?: boolean;\n  removable?: boolean;\n  preinstalled?: boolean;\n};\n\nconst defaultState: SnapControllerState = {\n  snaps: {},\n  snapStates: {},\n  unencryptedSnapStates: {},\n};\n\n/**\n * Truncates the properties of a snap to only ones that are easily serializable.\n *\n * @param snap - The snap to truncate.\n * @returns Object with serializable snap properties.\n */\nfunction truncateSnap(snap: Snap): TruncatedSnap {\n  const truncatedSnap = Object.keys(snap).reduce<Partial<TruncatedSnap>>(\n    (serialized, key) => {\n      if (TRUNCATED_SNAP_PROPERTIES.has(key as any)) {\n        serialized[key as keyof TruncatedSnap] = snap[\n          key as keyof TruncatedSnap\n        ] as any;\n      }\n\n      return serialized;\n    },\n    {},\n  );\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return truncatedSnap as TruncatedSnap;\n}\n\nconst name = 'SnapController';\n\n/*\n * A snap is initialized in three phases:\n * - Add: Loads the snap from a remote source and parses it.\n * - Authorize: Requests the snap's required permissions from the user.\n * - Start: Initializes the snap in its SES realm with the authorized permissions.\n */\n\nexport class SnapController extends BaseController<\n  string,\n  SnapControllerState,\n  SnapControllerMessenger\n> {\n  #closeAllConnections?: CloseAllConnectionsFunction;\n\n  #dynamicPermissions: string[];\n\n  #environmentEndowmentPermissions: string[];\n\n  #excludedPermissions: Record<string, string>;\n\n  #featureFlags: FeatureFlags;\n\n  #fetchFunction: typeof fetch;\n\n  #idleTimeCheckInterval: number;\n\n  #maxIdleTime: number;\n\n  // This property cannot be hash private yet because of tests.\n  private readonly maxRequestTime: number;\n\n  #detectSnapLocation: typeof detectSnapLocation;\n\n  #snapsRuntimeData: Map<SnapId, SnapRuntimeData>;\n\n  #rollbackSnapshots: Map<string, RollbackSnapshot>;\n\n  #timeoutForLastRequestStatus?: number;\n\n  #statusMachine!: StateMachine.Machine<\n    StatusContext,\n    StatusEvents,\n    StatusStates\n  >;\n\n  constructor({\n    closeAllConnections,\n    messenger,\n    state,\n    dynamicPermissions = ['eth_accounts'],\n    environmentEndowmentPermissions = [],\n    excludedPermissions = {},\n    idleTimeCheckInterval = inMilliseconds(5, Duration.Second),\n    maxIdleTime = inMilliseconds(30, Duration.Second),\n    maxRequestTime = inMilliseconds(60, Duration.Second),\n    fetchFunction = globalThis.fetch.bind(globalThis),\n    featureFlags = {},\n    detectSnapLocation: detectSnapLocationFunction = detectSnapLocation,\n    preinstalledSnaps,\n  }: SnapControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        snapStates: {\n          persist: true,\n          anonymous: false,\n        },\n        unencryptedSnapStates: {\n          persist: true,\n          anonymous: false,\n        },\n        snaps: {\n          persist: (snaps) => {\n            return (\n              Object.values(snaps)\n                // We should not persist snaps that are in the installing state,\n                // since they haven't completed installation and would be unusable\n                .filter((snap) => snap.status !== SnapStatus.Installing)\n                .map((snap) => {\n                  return {\n                    ...snap,\n                    // At the time state is rehydrated, no snap will be running.\n                    status: SnapStatus.Stopped,\n                  };\n                })\n                .reduce((memo: Record<SnapId, Snap>, snap) => {\n                  memo[snap.id] = snap;\n                  return memo;\n                }, {})\n            );\n          },\n          anonymous: false,\n        },\n      },\n      name,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n\n    this.#closeAllConnections = closeAllConnections;\n    this.#dynamicPermissions = dynamicPermissions;\n    this.#environmentEndowmentPermissions = environmentEndowmentPermissions;\n    this.#excludedPermissions = excludedPermissions;\n    this.#featureFlags = featureFlags;\n    this.#fetchFunction = fetchFunction;\n    this.#idleTimeCheckInterval = idleTimeCheckInterval;\n    this.#maxIdleTime = maxIdleTime;\n    this.maxRequestTime = maxRequestTime;\n    this.#detectSnapLocation = detectSnapLocationFunction;\n    this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);\n    this._onOutboundRequest = this._onOutboundRequest.bind(this);\n    this._onOutboundResponse = this._onOutboundResponse.bind(this);\n    this.#rollbackSnapshots = new Map();\n    this.#snapsRuntimeData = new Map();\n    this.#pollForLastRequestStatus();\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.subscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messagingSystem.subscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messagingSystem.subscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n    this.messagingSystem.subscribe('SnapController:snapInstalled', ({ id }) => {\n      this.#callLifecycleHook(id, HandlerType.OnInstall).catch((error) => {\n        logError(\n          `Error when calling \\`onInstall\\` lifecycle hook for snap \"${id}\": ${getErrorMessage(\n            error,\n          )}`,\n        );\n      });\n    });\n\n    this.messagingSystem.subscribe('SnapController:snapUpdated', ({ id }) => {\n      this.#callLifecycleHook(id, HandlerType.OnUpdate).catch((error) => {\n        logError(\n          `Error when calling \\`onUpdate\\` lifecycle hook for snap \"${id}\": ${getErrorMessage(\n            error,\n          )}`,\n        );\n      });\n    });\n\n    this.#initializeStateMachine();\n    this.#registerMessageHandlers();\n\n    if (preinstalledSnaps) {\n      this.#handlePreinstalledSnaps(preinstalledSnaps);\n    }\n\n    Object.values(this.state?.snaps ?? {}).forEach((snap) =>\n      this.#setupRuntime(snap.id),\n    );\n  }\n\n  /**\n   * We track status of a Snap using a finite-state-machine.\n   * It keeps track of whether the snap is started / stopped / etc.\n   *\n   * @see {@link SnapController.transition} for interacting with the machine.\n   */\n  // We initialize the machine in the instance because the status is currently tightly coupled\n  // with the SnapController - the guard checks for enabled status inside the SnapController state.\n  // In the future, side-effects could be added to the machine during transitions.\n  #initializeStateMachine() {\n    const disableGuard = ({ snapId }: StatusContext) => {\n      return this.getExpect(snapId).enabled;\n    };\n\n    const statusConfig: StateMachine.Config<\n      StatusContext,\n      StatusEvents,\n      StatusStates\n    > = {\n      initial: SnapStatus.Installing,\n      states: {\n        [SnapStatus.Installing]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n          },\n        },\n        [SnapStatus.Updating]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n          },\n        },\n        [SnapStatus.Running]: {\n          on: {\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n            [SnapStatusEvents.Crash]: SnapStatus.Crashed,\n          },\n        },\n        [SnapStatus.Stopped]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n        [SnapStatus.Crashed]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n      },\n    };\n    this.#statusMachine = createMachine(statusConfig);\n    validateMachine(this.#statusMachine);\n  }\n\n  /**\n   * Constructor helper for registering the controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:clearSnapState`,\n      (...args) => this.clearSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:get`,\n      (...args) => this.get(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getSnapState`,\n      (...args) => this.getSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:handleRequest`,\n      async (...args) => this.handleRequest(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:has`,\n      (...args) => this.has(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateBlockedSnaps`,\n      async () => this.updateBlockedSnaps(),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateSnapState`,\n      (...args) => this.updateSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:enable`,\n      (...args) => this.enableSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:disable`,\n      async (...args) => this.disableSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:remove`,\n      async (...args) => this.removeSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getPermitted`,\n      (...args) => this.getPermittedSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:install`,\n      async (...args) => this.installSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getAll`,\n      (...args) => this.getAllSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:incrementActiveReferences`,\n      (...args) => this.incrementActiveReferences(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:decrementActiveReferences`,\n      (...args) => this.decrementActiveReferences(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getRegistryMetadata`,\n      async (...args) => this.getRegistryMetadata(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:disconnectOrigin`,\n      (...args) => this.removeSnapFromSubject(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:revokeDynamicPermissions`,\n      (...args) => this.revokeDynamicSnapPermissions(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getFile`,\n      async (...args) => this.getSnapFile(...args),\n    );\n  }\n\n  #handlePreinstalledSnaps(preinstalledSnaps: PreinstalledSnap[]) {\n    for (const { snapId, manifest, files, removable } of preinstalledSnaps) {\n      const existingSnap = this.get(snapId);\n      const isAlreadyInstalled = existingSnap !== undefined;\n      const isUpdate =\n        isAlreadyInstalled && gtVersion(manifest.version, existingSnap.version);\n\n      // Disallow downgrades and overwriting non preinstalled snaps\n      if (\n        isAlreadyInstalled &&\n        (!isUpdate || existingSnap.preinstalled !== true)\n      ) {\n        continue;\n      }\n\n      const manifestFile = new VirtualFile<SnapManifest>({\n        path: NpmSnapFileNames.Manifest,\n        value: JSON.stringify(manifest),\n        result: manifest,\n      });\n\n      const virtualFiles = files.map(\n        ({ path, value }) => new VirtualFile({ value, path }),\n      );\n      const { filePath, iconPath } = manifest.source.location.npm;\n      const sourceCode = virtualFiles.find((file) => file.path === filePath);\n      const svgIcon = iconPath\n        ? virtualFiles.find((file) => file.path === iconPath)\n        : undefined;\n\n      assert(sourceCode, 'Source code not provided for preinstalled snap.');\n\n      assert(\n        !iconPath || (iconPath && svgIcon),\n        'Icon not provided for preinstalled snap.',\n      );\n\n      assert(\n        manifest.source.files === undefined,\n        'Auxiliary files are not currently supported for preinstalled snaps.',\n      );\n\n      const localizationFiles =\n        manifest.source.locales?.map((path) =>\n          virtualFiles.find((file) => file.path === path),\n        ) ?? [];\n\n      const validatedLocalizationFiles = getValidatedLocalizationFiles(\n        localizationFiles.filter(Boolean) as VirtualFile<unknown>[],\n      );\n\n      assert(\n        localizationFiles.length === validatedLocalizationFiles.length,\n        'Missing localization files for preinstalled snap.',\n      );\n\n      const filesObject: FetchedSnapFiles = {\n        manifest: manifestFile,\n        sourceCode,\n        svgIcon,\n        auxiliaryFiles: [],\n        localizationFiles: validatedLocalizationFiles,\n      };\n\n      // Add snap to the SnapController state\n      this.#set({\n        id: snapId,\n        origin: 'metamask',\n        files: filesObject,\n        removable,\n        preinstalled: true,\n      });\n\n      // Setup permissions\n      const processedPermissions = processSnapPermissions(\n        manifest.initialPermissions,\n      );\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      const { newPermissions, unusedPermissions } =\n        this.#calculatePermissionsChange(snapId, processedPermissions);\n\n      this.#updatePermissions({ snapId, newPermissions, unusedPermissions });\n\n      // Set status\n      this.update((state) => {\n        state.snaps[snapId].status = SnapStatus.Stopped;\n      });\n    }\n  }\n\n  #pollForLastRequestStatus() {\n    this.#timeoutForLastRequestStatus = setTimeout(() => {\n      this.#stopSnapsLastRequestPastMax().catch((error) => {\n        // TODO: Decide how to handle errors.\n        logError(error);\n      });\n\n      this.#pollForLastRequestStatus();\n    }, this.#idleTimeCheckInterval) as unknown as number;\n  }\n\n  /**\n   * Checks all installed snaps against the block list and\n   * blocks/unblocks snaps as appropriate. See {@link SnapController.blockSnap}\n   * for more information.\n   */\n  async updateBlockedSnaps(): Promise<void> {\n    await this.messagingSystem.call('SnapsRegistry:update');\n\n    const blockedSnaps = await this.messagingSystem.call(\n      'SnapsRegistry:get',\n      Object.values(this.state.snaps).reduce<SnapsRegistryRequest>(\n        (blockListArg, snap) => {\n          blockListArg[snap.id] = {\n            version: snap.version,\n            checksum: snap.manifest.source.shasum,\n          };\n          return blockListArg;\n        },\n        {},\n      ),\n    );\n\n    await Promise.all(\n      Object.entries(blockedSnaps).map(async ([snapId, { status, reason }]) => {\n        if (status === SnapsRegistryStatus.Blocked) {\n          return this.#blockSnap(snapId as SnapId, reason);\n        }\n\n        return this.#unblockSnap(snapId as SnapId);\n      }),\n    );\n  }\n\n  /**\n   * Blocks an installed snap and prevents it from being started again. Emits\n   * {@link SnapBlocked}. Does nothing if the snap is not installed.\n   *\n   * @param snapId - The snap to block.\n   * @param blockedSnapInfo - Information detailing why the snap is blocked.\n   */\n  async #blockSnap(\n    snapId: SnapId,\n    blockedSnapInfo?: BlockReason,\n  ): Promise<void> {\n    if (!this.has(snapId)) {\n      return;\n    }\n\n    try {\n      this.update((state: any) => {\n        state.snaps[snapId].blocked = true;\n        state.snaps[snapId].blockInformation = blockedSnapInfo;\n      });\n\n      await this.disableSnap(snapId);\n    } catch (error) {\n      logError(\n        `Encountered error when stopping blocked snap \"${snapId}\".`,\n        error,\n      );\n    }\n\n    this.messagingSystem.publish(\n      `${controllerName}:snapBlocked`,\n      snapId,\n      blockedSnapInfo,\n    );\n  }\n\n  /**\n   * Unblocks a snap so that it can be enabled and started again. Emits\n   * {@link SnapUnblocked}. Does nothing if the snap is not installed or already\n   * unblocked.\n   *\n   * @param snapId - The id of the snap to unblock.\n   */\n  #unblockSnap(snapId: SnapId) {\n    if (!this.has(snapId) || !this.state.snaps[snapId].blocked) {\n      return;\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].blocked = false;\n      delete state.snaps[snapId].blockInformation;\n    });\n\n    this.messagingSystem.publish(`${controllerName}:snapUnblocked`, snapId);\n  }\n\n  async #assertIsInstallAllowed(snapId: SnapId, snapInfo: SnapsRegistryInfo) {\n    const results = await this.messagingSystem.call('SnapsRegistry:get', {\n      [snapId]: snapInfo,\n    });\n    const result = results[snapId];\n    if (result.status === SnapsRegistryStatus.Blocked) {\n      throw new Error(\n        `Cannot install version \"${\n          snapInfo.version\n        }\" of snap \"${snapId}\": The version is blocked. ${\n          result.reason?.explanation ?? ''\n        }`,\n      );\n    } else if (\n      this.#featureFlags.requireAllowlist &&\n      result.status !== SnapsRegistryStatus.Verified\n    ) {\n      throw new Error(\n        `Cannot install version \"${snapInfo.version}\" of snap \"${snapId}\": The snap is not on the allowlist.`,\n      );\n    }\n  }\n\n  async #stopSnapsLastRequestPastMax() {\n    const entries = [...this.#snapsRuntimeData.entries()];\n    return Promise.all(\n      entries\n        .filter(\n          ([_snapId, runtime]) =>\n            runtime.activeReferences === 0 &&\n            runtime.pendingInboundRequests.length === 0 &&\n            runtime.lastRequest &&\n            this.#maxIdleTime &&\n            timeSince(runtime.lastRequest) > this.#maxIdleTime,\n        )\n        .map(async ([snapId]) => this.stopSnap(snapId, SnapStatusEvents.Stop)),\n    );\n  }\n\n  _onUnhandledSnapError(snapId: string, _error: SnapErrorJson) {\n    this.stopSnap(snapId as SnapId, SnapStatusEvents.Crash).catch(\n      (stopSnapError) => {\n        // TODO: Decide how to handle errors.\n        logError(stopSnapError);\n      },\n    );\n  }\n\n  _onOutboundRequest(snapId: string) {\n    const runtime = this.#getRuntimeExpect(snapId as SnapId);\n    // Ideally we would only pause the pending request that is making the outbound request\n    // but right now we don't have a way to know which request initiated the outbound request\n    runtime.pendingInboundRequests\n      .filter((pendingRequest) => pendingRequest.timer.status === 'running')\n      .forEach((pendingRequest) => pendingRequest.timer.pause());\n    runtime.pendingOutboundRequests += 1;\n  }\n\n  _onOutboundResponse(snapId: string) {\n    const runtime = this.#getRuntimeExpect(snapId as SnapId);\n    runtime.pendingOutboundRequests -= 1;\n    if (runtime.pendingOutboundRequests === 0) {\n      runtime.pendingInboundRequests\n        .filter((pendingRequest) => pendingRequest.timer.status === 'paused')\n        .forEach((pendingRequest) => pendingRequest.timer.resume());\n    }\n  }\n\n  /**\n   * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out\n   * the next state. This transition function uses a very minimal subset of XState conventions:\n   * - supports initial state\n   * - .on supports raw event target string\n   * - .on supports {target, cond} object\n   * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event,\n   * context) => boolean`\n   *\n   * @param snapId - The id of the snap to transition.\n   * @param event - The event enum to use to transition.\n   */\n  #transition(snapId: SnapId, event: StatusEvents | StatusEvents['type']) {\n    const { interpreter } = this.#getRuntimeExpect(snapId);\n    interpreter.send(event);\n    this.update((state: any) => {\n      state.snaps[snapId].status = interpreter.state.value;\n    });\n  }\n\n  /**\n   * Starts the given snap. Throws an error if no such snap exists\n   * or if it is already running.\n   *\n   * @param snapId - The id of the Snap to start.\n   */\n  async startSnap(snapId: SnapId): Promise<void> {\n    const snap = this.state.snaps[snapId];\n\n    if (snap.enabled === false) {\n      throw new Error(`Snap \"${snapId}\" is disabled.`);\n    }\n\n    await this.#startSnap({\n      snapId,\n      sourceCode: snap.sourceCode,\n    });\n  }\n\n  /**\n   * Enables the given snap. A snap can only be started if it is enabled. A snap\n   * can only be enabled if it isn't blocked.\n   *\n   * @param snapId - The id of the Snap to enable.\n   */\n  enableSnap(snapId: SnapId): void {\n    this.getExpect(snapId);\n\n    if (this.state.snaps[snapId].blocked) {\n      throw new Error(`Snap \"${snapId}\" is blocked and cannot be enabled.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = true;\n    });\n\n    this.messagingSystem.publish(\n      'SnapController:snapEnabled',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Disables the given snap. A snap can only be started if it is enabled.\n   *\n   * @param snapId - The id of the Snap to disable.\n   * @returns A promise that resolves once the snap has been disabled.\n   */\n  async disableSnap(snapId: SnapId): Promise<void> {\n    if (!this.has(snapId)) {\n      throw new Error(`Snap \"${snapId}\" not found.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = false;\n    });\n\n    if (this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    this.messagingSystem.publish(\n      'SnapController:snapDisabled',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Stops the given snap, removes all hooks, closes all connections, and\n   * terminates its worker.\n   *\n   * @param snapId - The id of the Snap to stop.\n   * @param statusEvent - The Snap status event that caused the snap to be\n   * stopped.\n   */\n  public async stopSnap(\n    snapId: SnapId,\n    statusEvent:\n      | SnapStatusEvents.Stop\n      | SnapStatusEvents.Crash = SnapStatusEvents.Stop,\n  ): Promise<void> {\n    const runtime = this.#getRuntime(snapId);\n    if (!runtime) {\n      throw new Error(`The snap \"${snapId}\" is not running.`);\n    }\n\n    // Reset request tracking\n    runtime.lastRequest = null;\n    runtime.pendingInboundRequests = [];\n    runtime.pendingOutboundRequests = 0;\n    try {\n      if (this.isRunning(snapId)) {\n        this.#closeAllConnections?.(snapId);\n        await this.#terminateSnap(snapId);\n      }\n    } finally {\n      if (this.isRunning(snapId)) {\n        this.#transition(snapId, statusEvent);\n      }\n    }\n  }\n\n  /**\n   * Terminates the specified snap and emits the `snapTerminated` event.\n   *\n   * @param snapId - The snap to terminate.\n   */\n  async #terminateSnap(snapId: SnapId) {\n    await this.messagingSystem.call('ExecutionService:terminateSnap', snapId);\n    this.messagingSystem.publish(\n      'SnapController:snapTerminated',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Returns whether the given snap is running.\n   * Throws an error if the snap doesn't exist.\n   *\n   * @param snapId - The id of the Snap to check.\n   * @returns `true` if the snap is running, otherwise `false`.\n   */\n  isRunning(snapId: SnapId): boolean {\n    return this.getExpect(snapId).status === 'running';\n  }\n\n  /**\n   * Returns whether the given snap has been added to state.\n   *\n   * @param snapId - The id of the Snap to check for.\n   * @returns `true` if the snap exists in the controller state, otherwise `false`.\n   */\n  has(snapId: SnapId): boolean {\n    return Boolean(this.get(snapId));\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, including all data.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns The entire snap object from the controller state.\n   */\n  get(snapId: string): Snap | undefined {\n    return this.state.snaps[snapId as SnapId];\n  }\n\n  /**\n   * Gets the snap with the given id, throws if doesn't.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @see {@link SnapController.get}\n   * @throws {@link Error}. If the snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns The entire snap object.\n   */\n  getExpect(snapId: SnapId): Snap {\n    const snap = this.get(snapId);\n    assert(snap !== undefined, new Error(`Snap \"${snapId}\" not found.`));\n    return snap;\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, excluding any\n   * non-serializable or expensive-to-serialize data.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  // TODO(ritave): this.get returns undefined, this.getTruncated returns null\n  getTruncated(snapId: SnapId): TruncatedSnap | null {\n    const snap = this.get(snapId);\n\n    return snap ? truncateSnap(snap) : null;\n  }\n\n  /**\n   * Gets the snap with the given id, throw if it doesn't exist.\n   *\n   * @throws {@link Error}. If snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  getTruncatedExpect(snapId: SnapId): TruncatedSnap {\n    return truncateSnap(this.getExpect(snapId));\n  }\n\n  /**\n   * Updates the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be updated.\n   * @param newSnapState - The new state of the snap.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   */\n  updateSnapState(snapId: SnapId, newSnapState: string, encrypted: boolean) {\n    this.update((state) => {\n      if (encrypted) {\n        state.snapStates[snapId] = newSnapState;\n      } else {\n        state.unencryptedSnapStates[snapId] = newSnapState;\n      }\n    });\n  }\n\n  /**\n   * Clears the state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be cleared.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   */\n  clearSnapState(snapId: SnapId, encrypted: boolean) {\n    this.update((state) => {\n      if (encrypted) {\n        state.snapStates[snapId] = null;\n      } else {\n        state.unencryptedSnapStates[snapId] = null;\n      }\n    });\n  }\n\n  /**\n   * Gets the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   * @returns The requested snap state or null if no state exists.\n   */\n  getSnapState(snapId: SnapId, encrypted: boolean): Json {\n    const state = encrypted\n      ? this.state.snapStates[snapId]\n      : this.state.unencryptedSnapStates[snapId];\n    return state ?? null;\n  }\n\n  /**\n   * Gets a static auxiliary snap file in a chosen file encoding.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @param path - The path to the requested file.\n   * @param encoding - An optional requested file encoding.\n   * @returns The file requested in the chosen file encoding or null if the file is not found.\n   */\n  async getSnapFile(\n    snapId: SnapId,\n    path: string,\n    encoding: AuxiliaryFileEncoding = AuxiliaryFileEncoding.Base64,\n  ): Promise<string | null> {\n    const snap = this.getExpect(snapId);\n    const normalizedPath = normalizeRelative(path);\n    const value = snap.auxiliaryFiles?.find(\n      (file) => file.path === normalizedPath,\n    )?.value;\n\n    if (!value) {\n      return null;\n    }\n\n    return encodeAuxiliaryFile(value, encoding);\n  }\n\n  /**\n   * Completely clear the controller's state: delete all associated data,\n   * handlers, event listeners, and permissions; tear down all snap providers.\n   */\n  async clearState() {\n    const snapIds = Object.keys(this.state.snaps);\n    if (this.#closeAllConnections) {\n      snapIds.forEach((snapId) => {\n        this.#closeAllConnections?.(snapId);\n      });\n    }\n\n    await this.messagingSystem.call('ExecutionService:terminateAllSnaps');\n    snapIds.forEach((snapId) => this.#revokeAllSnapPermissions(snapId));\n\n    this.update((state: any) => {\n      state.snaps = {};\n      state.snapStates = {};\n    });\n  }\n\n  /**\n   * Removes the given snap from state, and clears all associated handlers\n   * and listeners.\n   *\n   * @param snapId - The id of the Snap.\n   * @returns A promise that resolves once the snap has been removed.\n   */\n  async removeSnap(snapId: SnapId): Promise<void> {\n    return this.removeSnaps([snapId]);\n  }\n\n  /**\n   * Stops the given snaps, removes them from state, and clears all associated\n   * permissions, handlers, and listeners.\n   *\n   * @param snapIds - The ids of the Snaps.\n   */\n  async removeSnaps(snapIds: SnapId[]): Promise<void> {\n    if (!Array.isArray(snapIds)) {\n      throw new Error('Expected array of snap ids.');\n    }\n\n    snapIds.forEach((snapId) => {\n      const snap = this.getExpect(snapId);\n      assert(snap.removable !== false, `${snapId} is not removable.`);\n    });\n\n    await Promise.all(\n      snapIds.map(async (snapId) => {\n        const snap = this.getExpect(snapId);\n        const truncated = this.getTruncatedExpect(snapId);\n        // Disable the snap and revoke all of its permissions before deleting\n        // it. This ensures that the snap will not be restarted or otherwise\n        // affect the host environment while we are deleting it.\n        await this.disableSnap(snapId);\n        this.#revokeAllSnapPermissions(snapId);\n\n        this.#removeSnapFromSubjects(snapId);\n\n        this.#snapsRuntimeData.delete(snapId);\n\n        this.update((state: any) => {\n          delete state.snaps[snapId];\n          delete state.snapStates[snapId];\n        });\n\n        // If the snap has been fully installed before, also emit snapUninstalled.\n        if (snap.status !== SnapStatus.Installing) {\n          this.messagingSystem.publish(\n            `SnapController:snapUninstalled`,\n            truncated,\n          );\n        }\n      }),\n    );\n  }\n\n  #handleInitialConnections(\n    snapId: SnapId,\n    previousInitialConnections: InitialConnections | null,\n    initialConnections: InitialConnections,\n  ) {\n    if (previousInitialConnections) {\n      const revokedInitialConnections = setDiff(\n        previousInitialConnections,\n        initialConnections,\n      );\n\n      for (const origin of Object.keys(revokedInitialConnections)) {\n        this.removeSnapFromSubject(origin, snapId);\n      }\n    }\n\n    for (const origin of Object.keys(initialConnections)) {\n      this.#addSnapToSubject(origin, snapId);\n    }\n  }\n\n  #addSnapToSubject(origin: string, snapId: SnapId) {\n    const subjectPermissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const existingCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds);\n\n    const subjectHasSnap = Boolean(\n      (existingCaveat?.value as Record<string, Json>)?.[snapId],\n    );\n\n    // If the subject is already connected to the snap, this is a no-op.\n    if (subjectHasSnap) {\n      return;\n    }\n\n    // If an existing caveat exists, we add the snap to that.\n    if (existingCaveat) {\n      this.messagingSystem.call(\n        'PermissionController:updateCaveat',\n        origin,\n        WALLET_SNAP_PERMISSION_KEY,\n        SnapCaveatType.SnapIds,\n        { ...existingCaveat, [snapId]: {} },\n      );\n      return;\n    }\n\n    const approvedPermissions = {\n      [WALLET_SNAP_PERMISSION_KEY]: {\n        caveats: [\n          {\n            type: SnapCaveatType.SnapIds,\n            value: {\n              [snapId]: {},\n            },\n          },\n        ],\n      },\n    } as RequestedPermissions;\n\n    this.messagingSystem.call('PermissionController:grantPermissions', {\n      approvedPermissions,\n      subject: { origin },\n    });\n  }\n\n  /**\n   * Removes a snap's permission (caveat) from the specified subject.\n   *\n   * @param origin - The origin from which to remove the snap.\n   * @param snapId - The id of the snap to remove.\n   */\n  removeSnapFromSubject(origin: string, snapId: SnapId) {\n    const subjectPermissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const snapIdsCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds) as\n      | Caveat<string, Json>\n      | undefined;\n\n    if (!snapIdsCaveat) {\n      return;\n    }\n\n    const caveatHasSnap = Boolean(\n      (snapIdsCaveat.value as Record<string, Json>)?.[snapId],\n    );\n    if (caveatHasSnap) {\n      const newCaveatValue = {\n        ...(snapIdsCaveat.value as Record<string, Json>),\n      };\n      delete newCaveatValue[snapId];\n      if (Object.keys(newCaveatValue).length > 0) {\n        this.messagingSystem.call(\n          'PermissionController:updateCaveat',\n          origin,\n          WALLET_SNAP_PERMISSION_KEY,\n          SnapCaveatType.SnapIds,\n          newCaveatValue,\n        );\n      } else {\n        this.messagingSystem.call('PermissionController:revokePermissions', {\n          [origin]: [WALLET_SNAP_PERMISSION_KEY],\n        });\n      }\n    }\n  }\n\n  /**\n   * Checks if a list of permissions are dynamic and allowed to be revoked, if they are they will all be revoked.\n   *\n   * @param snapId - The snap ID.\n   * @param permissionNames - The names of the permissions.\n   * @throws If non-dynamic permissions are passed.\n   */\n  revokeDynamicSnapPermissions(\n    snapId: string,\n    permissionNames: NonEmptyArray<string>,\n  ) {\n    assert(\n      permissionNames.every((permissionName) =>\n        this.#dynamicPermissions.includes(permissionName),\n      ),\n      'Non-dynamic permissions cannot be revoked',\n    );\n    this.messagingSystem.call('PermissionController:revokePermissions', {\n      [snapId]: permissionNames,\n    });\n  }\n\n  /**\n   * Removes a snap's permission (caveat) from all subjects.\n   *\n   * @param snapId - The id of the Snap.\n   */\n  #removeSnapFromSubjects(snapId: SnapId) {\n    const subjects = this.messagingSystem.call(\n      'PermissionController:getSubjectNames',\n    );\n    for (const subject of subjects) {\n      this.removeSnapFromSubject(subject, snapId);\n    }\n  }\n\n  /**\n   * Safely revokes all permissions granted to a Snap.\n   *\n   * @param snapId - The snap ID.\n   */\n  #revokeAllSnapPermissions(snapId: string) {\n    if (\n      this.messagingSystem.call('PermissionController:hasPermissions', snapId)\n    ) {\n      this.messagingSystem.call(\n        'PermissionController:revokeAllPermissions',\n        snapId,\n      );\n    }\n  }\n\n  /**\n   * Handles incrementing the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced.\n   */\n  incrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.activeReferences += 1;\n  }\n\n  /**\n   * Handles decrement the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced..\n   */\n  decrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    assert(\n      runtime.activeReferences > 0,\n      'SnapController reference management is in an invalid state.',\n    );\n    runtime.activeReferences -= 1;\n  }\n\n  /**\n   * Gets all snaps in their truncated format.\n   *\n   * @returns All installed snaps in their truncated format.\n   */\n  getAllSnaps(): TruncatedSnap[] {\n    return Object.values(this.state.snaps).map(truncateSnap);\n  }\n\n  /**\n   * Gets the serialized permitted snaps of the given origin, if any.\n   *\n   * @param origin - The origin whose permitted snaps to retrieve.\n   * @returns The serialized permitted snaps for the origin.\n   */\n  getPermittedSnaps(origin: string): RequestSnapsResult {\n    const permissions =\n      this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        origin,\n      ) ?? {};\n    const snaps =\n      permissions[WALLET_SNAP_PERMISSION_KEY]?.caveats?.find(\n        (caveat) => caveat.type === SnapCaveatType.SnapIds,\n      )?.value ?? {};\n    return Object.keys(snaps).reduce<RequestSnapsResult>(\n      (permittedSnaps, snapId) => {\n        const snap = this.get(snapId);\n        const truncatedSnap = this.getTruncated(snapId as SnapId);\n\n        if (truncatedSnap && snap?.status !== SnapStatus.Installing) {\n          permittedSnaps[snapId] = truncatedSnap;\n        }\n        return permittedSnaps;\n      },\n      {},\n    );\n  }\n\n  /**\n   * Installs the snaps requested by the given origin, returning the snap\n   * object if the origin is permitted to install it, and an authorization error\n   * otherwise.\n   *\n   * @param origin - The origin that requested to install the snaps.\n   * @param requestedSnaps - The snaps to install.\n   * @returns An object of snap ids and snap objects, or errors if a\n   * snap couldn't be installed.\n   */\n  async installSnaps(\n    origin: string,\n    requestedSnaps: RequestSnapsParams,\n  ): Promise<RequestSnapsResult> {\n    const result: RequestSnapsResult = {};\n\n    const snapIds = Object.keys(requestedSnaps);\n\n    const pendingUpdates = [];\n    const pendingInstalls = [];\n\n    try {\n      for (const [snapId, { version: rawVersion }] of Object.entries(\n        requestedSnaps,\n      )) {\n        assertIsValidSnapId(snapId);\n\n        const [error, version] = resolveVersionRange(rawVersion);\n\n        if (error) {\n          throw rpcErrors.invalidParams(\n            `The \"version\" field must be a valid SemVer version range if specified. Received: \"${\n              rawVersion as string\n            }\".`,\n          );\n        }\n\n        const location = this.#detectSnapLocation(snapId, {\n          versionRange: version,\n          fetch: this.#fetchFunction,\n          allowLocal: this.#featureFlags.allowLocalSnaps,\n          resolveVersion: async (range) =>\n            this.#featureFlags.requireAllowlist\n              ? await this.#resolveAllowlistVersion(snapId, range)\n              : range,\n        });\n\n        // Existing snaps may need to be updated, unless they should be re-installed (e.g. local snaps)\n        // Everything else is treated as an install\n        const isUpdate = this.has(snapId) && !location.shouldAlwaysReload;\n\n        if (isUpdate && this.#isValidUpdate(snapId, version)) {\n          const existingSnap = this.getExpect(snapId);\n          pendingUpdates.push({ snapId, oldVersion: existingSnap.version });\n          let rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n          if (rollbackSnapshot === undefined) {\n            rollbackSnapshot = this.#createRollbackSnapshot(snapId);\n            rollbackSnapshot.newVersion = version;\n          } else {\n            throw new Error('This snap is already being updated.');\n          }\n        } else if (!isUpdate) {\n          pendingInstalls.push(snapId);\n        }\n\n        result[snapId] = await this.processRequestedSnap(\n          origin,\n          snapId,\n          location,\n          version,\n        );\n      }\n\n      // Once we finish all installs / updates, emit events.\n      pendingInstalls.forEach((snapId) =>\n        this.messagingSystem.publish(\n          `SnapController:snapInstalled`,\n          this.getTruncatedExpect(snapId),\n          origin,\n        ),\n      );\n\n      pendingUpdates.forEach(({ snapId, oldVersion }) =>\n        this.messagingSystem.publish(\n          `SnapController:snapUpdated`,\n          this.getTruncatedExpect(snapId),\n          oldVersion,\n          origin,\n        ),\n      );\n\n      snapIds.forEach((snapId) => this.#rollbackSnapshots.delete(snapId));\n    } catch (error) {\n      const installed = pendingInstalls.filter((snapId) => this.has(snapId));\n      await this.removeSnaps(installed);\n      const snapshottedSnaps = [...this.#rollbackSnapshots.keys()];\n      const snapsToRollback = pendingUpdates\n        .map(({ snapId }) => snapId)\n        .filter((snapId) => snapshottedSnaps.includes(snapId));\n      await this.#rollbackSnaps(snapsToRollback);\n\n      throw error;\n    }\n\n    return result;\n  }\n\n  /**\n   * Adds, authorizes, and runs the given snap with a snap provider.\n   * Results from this method should be efficiently serializable.\n   *\n   * @param origin - The origin requesting the snap.\n   * @param snapId - The id of the snap.\n   * @param location - The location implementation of the snap.\n   * @param versionRange - The semver range of the snap to install.\n   * @returns The resulting snap object, or an error if something went wrong.\n   */\n  private async processRequestedSnap(\n    origin: string,\n    snapId: SnapId,\n    location: SnapLocation,\n    versionRange: SemVerRange,\n  ): Promise<TruncatedSnap> {\n    const existingSnap = this.getTruncated(snapId);\n\n    // For devX we always re-install local snaps.\n    if (existingSnap && !location.shouldAlwaysReload) {\n      if (satisfiesVersionRange(existingSnap.version, versionRange)) {\n        return existingSnap;\n      }\n\n      return await this.updateSnap(\n        origin,\n        snapId,\n        location,\n        versionRange,\n        // Since we are requesting an update from within processRequestedSnap,\n        // we disable the emitting of the snapUpdated event and rely on the caller\n        // to publish this event after the update is complete.\n        // This is necessary as installSnaps may be installing multiple snaps\n        // and we don't want to emit events prematurely.\n        false,\n      );\n    }\n\n    let pendingApproval = this.#createApproval({\n      origin,\n      snapId,\n      type: SNAP_APPROVAL_INSTALL,\n    });\n\n    this.messagingSystem.publish(\n      'SnapController:snapInstallStarted',\n      snapId,\n      origin,\n      false,\n    );\n\n    // Existing snaps must be stopped before overwriting\n    if (existingSnap && this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    // Existing snaps that should be re-installed should not maintain their existing permissions\n    if (existingSnap && location.shouldAlwaysReload) {\n      this.#revokeAllSnapPermissions(snapId);\n    }\n\n    try {\n      const { sourceCode } = await this.#add({\n        origin,\n        id: snapId,\n        location,\n        versionRange,\n      });\n\n      await this.authorize(snapId, pendingApproval);\n\n      pendingApproval = this.#createApproval({\n        origin,\n        snapId,\n        type: SNAP_APPROVAL_RESULT,\n      });\n\n      await this.#startSnap({\n        snapId,\n        sourceCode,\n      });\n\n      const truncated = this.getTruncatedExpect(snapId);\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_INSTALL,\n      });\n\n      return truncated;\n    } catch (error) {\n      logError(`Error when adding ${snapId}.`, error);\n\n      const errorString =\n        error instanceof Error ? error.message : error.toString();\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_INSTALL,\n        error: errorString,\n      });\n\n      this.messagingSystem.publish(\n        'SnapController:snapInstallFailed',\n        snapId,\n        origin,\n        false,\n        errorString,\n      );\n\n      throw error;\n    }\n  }\n\n  #createApproval({\n    origin,\n    snapId,\n    type,\n  }: {\n    origin: string;\n    snapId: SnapId;\n    type: string;\n  }): PendingApproval {\n    const id = nanoid();\n    const promise = this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        origin,\n        id,\n        type,\n        requestData: {\n          // Mirror previous installation metadata\n          metadata: { id, origin: snapId, dappOrigin: origin },\n          snapId,\n        },\n        requestState: {\n          loading: true,\n        },\n      },\n      true,\n    );\n\n    return { id, promise };\n  }\n\n  #updateApproval(id: string, requestState: Record<string, Json>) {\n    try {\n      this.messagingSystem.call('ApprovalController:updateRequestState', {\n        id,\n        requestState,\n      });\n    } catch {\n      // Do nothing\n    }\n  }\n\n  /**\n   * Updates an installed snap. The flow is similar to\n   * {@link SnapController.installSnaps}. The user will be asked if they want\n   * to update, then approve any permission changes, and finally the snap will\n   * be restarted.\n   *\n   * The update will fail if the user rejects any prompt or if the new version\n   * of the snap is blocked.\n   *\n   * If the original version of the snap was blocked and the update succeeded,\n   * the snap will be unblocked and enabled before it is restarted.\n   *\n   * @param origin - The origin requesting the snap update.\n   * @param snapId - The id of the Snap to be updated.\n   * @param location - The location implementation of the snap.\n   * @param newVersionRange - A semver version range in which the maximum version will be chosen.\n   * @param emitEvent - An optional boolean flag to indicate whether this update should emit an event.\n   * @returns The snap metadata if updated, `null` otherwise.\n   */\n  async updateSnap(\n    origin: string,\n    snapId: SnapId,\n    location: SnapLocation,\n    newVersionRange: string = DEFAULT_REQUESTED_SNAP_VERSION,\n    emitEvent = true,\n  ): Promise<TruncatedSnap> {\n    if (!isValidSemVerRange(newVersionRange)) {\n      throw new Error(\n        `Received invalid snap version range: \"${newVersionRange}\".`,\n      );\n    }\n\n    let pendingApproval = this.#createApproval({\n      origin,\n      snapId,\n      type: SNAP_APPROVAL_UPDATE,\n    });\n\n    try {\n      this.messagingSystem.publish(\n        'SnapController:snapInstallStarted',\n        snapId,\n        origin,\n        true,\n      );\n\n      const snap = this.getExpect(snapId);\n\n      const oldManifest = snap.manifest;\n\n      const newSnap = await fetchSnap(snapId, location);\n      const { sourceCode: sourceCodeFile, manifest: manifestFile } = newSnap;\n\n      const manifest = manifestFile.result;\n\n      const newVersion = manifest.version;\n      if (!gtVersion(newVersion, snap.version)) {\n        throw rpcErrors.invalidParams(\n          `Snap \"${snapId}@${snap.version}\" is already installed. Couldn't update to a version inside requested \"${newVersionRange}\" range.`,\n        );\n      }\n\n      if (!satisfiesVersionRange(newVersion, newVersionRange)) {\n        throw new Error(\n          `Version mismatch. Manifest for \"${snapId}\" specifies version \"${newVersion}\" which doesn't satisfy requested version range \"${newVersionRange}\".`,\n        );\n      }\n\n      await this.#assertIsInstallAllowed(snapId, {\n        version: newVersion,\n        checksum: manifest.source.shasum,\n      });\n\n      const processedPermissions = processSnapPermissions(\n        manifest.initialPermissions,\n      );\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      const { newPermissions, unusedPermissions, approvedPermissions } =\n        this.#calculatePermissionsChange(snapId, processedPermissions);\n\n      this.#updateApproval(pendingApproval.id, {\n        permissions: newPermissions,\n        newVersion: manifest.version,\n        newPermissions,\n        approvedPermissions,\n        unusedPermissions,\n        loading: false,\n      });\n\n      const { permissions: approvedNewPermissions, ...requestData } =\n        (await pendingApproval.promise) as PermissionsRequest;\n\n      pendingApproval = this.#createApproval({\n        origin,\n        snapId,\n        type: SNAP_APPROVAL_RESULT,\n      });\n\n      if (this.isRunning(snapId)) {\n        await this.stopSnap(snapId, SnapStatusEvents.Stop);\n      }\n\n      this.#transition(snapId, SnapStatusEvents.Update);\n\n      this.#set({\n        origin,\n        id: snapId,\n        files: newSnap,\n        isUpdate: true,\n      });\n\n      this.#updatePermissions({\n        snapId,\n        unusedPermissions,\n        newPermissions: approvedNewPermissions,\n        requestData,\n      });\n\n      if (manifest.initialConnections) {\n        this.#handleInitialConnections(\n          snapId,\n          oldManifest.initialConnections ?? null,\n          manifest.initialConnections,\n        );\n      }\n\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.permissions.revoked = unusedPermissions;\n        rollbackSnapshot.permissions.granted = approvedNewPermissions;\n        rollbackSnapshot.permissions.requestData = requestData;\n      }\n\n      const sourceCode = sourceCodeFile.toString();\n\n      assert(\n        typeof sourceCode === 'string' && sourceCode.length > 0,\n        `Invalid source code for snap \"${snapId}\".`,\n      );\n\n      try {\n        await this.#startSnap({ snapId, sourceCode });\n      } catch {\n        throw new Error(`Snap ${snapId} crashed with updated source code.`);\n      }\n\n      const truncatedSnap = this.getTruncatedExpect(snapId);\n\n      if (emitEvent) {\n        this.messagingSystem.publish(\n          'SnapController:snapUpdated',\n          truncatedSnap,\n          snap.version,\n          origin,\n        );\n      }\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_UPDATE,\n      });\n\n      return truncatedSnap;\n    } catch (error) {\n      logError(`Error when updating ${snapId},`, error);\n\n      const errorString =\n        error instanceof Error ? error.message : error.toString();\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        error: errorString,\n        type: SNAP_APPROVAL_UPDATE,\n      });\n\n      this.messagingSystem.publish(\n        'SnapController:snapInstallFailed',\n        snapId,\n        origin,\n        true,\n        errorString,\n      );\n\n      throw error;\n    }\n  }\n\n  async #resolveAllowlistVersion(\n    snapId: SnapId,\n    versionRange: SemVerRange,\n  ): Promise<SemVerRange> {\n    return await this.messagingSystem.call(\n      'SnapsRegistry:resolveVersion',\n      snapId,\n      versionRange,\n    );\n  }\n\n  /**\n   * Get metadata for the given snap ID.\n   *\n   * @param snapId - The ID of the snap to get metadata for.\n   * @returns The metadata for the given snap ID, or `null` if the snap is not\n   * verified.\n   */\n  async getRegistryMetadata(\n    snapId: SnapId,\n  ): Promise<SnapsRegistryMetadata | null> {\n    return await this.messagingSystem.call('SnapsRegistry:getMetadata', snapId);\n  }\n\n  /**\n   * Returns a promise representing the complete installation of the requested snap.\n   * If the snap is already being installed, the previously pending promise will be returned.\n   *\n   * @param args - Object containing the snap id and either the URL of the snap's manifest,\n   * or the snap's manifest and source code. The object may also optionally contain a target\n   * version.\n   * @returns The resulting snap object.\n   */\n  async #add(args: AddSnapArgs): Promise<PersistedSnap> {\n    const { id: snapId, location, versionRange } = args;\n\n    this.#setupRuntime(snapId);\n    const runtime = this.#getRuntimeExpect(snapId);\n    if (!runtime.installPromise) {\n      log(`Adding snap: ${snapId}`);\n\n      // If fetching and setting the snap succeeds, this property will be set\n      // to null in the authorize() method.\n      runtime.installPromise = (async () => {\n        const fetchedSnap = await fetchSnap(snapId, location);\n        const manifest = fetchedSnap.manifest.result;\n        if (!satisfiesVersionRange(manifest.version, versionRange)) {\n          throw new Error(\n            `Version mismatch. Manifest for \"${snapId}\" specifies version \"${manifest.version}\" which doesn't satisfy requested version range \"${versionRange}\".`,\n          );\n        }\n\n        await this.#assertIsInstallAllowed(snapId, {\n          version: manifest.version,\n          checksum: manifest.source.shasum,\n        });\n\n        return this.#set({\n          ...args,\n          files: fetchedSnap,\n          id: snapId,\n        });\n      })();\n    }\n\n    try {\n      return await runtime.installPromise;\n    } catch (error) {\n      // Reset promise so users can retry installation in case the problem is\n      // temporary.\n      runtime.installPromise = null;\n      throw error;\n    }\n  }\n\n  async #startSnap(snapData: { snapId: SnapId; sourceCode: string }) {\n    const { snapId } = snapData;\n    if (this.isRunning(snapId)) {\n      throw new Error(`Snap \"${snapId}\" is already started.`);\n    }\n\n    try {\n      const runtime = this.#getRuntimeExpect(snapId);\n      const result = await this.#executeWithTimeout(\n        this.messagingSystem.call('ExecutionService:executeSnap', {\n          ...snapData,\n          endowments: await this.#getEndowments(snapId),\n        }),\n      );\n      this.#transition(snapId, SnapStatusEvents.Start);\n      // We treat the initialization of the snap as the first request, for idle timing purposes.\n      runtime.lastRequest = Date.now();\n      return result;\n    } catch (error) {\n      await this.#terminateSnap(snapId);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the names of all endowments that will be added to the Snap's\n   * Compartment when it executes. These should be the names of global\n   * JavaScript APIs accessible in the root realm of the execution environment.\n   *\n   * Throws an error if the endowment getter for a permission returns a truthy\n   * value that is not an array of strings.\n   *\n   * @param snapId - The id of the snap whose SES endowments to get.\n   * @returns An array of the names of the endowments.\n   */\n  async #getEndowments(snapId: string): Promise<string[]> {\n    let allEndowments: string[] = [];\n\n    for (const permissionName of this.#environmentEndowmentPermissions) {\n      if (\n        this.messagingSystem.call(\n          'PermissionController:hasPermission',\n          snapId,\n          permissionName,\n        )\n      ) {\n        const endowments = await this.messagingSystem.call(\n          'PermissionController:getEndowments',\n          snapId,\n          permissionName,\n        );\n\n        if (endowments) {\n          // We don't have any guarantees about the type of the endowments\n          // value, so we have to guard at runtime.\n          if (\n            !Array.isArray(endowments) ||\n            endowments.some((value) => typeof value !== 'string')\n          ) {\n            throw new Error('Expected an array of string endowment names.');\n          }\n\n          allEndowments = allEndowments.concat(endowments as string[]);\n        }\n      }\n    }\n\n    const dedupedEndowments = [\n      ...new Set([...DEFAULT_ENDOWMENTS, ...allEndowments]),\n    ];\n\n    if (\n      dedupedEndowments.length <\n      // This is a bug in TypeScript: https://github.com/microsoft/TypeScript/issues/48313\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      DEFAULT_ENDOWMENTS.length + allEndowments.length\n    ) {\n      logError(\n        `Duplicate endowments found for ${snapId}. Default endowments should not be requested.`,\n        allEndowments,\n      );\n    }\n    return dedupedEndowments;\n  }\n\n  /**\n   * Sets a snap in state. Called when a snap is installed or updated. Performs\n   * various validation checks on the received arguments, and will throw if\n   * validation fails.\n   *\n   * The snap will be enabled and unblocked by the time this method returns,\n   * regardless of its previous state.\n   *\n   * See {@link SnapController.add} and {@link SnapController.updateSnap} for\n   * usage.\n   *\n   * @param args - The add snap args.\n   * @returns The resulting snap object.\n   */\n  #set(args: SetSnapArgs): PersistedSnap {\n    const {\n      id: snapId,\n      origin,\n      files,\n      isUpdate = false,\n      removable,\n      preinstalled,\n    } = args;\n\n    const {\n      manifest,\n      sourceCode: sourceCodeFile,\n      svgIcon,\n      auxiliaryFiles: rawAuxiliaryFiles,\n      localizationFiles,\n    } = files;\n\n    assertIsSnapManifest(manifest.result);\n    const { version, proposedName } = manifest.result;\n\n    const sourceCode = sourceCodeFile.toString();\n\n    assert(\n      typeof sourceCode === 'string' && sourceCode.length > 0,\n      `Invalid source code for snap \"${snapId}\".`,\n    );\n\n    const auxiliaryFiles = rawAuxiliaryFiles.map((file) => {\n      assert(typeof file.data.base64 === 'string');\n      return {\n        path: file.path,\n        value: file.data.base64,\n      };\n    });\n\n    const snapsState = this.state.snaps;\n\n    const existingSnap = snapsState[snapId];\n\n    const previousVersionHistory = existingSnap?.versionHistory ?? [];\n    const versionHistory = [\n      ...previousVersionHistory,\n      {\n        version,\n        date: Date.now(),\n        origin,\n      },\n    ];\n\n    const snap: Snap = {\n      // Restore relevant snap state if it exists\n      ...existingSnap,\n\n      // Note that the snap will be unblocked and enabled, regardless of its\n      // previous state.\n      blocked: false,\n      enabled: true,\n\n      removable,\n      preinstalled,\n\n      id: snapId,\n      initialPermissions: manifest.result.initialPermissions,\n      manifest: manifest.result,\n      status: this.#statusMachine.config.initial as StatusStates['value'],\n      sourceCode,\n      version,\n      versionHistory,\n      auxiliaryFiles,\n      localizationFiles: localizationFiles.map((file) => file.result),\n    };\n\n    // If the snap was blocked, it isn't any longer\n    delete snap.blockInformation;\n\n    // store the snap back in state\n    const { inversePatches } = this.update((state: any) => {\n      state.snaps[snapId] = snap;\n    });\n\n    // checking for isUpdate here as this function is also used in\n    // the install flow, we do not care to create snapshots for installs\n    if (isUpdate) {\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.statePatches = inversePatches;\n      }\n    }\n\n    this.messagingSystem.call('SubjectMetadataController:addSubjectMetadata', {\n      subjectType: SubjectType.Snap,\n      name: proposedName,\n      origin: snap.id,\n      version,\n      svgIcon: svgIcon?.toString() ?? null,\n    });\n\n    return { ...snap, sourceCode };\n  }\n\n  #validateSnapPermissions(\n    processedPermissions: Record<string, Pick<PermissionConstraint, 'caveats'>>,\n  ) {\n    const permissionKeys = Object.keys(processedPermissions);\n    const handlerPermissions = Array.from(\n      new Set(Object.values(handlerEndowments)),\n    );\n\n    assert(\n      permissionKeys.some((key) => handlerPermissions.includes(key)),\n      `A snap must request at least one of the following permissions: ${handlerPermissions.join(\n        ', ',\n      )}.`,\n    );\n\n    const excludedPermissionErrors = permissionKeys.reduce<string[]>(\n      (errors, permission) => {\n        if (hasProperty(this.#excludedPermissions, permission)) {\n          errors.push(this.#excludedPermissions[permission]);\n        }\n\n        return errors;\n      },\n      [],\n    );\n\n    assert(\n      excludedPermissionErrors.length === 0,\n      `One or more permissions are not allowed:\\n${excludedPermissionErrors.join(\n        '\\n',\n      )}`,\n    );\n  }\n\n  /**\n   * Initiates a request for the given snap's initial permissions.\n   * Must be called in order. See processRequestedSnap.\n   *\n   * This function is not hash private yet because of tests.\n   *\n   * @param snapId - The id of the Snap.\n   * @param pendingApproval - Pending approval to update.\n   * @returns The snap's approvedPermissions.\n   */\n  private async authorize(\n    snapId: SnapId,\n    pendingApproval: PendingApproval,\n  ): Promise<void> {\n    log(`Authorizing snap: ${snapId}`);\n    const snapsState = this.state.snaps;\n    const snap = snapsState[snapId];\n    const { initialPermissions } = snap;\n\n    try {\n      const processedPermissions = processSnapPermissions(initialPermissions);\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        permissions: processedPermissions,\n      });\n\n      const { permissions: approvedPermissions, ...requestData } =\n        (await pendingApproval.promise) as PermissionsRequest;\n\n      this.#updatePermissions({\n        snapId,\n        newPermissions: approvedPermissions,\n        requestData,\n      });\n\n      if (snap.manifest.initialConnections) {\n        this.#handleInitialConnections(\n          snapId,\n          null,\n          snap.manifest.initialConnections,\n        );\n      }\n    } finally {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.installPromise = null;\n    }\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.#timeoutForLastRequestStatus) {\n      clearTimeout(this.#timeoutForLastRequestStatus);\n    }\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n\n    this.messagingSystem.clearEventSubscriptions(\n      'SnapController:snapInstalled',\n    );\n\n    this.messagingSystem.clearEventSubscriptions('SnapController:snapUpdated');\n    /* eslint-enable @typescript-eslint/unbound-method */\n  }\n\n  /**\n   * Passes a JSON-RPC request object to the RPC handler function of a snap.\n   *\n   * @param options - A bag of options.\n   * @param options.snapId - The ID of the recipient snap.\n   * @param options.origin - The origin of the RPC request.\n   * @param options.handler - The handler to trigger on the snap for the request.\n   * @param options.request - The JSON-RPC request object.\n   * @returns The result of the JSON-RPC request.\n   */\n  async handleRequest({\n    snapId,\n    origin,\n    handler: handlerType,\n    request: rawRequest,\n  }: SnapRpcHookArgs & { snapId: SnapId }): Promise<unknown> {\n    const request = {\n      jsonrpc: '2.0',\n      id: nanoid(),\n      ...rawRequest,\n    };\n\n    assertIsJsonRpcRequest(request);\n\n    const permissionName = handlerEndowments[handlerType];\n    const hasPermission = this.messagingSystem.call(\n      'PermissionController:hasPermission',\n      snapId,\n      permissionName,\n    );\n\n    if (!hasPermission) {\n      throw new Error(\n        `Snap \"${snapId}\" is not permitted to use \"${permissionName}\".`,\n      );\n    }\n\n    if (\n      permissionName === SnapEndowments.Rpc ||\n      permissionName === SnapEndowments.Keyring\n    ) {\n      const subject = this.messagingSystem.call(\n        'SubjectMetadataController:getSubjectMetadata',\n        origin,\n      );\n\n      const permissions = this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        snapId,\n      );\n\n      const handlerPermissions = permissions?.[permissionName];\n      assert(handlerPermissions);\n\n      const origins =\n        permissionName === SnapEndowments.Rpc\n          ? getRpcCaveatOrigins(handlerPermissions)\n          : getKeyringCaveatOrigins(handlerPermissions);\n      assert(origins);\n\n      if (\n        !isOriginAllowed(\n          origins,\n          subject?.subjectType ?? SubjectType.Website,\n          origin,\n        )\n      ) {\n        throw new Error(\n          `Snap \"${snapId}\" is not permitted to handle requests from \"${origin}\".`,\n        );\n      }\n    }\n\n    const handler = await this.#getRpcRequestHandler(snapId);\n    if (!handler) {\n      throw new Error(\n        `Snap RPC message handler not found for snap \"${snapId}\".`,\n      );\n    }\n\n    return handler({ origin, handler: handlerType, request });\n  }\n\n  /**\n   * Gets the RPC message handler for the given snap.\n   *\n   * @param snapId - The id of the Snap whose message handler to get.\n   * @returns The RPC handler for the given snap.\n   */\n  #getRpcRequestHandler(snapId: SnapId): SnapRpcHook {\n    const runtime = this.#getRuntimeExpect(snapId);\n    const existingHandler = runtime.rpcHandler;\n    if (existingHandler) {\n      return existingHandler;\n    }\n\n    const requestQueue = new RequestQueue(5);\n    // We need to set up this promise map to map snapIds to their respective startPromises,\n    // because otherwise we would lose context on the correct startPromise.\n    const startPromises = new Map<string, Promise<void>>();\n\n    const rpcHandler = async ({\n      origin,\n      handler: handlerType,\n      request,\n    }: SnapRpcHookArgs) => {\n      if (this.state.snaps[snapId].enabled === false) {\n        throw new Error(`Snap \"${snapId}\" is disabled.`);\n      }\n\n      if (this.state.snaps[snapId].status === SnapStatus.Installing) {\n        throw new Error(\n          `Snap \"${snapId}\" is currently being installed. Please try again later.`,\n        );\n      }\n\n      if (!this.isRunning(snapId)) {\n        let localStartPromise = startPromises.get(snapId);\n        if (!localStartPromise) {\n          localStartPromise = this.startSnap(snapId);\n          startPromises.set(snapId, localStartPromise);\n        } else if (requestQueue.get(origin) >= requestQueue.maxQueueSize) {\n          throw new Error(\n            'Exceeds maximum number of requests waiting to be resolved, please try again.',\n          );\n        }\n\n        requestQueue.increment(origin);\n        try {\n          await localStartPromise;\n        } finally {\n          requestQueue.decrement(origin);\n          // Only delete startPromise for a snap if its value hasn't changed\n          if (startPromises.get(snapId) === localStartPromise) {\n            startPromises.delete(snapId);\n          }\n        }\n      }\n\n      const timer = new Timer(this.maxRequestTime);\n      this.#recordSnapRpcRequestStart(snapId, request.id, timer);\n\n      const handleRpcRequestPromise = this.messagingSystem.call(\n        'ExecutionService:handleRpcRequest',\n        snapId,\n        { origin, handler: handlerType, request },\n      );\n\n      // This will either get the result or reject due to the timeout.\n      try {\n        const result = await this.#executeWithTimeout(\n          handleRpcRequestPromise,\n          timer,\n        );\n\n        await this.#assertSnapRpcRequestResult(handlerType, result);\n\n        return result;\n      } catch (error) {\n        const [jsonRpcError, handled] = unwrapError(error);\n\n        if (!handled) {\n          await this.stopSnap(snapId, SnapStatusEvents.Crash);\n        }\n\n        throw jsonRpcError;\n      } finally {\n        this.#recordSnapRpcRequestFinish(snapId, request.id);\n      }\n    };\n\n    runtime.rpcHandler = rpcHandler;\n    return rpcHandler;\n  }\n\n  async #triggerPhishingListUpdate() {\n    return this.messagingSystem.call('PhishingController:maybeUpdateState');\n  }\n\n  #checkPhishingList(origin: string) {\n    return this.messagingSystem.call('PhishingController:testOrigin', origin)\n      .result;\n  }\n\n  /**\n   * Asserts that the returned result of a Snap RPC call is the expected shape.\n   *\n   * @param handlerType - The handler type of the RPC Request.\n   * @param result - The result of the RPC request.\n   */\n  async #assertSnapRpcRequestResult(handlerType: HandlerType, result: unknown) {\n    switch (handlerType) {\n      case HandlerType.OnTransaction: {\n        assertStruct(result, OnTransactionResponseStruct);\n        // Null is an allowed return value here\n        if (result === null) {\n          return;\n        }\n\n        await this.#triggerPhishingListUpdate();\n\n        validateComponentLinks(\n          result.content,\n          this.#checkPhishingList.bind(this),\n        );\n        break;\n      }\n      case HandlerType.OnSignature: {\n        assertStruct(result, OnSignatureResponseStruct);\n        // Null is an allowed return value here\n        if (result === null) {\n          return;\n        }\n\n        await this.#triggerPhishingListUpdate();\n\n        validateComponentLinks(\n          result.content,\n          this.#checkPhishingList.bind(this),\n        );\n        break;\n      }\n      case HandlerType.OnHomePage:\n        assertStruct(result, OnHomePageResponseStruct);\n\n        await this.#triggerPhishingListUpdate();\n\n        validateComponentLinks(\n          result.content,\n          this.#checkPhishingList.bind(this),\n        );\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Awaits the specified promise and rejects if the promise doesn't resolve\n   * before the timeout.\n   *\n   * @param promise - The promise to await.\n   * @param timer - An optional timer object to control the timeout.\n   * @returns The result of the promise or rejects if the promise times out.\n   * @template PromiseValue - The value of the Promise.\n   */\n  async #executeWithTimeout<PromiseValue>(\n    promise: Promise<PromiseValue>,\n    timer?: Timer,\n  ): Promise<PromiseValue> {\n    const result = await withTimeout(promise, timer ?? this.maxRequestTime);\n    if (result === hasTimedOut) {\n      throw new Error('The request timed out.');\n    }\n    return result;\n  }\n\n  #recordSnapRpcRequestStart(snapId: SnapId, requestId: unknown, timer: Timer) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests.push({ requestId, timer });\n    runtime.lastRequest = null;\n  }\n\n  #recordSnapRpcRequestFinish(snapId: SnapId, requestId: unknown) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests = runtime.pendingInboundRequests.filter(\n      (request) => request.requestId !== requestId,\n    );\n\n    if (runtime.pendingInboundRequests.length === 0) {\n      runtime.lastRequest = Date.now();\n    }\n  }\n\n  /**\n   * Retrieves the rollback snapshot of a snap.\n   *\n   * @param snapId - The snap id.\n   * @returns A `RollbackSnapshot` or `undefined` if one doesn't exist.\n   */\n  #getRollbackSnapshot(snapId: SnapId): RollbackSnapshot | undefined {\n    return this.#rollbackSnapshots.get(snapId);\n  }\n\n  /**\n   * Creates a `RollbackSnapshot` that is used to help ensure\n   * atomicity in multiple snap updates.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If the snap exists before creation or if creation fails.\n   * @returns A `RollbackSnapshot`.\n   */\n  #createRollbackSnapshot(snapId: SnapId): RollbackSnapshot {\n    assert(\n      this.#rollbackSnapshots.get(snapId) === undefined,\n      new Error(`Snap \"${snapId}\" rollback snapshot already exists.`),\n    );\n\n    this.#rollbackSnapshots.set(snapId, {\n      statePatches: [],\n      permissions: {},\n      newVersion: '',\n    });\n\n    const newRollbackSnapshot = this.#rollbackSnapshots.get(snapId);\n\n    assert(\n      newRollbackSnapshot !== undefined,\n      new Error(`Snapshot creation failed for ${snapId}.`),\n    );\n    return newRollbackSnapshot;\n  }\n\n  /**\n   * Rolls back a snap to its previous state, permissions\n   * and source code based on the `RollbackSnapshot` that\n   * is captured during the update process. After rolling back,\n   * the function also emits an event indicating that the\n   * snap has been rolled back and it clears the snapshot\n   * for that snap.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If a snapshot does not exist.\n   */\n  async #rollbackSnap(snapId: SnapId) {\n    const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n    if (!rollbackSnapshot) {\n      throw new Error('A snapshot does not exist for this snap.');\n    }\n\n    await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    // Always set to stopped even if it wasn't running initially\n    if (this.get(snapId)?.status !== SnapStatus.Stopped) {\n      this.#transition(snapId, SnapStatusEvents.Stop);\n    }\n\n    const { statePatches, permissions } = rollbackSnapshot;\n\n    if (statePatches?.length) {\n      this.applyPatches(statePatches);\n    }\n\n    // Reset snap status, as we may have been in another state when we stored state patches\n    // But now we are 100% in a stopped state\n    if (this.get(snapId)?.status !== SnapStatus.Stopped) {\n      this.update((state) => {\n        state.snaps[snapId].status = SnapStatus.Stopped;\n      });\n    }\n\n    this.#updatePermissions({\n      snapId,\n      unusedPermissions: permissions.granted,\n      newPermissions: permissions.revoked,\n      requestData: permissions.requestData,\n    });\n\n    const truncatedSnap = this.getTruncatedExpect(snapId);\n\n    this.messagingSystem.publish(\n      'SnapController:snapRolledback',\n      truncatedSnap,\n      rollbackSnapshot.newVersion,\n    );\n\n    this.#rollbackSnapshots.delete(snapId);\n  }\n\n  /**\n   * Iterates through an array of snap ids\n   * and calls `rollbackSnap` on them.\n   *\n   * @param snapIds - An array of snap ids.\n   */\n  async #rollbackSnaps(snapIds: SnapId[]) {\n    for (const snapId of snapIds) {\n      await this.#rollbackSnap(snapId);\n    }\n  }\n\n  #getRuntime(snapId: SnapId): SnapRuntimeData | undefined {\n    return this.#snapsRuntimeData.get(snapId);\n  }\n\n  #getRuntimeExpect(snapId: SnapId): SnapRuntimeData {\n    const runtime = this.#getRuntime(snapId);\n    assert(\n      runtime !== undefined,\n      new Error(`Snap \"${snapId}\" runtime data not found`),\n    );\n    return runtime;\n  }\n\n  #setupRuntime(snapId: SnapId) {\n    if (this.#snapsRuntimeData.has(snapId)) {\n      return;\n    }\n\n    const snap = this.get(snapId);\n    const interpreter = interpret(this.#statusMachine);\n    interpreter.start({\n      context: { snapId },\n      value:\n        snap?.status ??\n        (this.#statusMachine.config.initial as StatusStates['value']),\n    });\n\n    forceStrict(interpreter);\n\n    this.#snapsRuntimeData.set(snapId, {\n      lastRequest: null,\n      rpcHandler: null,\n      installPromise: null,\n      activeReferences: 0,\n      pendingInboundRequests: [],\n      pendingOutboundRequests: 0,\n      interpreter,\n    });\n  }\n\n  #calculatePermissionsChange(\n    snapId: SnapId,\n    desiredPermissionsSet: Record<\n      string,\n      Pick<PermissionConstraint, 'caveats'>\n    >,\n  ): {\n    newPermissions: Record<string, Pick<PermissionConstraint, 'caveats'>>;\n    unusedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n    approvedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n  } {\n    const oldPermissions =\n      this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        snapId,\n      ) ?? {};\n\n    const newPermissions = setDiff(desiredPermissionsSet, oldPermissions);\n    // TODO(ritave): The assumption that these are unused only holds so long as we do not\n    //               permit dynamic permission requests.\n    const unusedPermissions = setDiff(oldPermissions, desiredPermissionsSet);\n\n    // It's a Set Intersection of oldPermissions and desiredPermissionsSet\n    // oldPermissions ∖ (oldPermissions ∖ desiredPermissionsSet) ⟺ oldPermissions ∩ desiredPermissionsSet\n    const approvedPermissions = setDiff(oldPermissions, unusedPermissions);\n\n    return { newPermissions, unusedPermissions, approvedPermissions };\n  }\n\n  /**\n   * Updates the permissions for a snap following an install, update or rollback.\n   *\n   * Grants newly requested permissions and revokes unused/revoked permissions.\n   *\n   * @param args - An options bag.\n   * @param args.snapId - The snap ID.\n   * @param args.newPermissions - New permissions to be granted.\n   * @param args.unusedPermissions - Unused permissions to be revoked.\n   * @param args.requestData - Optional request data from an approval.\n   */\n  #updatePermissions({\n    snapId,\n    unusedPermissions = {},\n    newPermissions = {},\n    requestData,\n  }: {\n    snapId: SnapId;\n    newPermissions?:\n      | RequestedPermissions\n      | Record<string, Pick<PermissionConstraint, 'caveats'>>;\n    unusedPermissions?:\n      | RequestedPermissions\n      | SubjectPermissions<ValidPermission<string, Caveat<string, any>>>;\n    requestData?: Record<string, unknown>;\n  }) {\n    const unusedPermissionsKeys = Object.keys(unusedPermissions);\n    if (isNonEmptyArray(unusedPermissionsKeys)) {\n      this.messagingSystem.call('PermissionController:revokePermissions', {\n        [snapId]: unusedPermissionsKeys,\n      });\n    }\n\n    if (isNonEmptyArray(Object.keys(newPermissions))) {\n      this.messagingSystem.call('PermissionController:grantPermissions', {\n        approvedPermissions: newPermissions,\n        subject: { origin: snapId },\n        requestData,\n      });\n    }\n  }\n\n  /**\n   * Checks if a snap will pass version validation checks\n   * with the new version range that is requested. The first\n   * check that is done is to check if the existing snap version\n   * falls inside the requested range. If it does, we want to return\n   * false because we do not care to create a rollback snapshot in\n   * that scenario. The second check is to ensure that the current\n   * snap version is not greater than all possible versions in\n   * the requested version range. If it is, then we also want\n   * to return false in that scenario.\n   *\n   * @param snapId - The snap id.\n   * @param newVersionRange - The new version range being requsted.\n   * @returns `true` if validation checks pass and `false` if they do not.\n   */\n  #isValidUpdate(snapId: SnapId, newVersionRange: SemVerRange): boolean {\n    const existingSnap = this.getExpect(snapId);\n\n    if (satisfiesVersionRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    if (gtRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Call a lifecycle hook on a snap, if the snap has the\n   * `endowment:lifecycle-hooks` permission. If the snap does not have the\n   * permission, nothing happens.\n   *\n   * @param snapId - The snap ID.\n   * @param handler - The lifecycle hook to call. This should be one of the\n   * supported lifecycle hooks.\n   * @private\n   */\n  async #callLifecycleHook(snapId: SnapId, handler: HandlerType) {\n    const permissionName = handlerEndowments[handler];\n    const hasPermission = this.messagingSystem.call(\n      'PermissionController:hasPermission',\n      snapId,\n      permissionName,\n    );\n\n    if (!hasPermission) {\n      return;\n    }\n\n    await this.handleRequest({\n      snapId,\n      handler,\n      origin: '',\n      request: {\n        jsonrpc: '2.0',\n        method: handler,\n      },\n    });\n  }\n}\n"],"names":["BaseController","SubjectType","rpcErrors","WALLET_SNAP_PERMISSION_KEY","AuxiliaryFileEncoding","getErrorMessage","validateComponentLinks","assertIsSnapManifest","assertIsValidSnapId","DEFAULT_ENDOWMENTS","DEFAULT_REQUESTED_SNAP_VERSION","encodeAuxiliaryFile","HandlerType","isOriginAllowed","logError","normalizeRelative","OnTransactionResponseStruct","OnSignatureResponseStruct","resolveVersionRange","SnapCaveatType","SnapStatus","SnapStatusEvents","unwrapError","OnHomePageResponseStruct","getValidatedLocalizationFiles","VirtualFile","NpmSnapFileNames","assert","assertIsJsonRpcRequest","assertStruct","Duration","gtRange","gtVersion","hasProperty","inMilliseconds","isNonEmptyArray","isValidSemVerRange","satisfiesVersionRange","timeSince","createMachine","interpret","nanoid","forceStrict","validateMachine","log","fetchSnap","hasTimedOut","setDiff","withTimeout","handlerEndowments","SnapEndowments","getKeyringCaveatOrigins","getRpcCaveatOrigins","detectSnapLocation","processSnapPermissions","SnapsRegistryStatus","RequestQueue","Timer","controllerName","SNAP_APPROVAL_INSTALL","SNAP_APPROVAL_UPDATE","SNAP_APPROVAL_RESULT","TRUNCATED_SNAP_PROPERTIES","Set","defaultState","snaps","snapStates","unencryptedSnapStates","truncateSnap","snap","truncatedSnap","Object","keys","reduce","serialized","key","has","name","SnapController","updateBlockedSnaps","messagingSystem","call","blockedSnaps","values","state","blockListArg","id","version","checksum","manifest","source","shasum","Promise","all","entries","map","snapId","status","reason","Blocked","blockSnap","unblockSnap","_onUnhandledSnapError","_error","stopSnap","Crash","catch","stopSnapError","_onOutboundRequest","runtime","getRuntimeExpect","pendingInboundRequests","filter","pendingRequest","timer","forEach","pause","pendingOutboundRequests","_onOutboundResponse","resume","startSnap","enabled","Error","sourceCode","enableSnap","getExpect","blocked","update","publish","getTruncatedExpect","disableSnap","isRunning","Stop","statusEvent","getRuntime","lastRequest","closeAllConnections","terminateSnap","transition","Boolean","get","undefined","getTruncated","updateSnapState","newSnapState","encrypted","clearSnapState","getSnapState","getSnapFile","path","encoding","Base64","normalizedPath","value","auxiliaryFiles","find","file","clearState","snapIds","revokeAllSnapPermissions","removeSnap","removeSnaps","Array","isArray","removable","truncated","removeSnapFromSubjects","snapsRuntimeData","delete","Installing","removeSnapFromSubject","origin","subjectPermissions","snapIdsCaveat","caveats","caveat","type","SnapIds","caveatHasSnap","newCaveatValue","length","revokeDynamicSnapPermissions","permissionNames","every","permissionName","dynamicPermissions","includes","incrementActiveReferences","activeReferences","decrementActiveReferences","getAllSnaps","getPermittedSnaps","permissions","permittedSnaps","installSnaps","requestedSnaps","result","pendingUpdates","pendingInstalls","rawVersion","error","invalidParams","location","versionRange","fetch","fetchFunction","allowLocal","featureFlags","allowLocalSnaps","resolveVersion","range","requireAllowlist","resolveAllowlistVersion","isUpdate","shouldAlwaysReload","isValidUpdate","existingSnap","push","oldVersion","rollbackSnapshot","getRollbackSnapshot","createRollbackSnapshot","newVersion","processRequestedSnap","rollbackSnapshots","installed","snapshottedSnaps","snapsToRollback","rollbackSnaps","updateSnap","pendingApproval","createApproval","add","authorize","updateApproval","loading","errorString","message","toString","newVersionRange","emitEvent","oldManifest","newSnap","sourceCodeFile","manifestFile","assertIsInstallAllowed","processedPermissions","initialPermissions","validateSnapPermissions","newPermissions","unusedPermissions","approvedPermissions","calculatePermissionsChange","approvedNewPermissions","requestData","promise","Update","set","files","updatePermissions","initialConnections","handleInitialConnections","revoked","granted","getRegistryMetadata","snapsState","installPromise","destroy","timeoutForLastRequestStatus","clearTimeout","unsubscribe","clearEventSubscriptions","handleRequest","handler","handlerType","request","rawRequest","jsonrpc","hasPermission","Rpc","Keyring","subject","handlerPermissions","origins","subjectType","Website","getRpcRequestHandler","constructor","messenger","environmentEndowmentPermissions","excludedPermissions","idleTimeCheckInterval","Second","maxIdleTime","maxRequestTime","globalThis","bind","detectSnapLocationFunction","preinstalledSnaps","metadata","persist","anonymous","Stopped","memo","Map","pollForLastRequestStatus","subscribe","callLifecycleHook","OnInstall","OnUpdate","initializeStateMachine","registerMessageHandlers","handlePreinstalledSnaps","setupRuntime","disableGuard","statusConfig","initial","states","on","Start","target","Running","cond","Updating","Crashed","statusMachine","registerActionHandler","args","isAlreadyInstalled","preinstalled","Manifest","JSON","stringify","virtualFiles","filePath","iconPath","npm","svgIcon","localizationFiles","locales","validatedLocalizationFiles","filesObject","setTimeout","stopSnapsLastRequestPastMax","blockedSnapInfo","blockInformation","snapInfo","results","explanation","Verified","_snapId","event","interpreter","send","previousInitialConnections","revokedInitialConnections","addSnapToSubject","existingCaveat","subjectHasSnap","subjects","dappOrigin","requestState","fetchedSnap","snapData","executeWithTimeout","endowments","getEndowments","Date","now","allEndowments","some","concat","dedupedEndowments","rawAuxiliaryFiles","proposedName","data","base64","previousVersionHistory","versionHistory","date","config","inversePatches","statePatches","Snap","permissionKeys","from","join","excludedPermissionErrors","errors","permission","existingHandler","rpcHandler","requestQueue","startPromises","localStartPromise","maxQueueSize","increment","decrement","recordSnapRpcRequestStart","handleRpcRequestPromise","assertSnapRpcRequestResult","jsonRpcError","handled","recordSnapRpcRequestFinish","OnTransaction","triggerPhishingListUpdate","content","checkPhishingList","OnSignature","OnHomePage","requestId","newRollbackSnapshot","applyPatches","rollbackSnap","start","context","desiredPermissionsSet","oldPermissions","unusedPermissionsKeys","method"],"mappings":"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"}