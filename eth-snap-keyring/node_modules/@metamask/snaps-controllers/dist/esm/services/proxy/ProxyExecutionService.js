function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
import { nanoid } from 'nanoid';
import { AbstractExecutionService } from '../AbstractExecutionService';
import { ProxyPostMessageStream } from '../ProxyPostMessageStream';
var _stream = /*#__PURE__*/ new WeakMap();
export class ProxyExecutionService extends AbstractExecutionService {
    /**
   * Send a termination command to the proxy stream.
   *
   * @param job - The job to terminate.
   */ async terminateJob(job) {
        // The `AbstractExecutionService` will have already closed the job stream,
        // so we write to the runtime stream directly.
        _class_private_field_get(this, _stream).write({
            jobId: job.id,
            data: {
                jsonrpc: '2.0',
                method: 'terminateJob',
                id: nanoid()
            }
        });
    }
    /**
   * Create a new stream for the specified job. This wraps the root stream
   * in a stream specific to the job.
   *
   * @param jobId - The job ID.
   */ async initEnvStream(jobId) {
        const stream = new ProxyPostMessageStream({
            stream: _class_private_field_get(this, _stream),
            jobId
        });
        return {
            worker: jobId,
            stream
        };
    }
    /**
   * Create a new proxy execution service.
   *
   * @param args - The constructor arguments.
   * @param args.messenger - The messenger to use for communication with the
   * `SnapController`.
   * @param args.setupSnapProvider - The function to use to set up the snap
   * provider.
   * @param args.stream - The stream to use for communicating with the proxy
   * executor.
   */ constructor({ stream, messenger, setupSnapProvider }){
        super({
            messenger,
            setupSnapProvider
        });
        _class_private_field_init(this, _stream, {
            writable: true,
            value: void 0
        });
        _class_private_field_set(this, _stream, stream);
    }
}

//# sourceMappingURL=ProxyExecutionService.js.map