{"version":3,"sources":["../../../src/restricted/manageState.ts"],"sourcesContent":["import type {\n  PermissionSpecificationBuilder,\n  RestrictedMethodOptions,\n  ValidPermissionSpecification,\n} from '@metamask/permission-controller';\nimport { PermissionType, SubjectType } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { ManageStateParams, ManageStateResult } from '@metamask/snaps-sdk';\nimport { ManageStateOperation } from '@metamask/snaps-sdk';\nimport { STATE_ENCRYPTION_MAGIC_VALUE, parseJson } from '@metamask/snaps-utils';\nimport type { Json, NonEmptyArray, Hex } from '@metamask/utils';\nimport { isObject, getJsonSize, assert, isValidJson } from '@metamask/utils';\n\nimport type { MethodHooksObject } from '../utils';\nimport { deriveEntropy } from '../utils';\n\n// The salt used for SIP-6-based entropy derivation.\nexport const STATE_ENCRYPTION_SALT = 'snap_manageState encryption';\n\nconst methodName = 'snap_manageState';\n\nexport type ManageStateMethodHooks = {\n  /**\n   * @returns The mnemonic of the user's primary keyring.\n   */\n  getMnemonic: () => Promise<Uint8Array>;\n\n  /**\n   * Waits for the extension to be unlocked.\n   *\n   * @returns A promise that resolves once the extension is unlocked.\n   */\n  getUnlockPromise: (shouldShowUnlockRequest: boolean) => Promise<void>;\n\n  /**\n   * A function that clears the state of the requesting Snap.\n   */\n  clearSnapState: (snapId: string, encrypted: boolean) => void;\n\n  /**\n   * A function that gets the encrypted state of the requesting Snap.\n   *\n   * @returns The current state of the Snap.\n   */\n  getSnapState: (snapId: string, encrypted: boolean) => string;\n\n  /**\n   * A function that updates the state of the requesting Snap.\n   *\n   * @param newState - The new state of the Snap.\n   */\n  updateSnapState: (\n    snapId: string,\n    newState: string,\n    encrypted: boolean,\n  ) => void;\n\n  /**\n   * Encrypts data with a key. This is assumed to perform symmetric encryption.\n   *\n   * @param key - The key to use for encryption, in hexadecimal format.\n   * @param data - The JSON data to encrypt.\n   * @returns The ciphertext as a string. The format for this string is\n   * dependent on the implementation, but MUST be a string.\n   */\n  encrypt: (key: string, data: Json) => Promise<string>;\n\n  /**\n   * Decrypts data with a key. This is assumed to perform symmetric decryption.\n   *\n   * @param key - The key to use for decryption, in hexadecimal format.\n   * @param cipherText - The ciphertext to decrypt. The format for this string\n   * is dependent on the implementation, but MUST be a string.\n   * @returns The decrypted data as a JSON object.\n   */\n  decrypt: (key: Hex, cipherText: string) => Promise<unknown>;\n};\n\ntype ManageStateSpecificationBuilderOptions = {\n  allowedCaveats?: Readonly<NonEmptyArray<string>> | null;\n  methodHooks: ManageStateMethodHooks;\n};\n\ntype ManageStateSpecification = ValidPermissionSpecification<{\n  permissionType: PermissionType.RestrictedMethod;\n  targetName: typeof methodName;\n  methodImplementation: ReturnType<typeof getManageStateImplementation>;\n  allowedCaveats: Readonly<NonEmptyArray<string>> | null;\n}>;\n\n/**\n * The specification builder for the `snap_manageState` permission.\n * `snap_manageState` lets the Snap store and manage some of its state on\n * your device.\n *\n * @param options - The specification builder options.\n * @param options.allowedCaveats - The optional allowed caveats for the permission.\n * @param options.methodHooks - The RPC method hooks needed by the method implementation.\n * @returns The specification for the `snap_manageState` permission.\n */\nexport const specificationBuilder: PermissionSpecificationBuilder<\n  PermissionType.RestrictedMethod,\n  ManageStateSpecificationBuilderOptions,\n  ManageStateSpecification\n> = ({\n  allowedCaveats = null,\n  methodHooks,\n}: ManageStateSpecificationBuilderOptions) => {\n  return {\n    permissionType: PermissionType.RestrictedMethod,\n    targetName: methodName,\n    allowedCaveats,\n    methodImplementation: getManageStateImplementation(methodHooks),\n    subjectTypes: [SubjectType.Snap],\n  };\n};\n\nconst methodHooks: MethodHooksObject<ManageStateMethodHooks> = {\n  getMnemonic: true,\n  getUnlockPromise: true,\n  clearSnapState: true,\n  getSnapState: true,\n  updateSnapState: true,\n  encrypt: true,\n  decrypt: true,\n};\n\nexport const manageStateBuilder = Object.freeze({\n  targetName: methodName,\n  specificationBuilder,\n  methodHooks,\n} as const);\n\nexport const STORAGE_SIZE_LIMIT = 104857600; // In bytes (100MB)\n\ntype GetEncryptionKeyArgs = {\n  snapId: string;\n  mnemonicPhrase: Uint8Array;\n};\n\n/**\n * Get a deterministic encryption key to use for encrypting and decrypting the\n * state.\n *\n * This key should only be used for state encryption using `snap_manageState`.\n * To get other encryption keys, a different salt can be used.\n *\n * @param args - The encryption key args.\n * @param args.snapId - The ID of the snap to get the encryption key for.\n * @param args.mnemonicPhrase - The mnemonic phrase to derive the encryption key\n * from.\n * @returns The state encryption key.\n */\nexport async function getEncryptionKey({\n  mnemonicPhrase,\n  snapId,\n}: GetEncryptionKeyArgs) {\n  return await deriveEntropy({\n    mnemonicPhrase,\n    input: snapId,\n    salt: STATE_ENCRYPTION_SALT,\n    magic: STATE_ENCRYPTION_MAGIC_VALUE,\n  });\n}\n\ntype EncryptStateArgs = GetEncryptionKeyArgs & {\n  state: Json;\n  encryptFunction: ManageStateMethodHooks['encrypt'];\n};\n\n/**\n * Encrypt the state using a deterministic encryption algorithm, based on the\n * snap ID and mnemonic phrase.\n *\n * @param args - The encryption args.\n * @param args.state - The state to encrypt.\n * @param args.encryptFunction - The function to use for encrypting the state.\n * @param args.snapId - The ID of the snap to get the encryption key for.\n * @param args.mnemonicPhrase - The mnemonic phrase to derive the encryption key\n * from.\n * @returns The encrypted state.\n */\nasync function encryptState({\n  state,\n  encryptFunction,\n  ...keyArgs\n}: EncryptStateArgs) {\n  const encryptionKey = await getEncryptionKey(keyArgs);\n  return await encryptFunction(encryptionKey, state);\n}\n\ntype DecryptStateArgs = GetEncryptionKeyArgs & {\n  state: string;\n  decryptFunction: ManageStateMethodHooks['decrypt'];\n};\n\n/**\n * Decrypt the state using a deterministic decryption algorithm, based on the\n * snap ID and mnemonic phrase.\n *\n * @param args - The encryption args.\n * @param args.state - The state to decrypt.\n * @param args.decryptFunction - The function to use for decrypting the state.\n * @param args.snapId - The ID of the snap to get the encryption key for.\n * @param args.mnemonicPhrase - The mnemonic phrase to derive the encryption key\n * from.\n * @returns The encrypted state.\n */\nasync function decryptState({\n  state,\n  decryptFunction,\n  ...keyArgs\n}: DecryptStateArgs) {\n  try {\n    const encryptionKey = await getEncryptionKey(keyArgs);\n    const decryptedState = await decryptFunction(encryptionKey, state);\n\n    assert(isValidJson(decryptedState));\n\n    return decryptedState as Record<string, Json>;\n  } catch {\n    throw rpcErrors.internal({\n      message: 'Failed to decrypt snap state, the state must be corrupted.',\n    });\n  }\n}\n\n/**\n * Builds the method implementation for `snap_manageState`.\n *\n * @param hooks - The RPC method hooks.\n * @param hooks.clearSnapState - A function that clears the state stored for a\n * snap.\n * @param hooks.getSnapState - A function that fetches the persisted decrypted\n * state for a snap.\n * @param hooks.updateSnapState - A function that updates the state stored for a\n * snap.\n * @param hooks.getMnemonic - A function to retrieve the Secret Recovery Phrase\n * of the user.\n * @param hooks.getUnlockPromise - A function that resolves once the MetaMask\n * extension is unlocked and prompts the user to unlock their MetaMask if it is\n * locked.\n * @param hooks.encrypt - A function that encrypts the given state.\n * @param hooks.decrypt - A function that decrypts the given state.\n * @returns The method implementation which either returns `null` for a\n * successful state update/deletion or returns the decrypted state.\n * @throws If the params are invalid.\n */\nexport function getManageStateImplementation({\n  getMnemonic,\n  getUnlockPromise,\n  clearSnapState,\n  getSnapState,\n  updateSnapState,\n  encrypt,\n  decrypt,\n}: ManageStateMethodHooks) {\n  return async function manageState(\n    options: RestrictedMethodOptions<ManageStateParams>,\n  ): Promise<ManageStateResult> {\n    const {\n      params = {},\n      method,\n      context: { origin },\n    } = options;\n    const validatedParams = getValidatedParams(params, method);\n\n    // If the encrypted param is undefined or null we default to true.\n    const shouldEncrypt = validatedParams.encrypted ?? true;\n\n    // We only need to prompt the user when the mnemonic is needed\n    // which it isn't for the clear operation or unencrypted storage.\n    if (\n      shouldEncrypt &&\n      validatedParams.operation !== ManageStateOperation.ClearState\n    ) {\n      await getUnlockPromise(true);\n    }\n\n    switch (validatedParams.operation) {\n      case ManageStateOperation.ClearState:\n        clearSnapState(origin, shouldEncrypt);\n        return null;\n\n      case ManageStateOperation.GetState: {\n        const state = getSnapState(origin, shouldEncrypt);\n        if (state === null) {\n          return state;\n        }\n        return shouldEncrypt\n          ? await decryptState({\n              state,\n              decryptFunction: decrypt,\n              mnemonicPhrase: await getMnemonic(),\n              snapId: origin,\n            })\n          : parseJson<Record<string, Json>>(state);\n      }\n\n      case ManageStateOperation.UpdateState: {\n        const finalizedState = shouldEncrypt\n          ? await encryptState({\n              state: validatedParams.newState,\n              encryptFunction: encrypt,\n              mnemonicPhrase: await getMnemonic(),\n              snapId: origin,\n            })\n          : JSON.stringify(validatedParams.newState);\n\n        updateSnapState(origin, finalizedState, shouldEncrypt);\n        return null;\n      }\n\n      default:\n        throw rpcErrors.invalidParams(\n          `Invalid ${method} operation: \"${\n            validatedParams.operation as string\n          }\"`,\n        );\n    }\n  };\n}\n\n/**\n * Validates the manageState method `params` and returns them cast to the correct\n * type. Throws if validation fails.\n *\n * @param params - The unvalidated params object from the method request.\n * @param method - RPC method name used for debugging errors.\n * @param storageSizeLimit - Maximum allowed size (in bytes) of a new state object.\n * @returns The validated method parameter object.\n */\nexport function getValidatedParams(\n  params: unknown,\n  method: string,\n  storageSizeLimit = STORAGE_SIZE_LIMIT,\n): ManageStateParams {\n  if (!isObject(params)) {\n    throw rpcErrors.invalidParams({\n      message: 'Expected params to be a single object.',\n    });\n  }\n\n  const { operation, newState, encrypted } = params;\n\n  if (\n    !operation ||\n    typeof operation !== 'string' ||\n    !Object.values(ManageStateOperation).includes(\n      operation as ManageStateOperation,\n    )\n  ) {\n    throw rpcErrors.invalidParams({\n      message: 'Must specify a valid manage state \"operation\".',\n    });\n  }\n\n  if (encrypted !== undefined && typeof encrypted !== 'boolean') {\n    throw rpcErrors.invalidParams({\n      message: '\"encrypted\" parameter must be a boolean if specified.',\n    });\n  }\n\n  if (operation === ManageStateOperation.UpdateState) {\n    if (!isObject(newState)) {\n      throw rpcErrors.invalidParams({\n        message: `Invalid ${method} \"updateState\" parameter: The new state must be a plain object.`,\n        data: {\n          receivedNewState:\n            typeof newState === 'undefined' ? 'undefined' : newState,\n        },\n      });\n    }\n\n    let size;\n    try {\n      // `getJsonSize` will throw if the state is not JSON serializable.\n      size = getJsonSize(newState);\n    } catch {\n      throw rpcErrors.invalidParams({\n        message: `Invalid ${method} \"updateState\" parameter: The new state must be JSON serializable.`,\n        data: {\n          receivedNewState:\n            typeof newState === 'undefined' ? 'undefined' : newState,\n        },\n      });\n    }\n\n    if (size > storageSizeLimit) {\n      throw rpcErrors.invalidParams({\n        message: `Invalid ${method} \"updateState\" parameter: The new state must not exceed ${storageSizeLimit} bytes in size.`,\n        data: {\n          receivedNewState:\n            typeof newState === 'undefined' ? 'undefined' : newState,\n        },\n      });\n    }\n  }\n\n  return params as ManageStateParams;\n}\n"],"names":["PermissionType","SubjectType","rpcErrors","ManageStateOperation","STATE_ENCRYPTION_MAGIC_VALUE","parseJson","isObject","getJsonSize","assert","isValidJson","deriveEntropy","STATE_ENCRYPTION_SALT","methodName","specificationBuilder","allowedCaveats","methodHooks","permissionType","RestrictedMethod","targetName","methodImplementation","getManageStateImplementation","subjectTypes","Snap","getMnemonic","getUnlockPromise","clearSnapState","getSnapState","updateSnapState","encrypt","decrypt","manageStateBuilder","Object","freeze","STORAGE_SIZE_LIMIT","getEncryptionKey","mnemonicPhrase","snapId","input","salt","magic","encryptState","state","encryptFunction","keyArgs","encryptionKey","decryptState","decryptFunction","decryptedState","internal","message","manageState","options","params","method","context","origin","validatedParams","getValidatedParams","shouldEncrypt","encrypted","operation","ClearState","GetState","UpdateState","finalizedState","newState","JSON","stringify","invalidParams","storageSizeLimit","values","includes","undefined","data","receivedNewState","size"],"mappings":"AAKA,SAASA,cAAc,EAAEC,WAAW,QAAQ,kCAAkC;AAC9E,SAASC,SAAS,QAAQ,uBAAuB;AAEjD,SAASC,oBAAoB,QAAQ,sBAAsB;AAC3D,SAASC,4BAA4B,EAAEC,SAAS,QAAQ,wBAAwB;AAEhF,SAASC,QAAQ,EAAEC,WAAW,EAAEC,MAAM,EAAEC,WAAW,QAAQ,kBAAkB;AAG7E,SAASC,aAAa,QAAQ,WAAW;AAEzC,oDAAoD;AACpD,OAAO,MAAMC,wBAAwB,8BAA8B;AAEnE,MAAMC,aAAa;AAuEnB;;;;;;;;;CASC,GACD,OAAO,MAAMC,uBAIT,CAAC,EACHC,iBAAiB,IAAI,EACrBC,WAAW,EAC4B;IACvC,OAAO;QACLC,gBAAgBhB,eAAeiB,gBAAgB;QAC/CC,YAAYN;QACZE;QACAK,sBAAsBC,6BAA6BL;QACnDM,cAAc;YAACpB,YAAYqB,IAAI;SAAC;IAClC;AACF,EAAE;AAEF,MAAMP,cAAyD;IAC7DQ,aAAa;IACbC,kBAAkB;IAClBC,gBAAgB;IAChBC,cAAc;IACdC,iBAAiB;IACjBC,SAAS;IACTC,SAAS;AACX;AAEA,OAAO,MAAMC,qBAAqBC,OAAOC,MAAM,CAAC;IAC9Cd,YAAYN;IACZC;IACAE;AACF,GAAY;AAEZ,OAAO,MAAMkB,qBAAqB,UAAU,CAAC,mBAAmB;AAOhE;;;;;;;;;;;;CAYC,GACD,OAAO,eAAeC,iBAAiB,EACrCC,cAAc,EACdC,MAAM,EACe;IACrB,OAAO,MAAM1B,cAAc;QACzByB;QACAE,OAAOD;QACPE,MAAM3B;QACN4B,OAAOnC;IACT;AACF;AAOA;;;;;;;;;;;CAWC,GACD,eAAeoC,aAAa,EAC1BC,KAAK,EACLC,eAAe,EACf,GAAGC,SACc;IACjB,MAAMC,gBAAgB,MAAMV,iBAAiBS;IAC7C,OAAO,MAAMD,gBAAgBE,eAAeH;AAC9C;AAOA;;;;;;;;;;;CAWC,GACD,eAAeI,aAAa,EAC1BJ,KAAK,EACLK,eAAe,EACf,GAAGH,SACc;IACjB,IAAI;QACF,MAAMC,gBAAgB,MAAMV,iBAAiBS;QAC7C,MAAMI,iBAAiB,MAAMD,gBAAgBF,eAAeH;QAE5DjC,OAAOC,YAAYsC;QAEnB,OAAOA;IACT,EAAE,OAAM;QACN,MAAM7C,UAAU8C,QAAQ,CAAC;YACvBC,SAAS;QACX;IACF;AACF;AAEA;;;;;;;;;;;;;;;;;;;;CAoBC,GACD,OAAO,SAAS7B,6BAA6B,EAC3CG,WAAW,EACXC,gBAAgB,EAChBC,cAAc,EACdC,YAAY,EACZC,eAAe,EACfC,OAAO,EACPC,OAAO,EACgB;IACvB,OAAO,eAAeqB,YACpBC,OAAmD;QAEnD,MAAM,EACJC,SAAS,CAAC,CAAC,EACXC,MAAM,EACNC,SAAS,EAAEC,MAAM,EAAE,EACpB,GAAGJ;QACJ,MAAMK,kBAAkBC,mBAAmBL,QAAQC;QAEnD,kEAAkE;QAClE,MAAMK,gBAAgBF,gBAAgBG,SAAS,IAAI;QAEnD,8DAA8D;QAC9D,iEAAiE;QACjE,IACED,iBACAF,gBAAgBI,SAAS,KAAKzD,qBAAqB0D,UAAU,EAC7D;YACA,MAAMrC,iBAAiB;QACzB;QAEA,OAAQgC,gBAAgBI,SAAS;YAC/B,KAAKzD,qBAAqB0D,UAAU;gBAClCpC,eAAe8B,QAAQG;gBACvB,OAAO;YAET,KAAKvD,qBAAqB2D,QAAQ;gBAAE;oBAClC,MAAMrB,QAAQf,aAAa6B,QAAQG;oBACnC,IAAIjB,UAAU,MAAM;wBAClB,OAAOA;oBACT;oBACA,OAAOiB,gBACH,MAAMb,aAAa;wBACjBJ;wBACAK,iBAAiBjB;wBACjBM,gBAAgB,MAAMZ;wBACtBa,QAAQmB;oBACV,KACAlD,UAAgCoC;gBACtC;YAEA,KAAKtC,qBAAqB4D,WAAW;gBAAE;oBACrC,MAAMC,iBAAiBN,gBACnB,MAAMlB,aAAa;wBACjBC,OAAOe,gBAAgBS,QAAQ;wBAC/BvB,iBAAiBd;wBACjBO,gBAAgB,MAAMZ;wBACtBa,QAAQmB;oBACV,KACAW,KAAKC,SAAS,CAACX,gBAAgBS,QAAQ;oBAE3CtC,gBAAgB4B,QAAQS,gBAAgBN;oBACxC,OAAO;gBACT;YAEA;gBACE,MAAMxD,UAAUkE,aAAa,CAC3B,CAAC,QAAQ,EAAEf,OAAO,aAAa,EAC7BG,gBAAgBI,SAAS,CAC1B,CAAC,CAAC;QAET;IACF;AACF;AAEA;;;;;;;;CAQC,GACD,OAAO,SAASH,mBACdL,MAAe,EACfC,MAAc,EACdgB,mBAAmBpC,kBAAkB;IAErC,IAAI,CAAC3B,SAAS8C,SAAS;QACrB,MAAMlD,UAAUkE,aAAa,CAAC;YAC5BnB,SAAS;QACX;IACF;IAEA,MAAM,EAAEW,SAAS,EAAEK,QAAQ,EAAEN,SAAS,EAAE,GAAGP;IAE3C,IACE,CAACQ,aACD,OAAOA,cAAc,YACrB,CAAC7B,OAAOuC,MAAM,CAACnE,sBAAsBoE,QAAQ,CAC3CX,YAEF;QACA,MAAM1D,UAAUkE,aAAa,CAAC;YAC5BnB,SAAS;QACX;IACF;IAEA,IAAIU,cAAca,aAAa,OAAOb,cAAc,WAAW;QAC7D,MAAMzD,UAAUkE,aAAa,CAAC;YAC5BnB,SAAS;QACX;IACF;IAEA,IAAIW,cAAczD,qBAAqB4D,WAAW,EAAE;QAClD,IAAI,CAACzD,SAAS2D,WAAW;YACvB,MAAM/D,UAAUkE,aAAa,CAAC;gBAC5BnB,SAAS,CAAC,QAAQ,EAAEI,OAAO,+DAA+D,CAAC;gBAC3FoB,MAAM;oBACJC,kBACE,OAAOT,aAAa,cAAc,cAAcA;gBACpD;YACF;QACF;QAEA,IAAIU;QACJ,IAAI;YACF,kEAAkE;YAClEA,OAAOpE,YAAY0D;QACrB,EAAE,OAAM;YACN,MAAM/D,UAAUkE,aAAa,CAAC;gBAC5BnB,SAAS,CAAC,QAAQ,EAAEI,OAAO,kEAAkE,CAAC;gBAC9FoB,MAAM;oBACJC,kBACE,OAAOT,aAAa,cAAc,cAAcA;gBACpD;YACF;QACF;QAEA,IAAIU,OAAON,kBAAkB;YAC3B,MAAMnE,UAAUkE,aAAa,CAAC;gBAC5BnB,SAAS,CAAC,QAAQ,EAAEI,OAAO,wDAAwD,EAAEgB,iBAAiB,eAAe,CAAC;gBACtHI,MAAM;oBACJC,kBACE,OAAOT,aAAa,cAAc,cAAcA;gBACpD;YACF;QACF;IACF;IAEA,OAAOb;AACT"}