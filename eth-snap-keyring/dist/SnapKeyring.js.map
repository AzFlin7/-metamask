{"version":3,"file":"SnapKeyring.js","sourceRoot":"","sources":["../src/SnapKeyring.ts"],"names":[],"mappings":"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","sourcesContent":["import type { TypedTransaction } from '@ethereumjs/tx';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport type { TypedDataV1, TypedMessage } from '@metamask/eth-sig-util';\nimport { SignTypedDataVersion } from '@metamask/eth-sig-util';\nimport type {\n  EthBaseTransaction,\n  EthBaseUserOperation,\n  EthUserOperation,\n  EthUserOperationPatch,\n  InternalAccount,\n  KeyringAccount,\n} from '@metamask/keyring-api';\nimport {\n  AccountCreatedEventStruct,\n  AccountDeletedEventStruct,\n  AccountUpdatedEventStruct,\n  EthBaseUserOperationStruct,\n  EthBytesStruct,\n  EthMethod,\n  EthUserOperationPatchStruct,\n  KeyringEvent,\n  RequestApprovedEventStruct,\n  RequestRejectedEventStruct,\n} from '@metamask/keyring-api';\nimport type { SnapController } from '@metamask/snaps-controllers';\nimport type { SnapId } from '@metamask/snaps-sdk';\nimport type { Json } from '@metamask/utils';\nimport { bigIntToHex } from '@metamask/utils';\nimport { EventEmitter } from 'events';\nimport { assert, mask, object, string } from 'superstruct';\nimport { v4 as uuid } from 'uuid';\n\nimport { DeferredPromise } from './DeferredPromise';\nimport { KeyringSnapControllerClient } from './KeyringSnapControllerClient';\nimport { SnapIdMap } from './SnapIdMap';\nimport type { SnapMessage } from './types';\nimport { SnapMessageStruct } from './types';\nimport {\n  equalsIgnoreCase,\n  strictMask,\n  throwError,\n  toJson,\n  unique,\n} from './util';\n\nexport const SNAP_KEYRING_TYPE = 'Snap Keyring';\n\n/**\n * Snap keyring state.\n *\n * This state is persisted by the keyring controller and passed to the snap\n * keyring when it's created.\n */\nexport type KeyringState = {\n  accounts: Record<string, { account: KeyringAccount; snapId: SnapId }>;\n};\n\n/**\n * Snap keyring callbacks.\n *\n * These callbacks are used to interact with other components.\n */\nexport type SnapKeyringCallbacks = {\n  saveState: () => Promise<void>;\n\n  addressExists(address: string): Promise<boolean>;\n\n  addAccount(\n    address: string,\n    snapId: SnapId,\n    handleUserInput: (accepted: boolean) => Promise<void>,\n  ): Promise<void>;\n\n  removeAccount(\n    address: string,\n    snapId: SnapId,\n    handleUserInput: (accepted: boolean) => Promise<void>,\n  ): Promise<void>;\n\n  redirectUser(snapId: SnapId, url: string, message: string): Promise<void>;\n};\n\n/**\n * Keyring bridge implementation to support snaps.\n */\nexport class SnapKeyring extends EventEmitter {\n  static type: string = SNAP_KEYRING_TYPE;\n\n  type: string;\n\n  /**\n   * Client used to call the snap keyring.\n   */\n  #snapClient: KeyringSnapControllerClient;\n\n  /**\n   * Mapping between account IDs and an object that contains the associated\n   * account object and snap ID.\n   */\n  #accounts: SnapIdMap<{\n    account: KeyringAccount;\n    snapId: SnapId;\n  }>;\n\n  /**\n   * Mapping between request IDs and their deferred promises.\n   */\n  #requests: SnapIdMap<{\n    promise: DeferredPromise<any>;\n    snapId: SnapId;\n  }>;\n\n  /**\n   * Callbacks used to interact with other components.\n   */\n  #callbacks: SnapKeyringCallbacks;\n\n  /**\n   * Create a new snap keyring.\n   *\n   * @param controller - Snaps controller.\n   * @param callbacks - Callbacks used to interact with other components.\n   * @returns A new snap keyring.\n   */\n  constructor(controller: SnapController, callbacks: SnapKeyringCallbacks) {\n    super();\n    this.type = SnapKeyring.type;\n    this.#snapClient = new KeyringSnapControllerClient({ controller });\n    this.#requests = new SnapIdMap();\n    this.#accounts = new SnapIdMap();\n    this.#callbacks = callbacks;\n  }\n\n  /**\n   * Handle an Account Created event from a snap.\n   *\n   * @param snapId - Snap ID.\n   * @param message - Event message.\n   * @returns `null`.\n   */\n  async #handleAccountCreated(\n    snapId: SnapId,\n    message: SnapMessage,\n  ): Promise<null> {\n    assert(message, AccountCreatedEventStruct);\n    const { account } = message.params;\n\n    // The UI still uses the account address to identify accounts, so we need\n    // to block the creation of duplicate accounts for now to prevent accounts\n    // from being overwritten.\n    if (await this.#callbacks.addressExists(account.address.toLowerCase())) {\n      throw new Error(`Account address '${account.address}' already exists`);\n    }\n\n    // A snap could try to create an account with a different address but with\n    // an existing ID, so the above test only is not enough.\n    if (this.#accounts.has(snapId, account.id)) {\n      throw new Error(`Account '${account.id}' already exists`);\n    }\n\n    await this.#callbacks.addAccount(\n      account.address.toLowerCase(),\n      snapId,\n      async (accepted: boolean) => {\n        if (accepted) {\n          this.#accounts.set(account.id, { account, snapId });\n          await this.#callbacks.saveState();\n        }\n      },\n    );\n    return null;\n  }\n\n  /**\n   * Handle an Account Updated event from a snap.\n   *\n   * @param snapId - Snap ID.\n   * @param message - Event message.\n   * @returns `null`.\n   */\n  async #handleAccountUpdated(\n    snapId: SnapId,\n    message: SnapMessage,\n  ): Promise<null> {\n    assert(message, AccountUpdatedEventStruct);\n    const { account: newAccount } = message.params;\n    const { account: oldAccount } =\n      this.#accounts.get(snapId, newAccount.id) ??\n      throwError(`Account '${newAccount.id}' not found`);\n\n    // The address of the account cannot be changed. In the future, we will\n    // support changing the address of an account since it will be required to\n    // support UTXO-based chains.\n    if (!equalsIgnoreCase(oldAccount.address, newAccount.address)) {\n      throw new Error(`Cannot change address of account '${newAccount.id}'`);\n    }\n\n    this.#accounts.set(newAccount.id, { account: newAccount, snapId });\n    await this.#callbacks.saveState();\n    return null;\n  }\n\n  /**\n   * Handle an Account Deleted event from a snap.\n   *\n   * @param snapId - Snap ID.\n   * @param message - Event message.\n   * @returns `null`.\n   */\n  async #handleAccountDeleted(\n    snapId: SnapId,\n    message: SnapMessage,\n  ): Promise<null> {\n    assert(message, AccountDeletedEventStruct);\n    const { id } = message.params;\n    const entry = this.#accounts.get(snapId, id);\n\n    // We can ignore the case where the account was already removed from the\n    // keyring, making the deletion idempotent.\n    //\n    // This happens when the keyring calls the snap to delete an account, and\n    // the snap calls the keyring back with an `AccountDeleted` event.\n    if (entry === undefined) {\n      return null;\n    }\n\n    // At this point we know that the account exists, so we can safely\n    // destructure it.\n    const {\n      account: { address },\n    } = entry;\n\n    await this.#callbacks.removeAccount(\n      address.toLowerCase(),\n      snapId,\n      async (accepted) => {\n        if (accepted) {\n          await this.#callbacks.saveState();\n        }\n      },\n    );\n    return null;\n  }\n\n  /**\n   * Handle an Request Approved event from a snap.\n   *\n   * @param snapId - Snap ID.\n   * @param message - Event message.\n   * @returns `null`.\n   */\n  async #handleRequestApproved(\n    snapId: SnapId,\n    message: SnapMessage,\n  ): Promise<null> {\n    assert(message, RequestApprovedEventStruct);\n    const { id, result } = message.params;\n    const { promise } =\n      this.#requests.get(snapId, id) ?? throwError(`Request '${id}' not found`);\n\n    this.#requests.delete(snapId, id);\n    promise.resolve(result);\n    return null;\n  }\n\n  /**\n   * Handle an Request Rejected event from a snap.\n   *\n   * @param snapId - Snap ID.\n   * @param message - Event message.\n   * @returns `null`.\n   */\n  async #handleRequestRejected(\n    snapId: SnapId,\n    message: SnapMessage,\n  ): Promise<null> {\n    assert(message, RequestRejectedEventStruct);\n    const { id } = message.params;\n    const { promise } =\n      this.#requests.get(snapId, id) ?? throwError(`Request '${id}' not found`);\n\n    this.#requests.delete(snapId, id);\n    promise.reject(new Error(`Request rejected by user or snap.`));\n    return null;\n  }\n\n  /**\n   * Handle a message from a snap.\n   *\n   * @param snapId - ID of the snap.\n   * @param message - Message sent by the snap.\n   * @returns The execution result.\n   */\n  async handleKeyringSnapMessage(\n    snapId: SnapId,\n    message: SnapMessage,\n  ): Promise<Json> {\n    assert(message, SnapMessageStruct);\n    switch (message.method) {\n      case KeyringEvent.AccountCreated: {\n        return this.#handleAccountCreated(snapId, message);\n      }\n\n      case KeyringEvent.AccountUpdated: {\n        return this.#handleAccountUpdated(snapId, message);\n      }\n\n      case KeyringEvent.AccountDeleted: {\n        return this.#handleAccountDeleted(snapId, message);\n      }\n\n      case KeyringEvent.RequestApproved: {\n        return this.#handleRequestApproved(snapId, message);\n      }\n\n      case KeyringEvent.RequestRejected: {\n        return this.#handleRequestRejected(snapId, message);\n      }\n\n      default:\n        throw new Error(`Method not supported: ${message.method}`);\n    }\n  }\n\n  /**\n   * Serialize the keyring state.\n   *\n   * @returns Serialized keyring state.\n   */\n  async serialize(): Promise<KeyringState> {\n    return {\n      accounts: this.#accounts.toObject(),\n    };\n  }\n\n  /**\n   * Deserialize the keyring state into this keyring.\n   *\n   * @param state - Serialized keyring state.\n   */\n  async deserialize(state: KeyringState | undefined): Promise<void> {\n    // If the state is undefined, it means that this is a new keyring, so we\n    // don't need to do anything.\n    if (state === undefined) {\n      return;\n    }\n    this.#accounts = SnapIdMap.fromObject(state.accounts);\n  }\n\n  /**\n   * Get the addresses of the accounts in this keyring.\n   *\n   * @returns The addresses of the accounts in this keyring.\n   */\n  async getAccounts(): Promise<string[]> {\n    return unique(\n      [...this.#accounts.values()].map(({ account }) =>\n        account.address.toLowerCase(),\n      ),\n    );\n  }\n\n  /**\n   * Get the addresses of the accounts associated with a given Snap.\n   *\n   * @param snapId - Snap ID to filter by.\n   * @returns The addresses of the accounts associated with the given Snap.\n   */\n  async getAccountsBySnapId(snapId: SnapId): Promise<string[]> {\n    return unique(\n      [...this.#accounts.values()]\n        .filter(({ snapId: accountSnapId }) => accountSnapId === snapId)\n        .map(({ account }) => account.address.toLowerCase()),\n    );\n  }\n\n  /**\n   * Submit a request to a snap.\n   *\n   * @param opts - Request options.\n   * @param opts.address - Account address.\n   * @param opts.method - Method to call.\n   * @param opts.params - Method parameters.\n   * @param opts.chainId - Selected chain ID (CAIP-2).\n   * @returns Promise that resolves to the result of the method call.\n   */\n  async #submitRequest<Response extends Json>({\n    address,\n    method,\n    params,\n    chainId = '',\n  }: {\n    address: string;\n    method: string;\n    params?: Json[] | Record<string, Json>;\n    chainId?: string;\n  }): Promise<Json> {\n    const { account, snapId } = this.#resolveAddress(address);\n    if (!account.methods.includes(method as EthMethod)) {\n      throw new Error(\n        `Method '${method}' not supported for account ${account.address}`,\n      );\n    }\n    const requestId = uuid();\n\n    // Create the promise before calling the snap to prevent a race condition\n    // where the snap responds before we have a chance to create it.\n    const promise = new DeferredPromise<Response>();\n    this.#requests.set(requestId, { promise, snapId });\n\n    const response = await (async () => {\n      try {\n        return await this.#snapClient.withSnapId(snapId).submitRequest({\n          id: requestId,\n          scope: chainId,\n          account: account.id,\n          request: {\n            method,\n            ...(params !== undefined && { params }),\n          },\n        });\n      } catch (error) {\n        // If the snap failed to respond, delete the promise to prevent a leak.\n        this.#requests.delete(snapId, requestId);\n        throw error;\n      }\n    })();\n\n    // If the snap answers synchronously, the promise must be removed from the\n    // map to prevent a leak.\n    if (!response.pending) {\n      this.#requests.delete(snapId, requestId);\n      return response.result;\n    }\n\n    // If the snap answers asynchronously, we will inform the user with a redirect\n    if (response.redirect?.message || response.redirect?.url) {\n      const { message = '', url = '' } = response.redirect;\n      await this.#callbacks.redirectUser(snapId, url, message);\n    }\n\n    return promise.promise;\n  }\n\n  /**\n   * Sign a transaction.\n   *\n   * @param address - Sender's address.\n   * @param transaction - Transaction.\n   * @param _opts - Transaction options (not used).\n   */\n  async signTransaction(\n    address: string,\n    transaction: TypedTransaction,\n    _opts = {},\n  ): Promise<Json | TypedTransaction> {\n    const tx = toJson({\n      ...transaction.toJSON(),\n      from: address,\n      type: `0x${transaction.type.toString(16)}`,\n      chainId: bigIntToHex(transaction.common.chainId()),\n    });\n\n    const signedTx = await this.#submitRequest({\n      address,\n      method: EthMethod.SignTransaction,\n      params: [tx],\n    });\n\n    // ! It's *** CRITICAL *** that we mask the signature here, otherwise the\n    // ! snap could overwrite the transaction.\n    const signature = mask(\n      signedTx,\n      object({\n        r: string(),\n        s: string(),\n        v: string(),\n      }),\n    );\n\n    return TransactionFactory.fromTxData({\n      ...(tx as Record<string, Json>),\n      r: signature.r,\n      s: signature.s,\n      v: signature.v,\n    });\n  }\n\n  /**\n   * Sign a typed data message.\n   *\n   * @param address - Signer's address.\n   * @param data - Data to sign.\n   * @param opts - Signing options.\n   * @returns The signature.\n   */\n  async signTypedData(\n    address: string,\n    data: Record<string, unknown>[] | TypedDataV1 | TypedMessage<any>,\n    opts = { version: SignTypedDataVersion.V1 },\n  ): Promise<string> {\n    const methods = {\n      [SignTypedDataVersion.V1]: EthMethod.SignTypedDataV1,\n      [SignTypedDataVersion.V3]: EthMethod.SignTypedDataV3,\n      [SignTypedDataVersion.V4]: EthMethod.SignTypedDataV4,\n    };\n\n    // Use 'V1' by default to match other keyring implementations. V1 will be\n    // used if the version is not specified or not supported.\n    const method = methods[opts.version] || EthMethod.SignTypedDataV1;\n\n    return strictMask(\n      await this.#submitRequest({\n        address,\n        method,\n        params: toJson<Json[]>([address, data]),\n      }),\n      EthBytesStruct,\n    );\n  }\n\n  /**\n   * Sign a message.\n   *\n   * @param address - Signer's address.\n   * @param hash - Data to sign.\n   * @returns The signature.\n   */\n  async signMessage(address: string, hash: any): Promise<string> {\n    return strictMask(\n      await this.#submitRequest({\n        address,\n        method: EthMethod.Sign,\n        params: toJson<Json[]>([address, hash]),\n      }),\n      EthBytesStruct,\n    );\n  }\n\n  /**\n   * Sign a personal message.\n   *\n   * Note: KeyringController says this should return a Buffer but it actually\n   * expects a string.\n   *\n   * @param address - Signer's address.\n   * @param data - Data to sign.\n   * @returns Promise of the signature.\n   */\n  async signPersonalMessage(address: string, data: any): Promise<string> {\n    return strictMask(\n      await this.#submitRequest({\n        address,\n        method: EthMethod.PersonalSign,\n        params: toJson<Json[]>([data, address]),\n      }),\n      EthBytesStruct,\n    );\n  }\n\n  /**\n   * Convert a base transaction to a base UserOperation.\n   *\n   * @param address - Address of the sender.\n   * @param transactions - Base transactions to include in the UserOperation.\n   * @returns A pseudo-UserOperation that can be used to construct a real.\n   */\n  async prepareUserOperation(\n    address: string,\n    transactions: EthBaseTransaction[],\n  ): Promise<EthBaseUserOperation> {\n    return strictMask(\n      await this.#submitRequest({\n        address,\n        method: EthMethod.PrepareUserOperation,\n        params: toJson<Json[]>(transactions),\n      }),\n      EthBaseUserOperationStruct,\n    );\n  }\n\n  /**\n   * Patches properties of a UserOperation. Currently, only the\n   * `paymasterAndData` can be patched.\n   *\n   * @param address - Address of the sender.\n   * @param userOp - UserOperation to patch.\n   * @returns A patch to apply to the UserOperation.\n   */\n  async patchUserOperation(\n    address: string,\n    userOp: EthUserOperation,\n  ): Promise<EthUserOperationPatch> {\n    return strictMask(\n      await this.#submitRequest({\n        address,\n        method: EthMethod.PatchUserOperation,\n        params: toJson<Json[]>([userOp]),\n      }),\n      EthUserOperationPatchStruct,\n    );\n  }\n\n  /**\n   * Signs an UserOperation.\n   *\n   * @param address - Address of the sender.\n   * @param userOp - UserOperation to sign.\n   * @returns The signature of the UserOperation.\n   */\n  async signUserOperation(\n    address: string,\n    userOp: EthUserOperation,\n  ): Promise<string> {\n    return strictMask(\n      await this.#submitRequest({\n        address,\n        method: EthMethod.SignUserOperation,\n        params: toJson<Json[]>([userOp]),\n      }),\n      EthBytesStruct,\n    );\n  }\n\n  /**\n   * Gets the private data associated with the given address so\n   * that it may be exported.\n   *\n   * If this keyring contains duplicate public keys the first\n   * matching address is exported.\n   *\n   * Used by the UI to export an account.\n   *\n   * @param _address - Address of the account to export.\n   */\n  exportAccount(_address: string): [Uint8Array, Json] | undefined {\n    throw new Error('Exporting accounts from snaps is not supported.');\n  }\n\n  /**\n   * Removes the account matching the given address.\n   *\n   * @param address - Address of the account to remove.\n   */\n  async removeAccount(address: string): Promise<void> {\n    const { account, snapId } = this.#resolveAddress(address);\n\n    // Always remove the account from the maps, even if the snap is going to\n    // fail to delete it.\n    this.#accounts.delete(snapId, account.id);\n\n    try {\n      await this.#snapClient.withSnapId(snapId).deleteAccount(account.id);\n    } catch (error) {\n      // If the snap failed to delete the account, log the error and continue\n      // with the account deletion, otherwise the account will be stuck in the\n      // keyring.\n      console.error(\n        `Account '${address}' may not have been removed from snap '${snapId}':`,\n        error,\n      );\n    }\n  }\n\n  /**\n   * Resolve an address to an account and snap ID.\n   *\n   * @param address - Address of the account to resolve.\n   * @returns Account and snap ID. Throws if the account or snap ID is not\n   * found.\n   */\n  #resolveAddress(address: string): {\n    account: KeyringAccount;\n    snapId: SnapId;\n  } {\n    return (\n      [...this.#accounts.values()].find(({ account }) =>\n        equalsIgnoreCase(account.address, address),\n      ) ?? throwError(`Account '${address}' not found`)\n    );\n  }\n\n  /**\n   * Get the metadata of a snap keyring account.\n   *\n   * @param snapId - Snap ID.\n   * @returns The snap metadata or undefined if the snap cannot be found.\n   */\n  #getSnapMetadata(\n    snapId: SnapId,\n  ): InternalAccount['metadata']['snap'] | undefined {\n    const snap = this.#snapClient.getController().get(snapId);\n    return snap\n      ? { id: snapId, name: snap.manifest.proposedName, enabled: snap.enabled }\n      : undefined;\n  }\n\n  /**\n   * Return an internal account object for a given address.\n   *\n   * @param address - Address of the account to return.\n   * @returns An internal account object for the given address.\n   */\n  getAccountByAddress(address: string): InternalAccount | undefined {\n    const accounts = this.listAccounts();\n    return accounts.find(({ address: accountAddress }) =>\n      equalsIgnoreCase(accountAddress, address),\n    );\n  }\n\n  /**\n   * List all snap keyring accounts.\n   *\n   * @returns An array containing all snap keyring accounts.\n   */\n  listAccounts(): InternalAccount[] {\n    return [...this.#accounts.values()].map(({ account, snapId }) => {\n      const snap = this.#getSnapMetadata(snapId);\n      return {\n        ...account,\n        // TODO: Do not convert the address to lowercase.\n        //\n        // This is a workaround to support the current UI which expects the\n        // account address to be lowercase. This workaround should be removed\n        // once we migrated the UI to use the account ID instead of the account\n        // address.\n        address: account.address.toLowerCase(),\n        metadata: {\n          name: '',\n          keyring: {\n            type: this.type,\n          },\n          ...(snap !== undefined && { snap }),\n        },\n      };\n    });\n  }\n}\n"]}