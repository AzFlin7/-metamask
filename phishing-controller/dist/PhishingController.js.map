{"version":3,"file":"PhishingController.js","sourceRoot":"","sources":["../src/PhishingController.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,+DAA2D;AAC3D,iEAA2D;AAC3D,gFAAgE;AAChE,wCAAoC;AAEpC,mCAAmD;AAEtC,QAAA,wBAAwB,GACnC,kDAAkD,CAAC;AAExC,QAAA,uBAAuB,GAAG,eAAe,CAAC;AAE1C,QAAA,0BAA0B,GAAG,gBAAgB,CAAC;AAE9C,QAAA,wBAAwB,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,qBAAqB;AACzD,QAAA,0BAA0B,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,oBAAoB;AAEnE,QAAA,sBAAsB,GAAG,GAAG,gCAAwB,GAAG,+BAAuB,EAAE,CAAC;AACjF,QAAA,yBAAyB,GAAG,GAAG,gCAAwB,GAAG,kCAA0B,EAAE,CAAC;AAqHpG;;;GAGG;AACH,IAAY,QAGX;AAHD,WAAY,QAAQ;IAClB,kDAAsC,CAAA;IACtC,kEAAsD,CAAA;AACxD,CAAC,EAHW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAGnB;AAED;;GAEG;AACH,IAAY,SAGX;AAHD,WAAY,SAAS;IACnB,kCAAqB,CAAA;IACrB,oCAAuB,CAAA;AACzB,CAAC,EAHW,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAGpB;AAED;;;GAGG;AACH,MAAM,sBAAsB,GAAG;IAC7B,CAAC,SAAS,CAAC,SAAS,CAAC,EAAE,QAAQ,CAAC,gBAAgB;IAChD,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,uBAAuB;CACvD,CAAC;AAEF;;;GAGG;AACU,QAAA,sBAAsB,GAAG;IACpC,CAAC,QAAQ,CAAC,uBAAuB,CAAC,EAAE,SAAS,CAAC,QAAQ;IACtD,CAAC,QAAQ,CAAC,gBAAgB,CAAC,EAAE,SAAS,CAAC,SAAS;CACjD,CAAC;AAEF,MAAM,cAAc,GAAG,oBAAoB,CAAC;AAE5C,MAAM,QAAQ,GAAG;IACf,aAAa,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE;IAClD,SAAS,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE;IAC9C,kBAAkB,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE;IACvD,oBAAoB,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE;CAC1D,CAAC;AAEF;;;GAGG;AACH,MAAM,eAAe,GAAG,GAA4B,EAAE;IACpD,OAAO;QACL,aAAa,EAAE,EAAE;QACjB,SAAS,EAAE,EAAE;QACb,kBAAkB,EAAE,CAAC;QACrB,oBAAoB,EAAE,CAAC;KACxB,CAAC;AACJ,CAAC,CAAC;AAkDF;;GAEG;AACH,MAAa,kBAAmB,SAAQ,gCAIvC;IAaC;;;;;;;;OAQG;IACH,YAAY,EACV,wBAAwB,GAAG,kCAA0B,EACrD,sBAAsB,GAAG,gCAAwB,EACjD,SAAS,EACT,KAAK,GAAG,EAAE,GACgB;QAC1B,KAAK,CAAC;YACJ,IAAI,EAAE,cAAc;YACpB,QAAQ;YACR,SAAS;YACT,KAAK,kCACA,eAAe,EAAE,GACjB,KAAK,CACT;SACF,CAAC,CAAC;;QAnCL,gCAAgC;QAChC,8DAA8D;QAC9D,+CAAe;QAEf,+DAAkC;QAElC,6DAAgC;QAEhC,8DAAyC;QAEzC,gEAA2C;QA2BzC,uBAAA,IAAI,gDAA6B,wBAAwB,MAAA,CAAC;QAC1D,uBAAA,IAAI,8CAA2B,sBAAsB,MAAA,CAAC;QACtD,uBAAA,IAAI,kFAAyB,MAA7B,IAAI,CAA2B,CAAC;QAEhC,IAAI,CAAC,sBAAsB,EAAE,CAAC;IAChC,CAAC;IAkBD;;OAEG;IACH,sBAAsB;QACpB,uBAAA,IAAI,gCAAa,IAAI,kBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,MAAA,CAAC;IAClE,CAAC;IAED;;;;;;OAMG;IACH,2BAA2B,CAAC,QAAgB;QAC1C,uBAAA,IAAI,gDAA6B,QAAQ,MAAA,CAAC;IAC5C,CAAC;IAED;;;;;;OAMG;IACH,yBAAyB,CAAC,QAAgB;QACxC,uBAAA,IAAI,8CAA2B,QAAQ,MAAA,CAAC;IAC1C,CAAC;IAED;;;;OAIG;IACH,oBAAoB;QAClB,OAAO,CACL,IAAA,oBAAY,GAAE,GAAG,IAAI,CAAC,KAAK,CAAC,oBAAoB;YAChD,uBAAA,IAAI,oDAA0B,CAC/B,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACH,kBAAkB;QAChB,OAAO,CACL,IAAA,oBAAY,GAAE,GAAG,IAAI,CAAC,KAAK,CAAC,kBAAkB;YAC9C,uBAAA,IAAI,kDAAwB,CAC7B,CAAC;IACJ,CAAC;IAED;;;;;;;OAOG;IACG,gBAAgB;;YACpB,MAAM,kBAAkB,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;YACvD,IAAI,kBAAkB,EAAE;gBACtB,MAAM,IAAI,CAAC,eAAe,EAAE,CAAC;gBAC7B,OAAO;aACR;YACD,MAAM,gBAAgB,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;YACnD,IAAI,gBAAgB,EAAE;gBACpB,MAAM,IAAI,CAAC,aAAa,EAAE,CAAC;aAC5B;QACH,CAAC;KAAA;IAED;;;;;;;;;OASG;IACH,IAAI,CAAC,MAAc;QACjB,MAAM,cAAc,GAAG,IAAA,kBAAO,EAAC,MAAM,CAAC,CAAC;QACvC,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE;YACjD,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC,6DAA6D;SACrG;QACD,OAAO,uBAAA,IAAI,oCAAU,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;IAC9C,CAAC;IAED;;;;OAIG;IACH,MAAM,CAAC,MAAc;QACnB,MAAM,cAAc,GAAG,IAAA,kBAAO,EAAC,MAAM,CAAC,CAAC;QACvC,MAAM,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC;QACjC,IAAI,SAAS,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE;YACtC,OAAO;SACR;QACD,IAAI,CAAC,MAAM,CAAC,CAAC,UAAU,EAAE,EAAE;YACzB,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAC5C,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACG,aAAa;;YACjB,IAAI,uBAAA,IAAI,mDAAyB,EAAE;gBACjC,MAAM,uBAAA,IAAI,mDAAyB,CAAC;gBACpC,OAAO;aACR;YAED,IAAI;gBACF,uBAAA,IAAI,+CAA4B,uBAAA,IAAI,wEAAe,MAAnB,IAAI,CAAiB,MAAA,CAAC;gBACtD,MAAM,uBAAA,IAAI,mDAAyB,CAAC;aACrC;oBAAS;gBACR,uBAAA,IAAI,+CAA4B,SAAS,MAAA,CAAC;aAC3C;QACH,CAAC;KAAA;IAED;;;;;OAKG;IACG,eAAe;;YACnB,IAAI,uBAAA,IAAI,qDAA2B,EAAE;gBACnC,MAAM,uBAAA,IAAI,qDAA2B,CAAC;gBACtC,OAAO;aACR;YAED,IAAI;gBACF,uBAAA,IAAI,iDAA8B,uBAAA,IAAI,0EAAiB,MAArB,IAAI,CAAmB,MAAA,CAAC;gBAC1D,MAAM,uBAAA,IAAI,qDAA2B,CAAC;aACvC;oBAAS;gBACR,uBAAA,IAAI,iDAA8B,SAAS,MAAA,CAAC;aAC7C;QACH,CAAC;KAAA;CAkIF;AApVD,gDAoVC;;IA9RG,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,cAAc,mBAA4B,EAC7C,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CACjC,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,cAAc,aAAsB,EACvC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CACrB,CAAC;AACJ,CAAC;;QA4JC,IAAI,iBAAiB,CAAC;QACtB,IAAI,oBAAoB,CAAC;QACzB,IAAI;YACF,iBAAiB,GAAG,MAAM,uBAAA,IAAI,sEAAa,MAAjB,IAAI,EAE5B,8BAAsB,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;YAEzC,yGAAyG;YACzG,8EAA8E;YAC9E,IAAI,CAAA,iBAAiB,aAAjB,iBAAiB,uBAAjB,iBAAiB,CAAE,IAAI,KAAI,iBAAiB,CAAC,IAAI,CAAC,WAAW,GAAG,CAAC,EAAE;gBACrE,oBAAoB,GAAG,MAAM,uBAAA,IAAI,sEAAa,MAAjB,IAAI,EAE/B,GAAG,iCAAyB,IAAI,iBAAiB,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC;aACzE;SACF;gBAAS;YACR,iGAAiG;YACjG,kEAAkE;YAClE,MAAM,OAAO,GAAG,IAAA,oBAAY,GAAE,CAAC;YAC/B,IAAI,CAAC,MAAM,CAAC,CAAC,UAAU,EAAE,EAAE;gBACzB,UAAU,CAAC,oBAAoB,GAAG,OAAO,CAAC;gBAC1C,UAAU,CAAC,kBAAkB,GAAG,OAAO,CAAC;YAC1C,CAAC,CAAC,CAAC;SACJ;QAED,IAAI,CAAC,iBAAiB,IAAI,CAAC,oBAAoB,EAAE;YAC/C,OAAO;SACR;QAED,MAAM,KACJ,iBAAiB,CAAC,IAAI,EADlB,EAAE,iBAAiB,EAAE,0BAA0B,OAC7B,EADkC,YAAY,cAAhE,mDAAkE,CAChD,CAAC;QAEzB,MAAM,kBAAkB,iDACnB,iBAAiB,GACjB,YAAY,KACf,SAAS,EAAE,EAAE,EACb,SAAS,EAAE,EAAE,EACb,IAAI,EAAE,8BAAsB,CAAC,iBAAiB,GAC/C,CAAC;QACF,MAAM,iBAAiB,iDAClB,0BAA0B,GAC1B,YAAY,KACf,IAAI,EAAE,8BAAsB,CAAC,0BAA0B,GACxD,CAAC;QACF,0FAA0F;QAC1F,MAAM,qBAAqB,GAAsB,IAAA,kBAAU,EACzD,kBAAkB,EAClB,oBAAoB,CAAC,IAAI,EACzB,QAAQ,CAAC,gBAAgB,CAC1B,CAAC;QACF,MAAM,oBAAoB,GAAsB,IAAA,kBAAU,EACxD,iBAAiB,EACjB,oBAAoB,CAAC,IAAI,EACzB,QAAQ,CAAC,uBAAuB,CACjC,CAAC;QAEF,IAAI,CAAC,MAAM,CAAC,CAAC,UAAU,EAAE,EAAE;YACzB,UAAU,CAAC,aAAa,GAAG,CAAC,oBAAoB,EAAE,qBAAqB,CAAC,CAAC;QAC3E,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,sBAAsB,EAAE,CAAC;IAChC,CAAC;;;QASC,MAAM,iBAAiB,GAAG,IAAI,CAAC,GAAG,CAChC,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,WAAW,CAAC,CAClE,CAAC;QACF,IAAI,eAAkD,CAAC;QAEvD,IAAI;YACF,eAAe,GAAG,MAAM,uBAAA,IAAI,sEAAa,MAAjB,IAAI,EAC1B,GAAG,iCAAyB,IAAI,iBAAiB,EAAE,CACpD,CAAC;SACH;gBAAS;YACR,kGAAkG;YAClG,sCAAsC;YACtC,IAAI,CAAC,MAAM,CAAC,CAAC,UAAU,EAAE,EAAE;gBACzB,UAAU,CAAC,kBAAkB,GAAG,IAAA,oBAAY,GAAE,CAAC;YACjD,CAAC,CAAC,CAAC;SACJ;QAED,IAAI,CAAC,CAAA,eAAe,aAAf,eAAe,uBAAf,eAAe,CAAE,IAAI,CAAA,EAAE;YAC1B,OAAO;SACR;QACD,MAAM,OAAO,GAAG,eAAe,CAAC,IAAI,CAAC;QACrC,MAAM,gBAAgB,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,YAAY,EAAE,EAAE,CACrE,IAAA,kBAAU,EACR,YAAY,EACZ,OAAO,EACP,sBAAsB,CAAC,YAAY,CAAC,IAAI,CAAC,CAC1C,CACF,CAAC;QAEF,IAAI,CAAC,MAAM,CAAC,CAAC,UAAU,EAAE,EAAE;YACzB,UAAU,CAAC,aAAa,GAAG,gBAAgB,CAAC;QAC9C,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,sBAAsB,EAAE,CAAC;IAChC,CAAC;8EAGC,KAAkB;;QAElB,MAAM,QAAQ,GAAG,MAAM,IAAA,gCAAa,EAClC,GAAG,EAAE,CAAC,KAAK,CAAC,KAAK,EAAE,EAAE,KAAK,EAAE,UAAU,EAAE,CAAC,EACzC,IAAI,CACL,CAAC;QAEF,QAAQ,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,MAAM,EAAE;YACxB,KAAK,GAAG,CAAC,CAAC;gBACR,OAAO,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC;aAC9B;YAED,OAAO,CAAC,CAAC;gBACP,OAAO,IAAI,CAAC;aACb;SACF;IACH,CAAC;;AAGH,kBAAe,kBAAkB,CAAC","sourcesContent":["import type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport PhishingDetector from 'eth-phishing-detect/src/detector';\nimport { toASCII } from 'punycode/';\n\nimport { applyDiffs, fetchTimeNow } from './utils';\n\nexport const PHISHING_CONFIG_BASE_URL =\n  'https://phishing-detection.metafi.codefi.network';\n\nexport const METAMASK_STALELIST_FILE = '/v1/stalelist';\n\nexport const METAMASK_HOTLIST_DIFF_FILE = '/v1/diffsSince';\n\nexport const HOTLIST_REFRESH_INTERVAL = 30 * 60; // 30 mins in seconds\nexport const STALELIST_REFRESH_INTERVAL = 4 * 24 * 60 * 60; // 4 days in seconds\n\nexport const METAMASK_STALELIST_URL = `${PHISHING_CONFIG_BASE_URL}${METAMASK_STALELIST_FILE}`;\nexport const METAMASK_HOTLIST_DIFF_URL = `${PHISHING_CONFIG_BASE_URL}${METAMASK_HOTLIST_DIFF_FILE}`;\n\n/**\n * @type ListTypes\n *\n * Type outlining the types of lists provided by aggregating different source lists\n */\nexport type ListTypes = 'fuzzylist' | 'blocklist' | 'allowlist';\n\n/**\n * @type EthPhishingResponse\n *\n * Configuration response from the eth-phishing-detect package\n * consisting of approved and unapproved website origins\n * @property blacklist - List of unapproved origins\n * @property fuzzylist - List of fuzzy-matched unapproved origins\n * @property tolerance - Fuzzy match tolerance level\n * @property version - Version number of this configuration\n * @property whitelist - List of approved origins\n */\nexport type EthPhishingResponse = {\n  blacklist: string[];\n  fuzzylist: string[];\n  tolerance: number;\n  version: number;\n  whitelist: string[];\n};\n\n/**\n * @type PhishingStalelist\n *\n * type defining expected type of the stalelist.json file.\n * @property eth_phishing_detect_config - Stale list sourced from eth-phishing-detect's config.json.\n * @property phishfort_hotlist - Stale list sourced from phishfort's hotlist.json. Only includes blocklist. Deduplicated entries from eth_phishing_detect_config.\n * @property tolerance - Fuzzy match tolerance level\n * @property lastUpdated - Timestamp of last update.\n * @property version - Stalelist data structure iteration.\n */\nexport type PhishingStalelist = {\n  eth_phishing_detect_config: Record<ListTypes, string[]>;\n  phishfort_hotlist: Record<ListTypes, string[]>;\n  tolerance: number;\n  version: number;\n  lastUpdated: number;\n};\n\n/**\n * @type PhishingListState\n *\n * type defining the persisted list state. This is the persisted state that is updated frequently with `this.maybeUpdateState()`.\n * @property allowlist - List of approved origins (legacy naming \"whitelist\")\n * @property blocklist - List of unapproved origins (legacy naming \"blacklist\")\n * @property fuzzylist - List of fuzzy-matched unapproved origins\n * @property tolerance - Fuzzy match tolerance level\n * @property lastUpdated - Timestamp of last update.\n * @property version - Version of the phishing list state.\n * @property name - Name of the list. Used for attribution.\n */\nexport type PhishingListState = {\n  allowlist: string[];\n  blocklist: string[];\n  fuzzylist: string[];\n  tolerance: number;\n  version: number;\n  lastUpdated: number;\n  name: ListNames;\n};\n\n/**\n * @type EthPhishingDetectResult\n *\n * type that describes the result of the `test` method.\n * @property name - Name of the config on which a match was found.\n * @property version - Version of the config on which a match was found.\n * @property result - Whether a domain was detected as a phishing domain. True means an unsafe domain.\n * @property match - The matching fuzzylist origin when a fuzzylist match is found. Returned as undefined for non-fuzzy true results.\n * @property type - The field of the config on which a match was found.\n */\nexport type EthPhishingDetectResult = {\n  name?: string;\n  version?: string;\n  result: boolean;\n  match?: string; // Returned as undefined for non-fuzzy true results.\n  type: 'all' | 'fuzzy' | 'blocklist' | 'allowlist';\n};\n\n/**\n * @type HotlistDiff\n *\n * type defining the expected type of the diffs in hotlist.json file.\n * @property url - Url of the diff entry.\n * @property timestamp - Timestamp at which the diff was identified.\n * @property targetList - The list name where the diff was identified.\n * @property isRemoval - Was the diff identified a removal type.\n */\nexport type HotlistDiff = {\n  url: string;\n  timestamp: number;\n  targetList: `${ListKeys}.${ListTypes}`;\n  isRemoval?: boolean;\n};\n\nexport type DataResultWrapper<T> = {\n  data: T;\n};\n\n/**\n * @type Hotlist\n *\n * Type defining expected hotlist.json file.\n * @property url - Url of the diff entry.\n * @property timestamp - Timestamp at which the diff was identified.\n * @property targetList - The list name where the diff was identified.\n * @property isRemoval - Was the diff identified a removal type.\n */\nexport type Hotlist = HotlistDiff[];\n\n/**\n * Enum containing upstream data provider source list keys.\n * These are the keys denoting lists consumed by the upstream data provider.\n */\nexport enum ListKeys {\n  PhishfortHotlist = 'phishfort_hotlist',\n  EthPhishingDetectConfig = 'eth_phishing_detect_config',\n}\n\n/**\n * Enum containing downstream client attribution names.\n */\nexport enum ListNames {\n  MetaMask = 'MetaMask',\n  Phishfort = 'Phishfort',\n}\n\n/**\n * Maps from downstream client attribution name\n * to list key sourced from upstream data provider.\n */\nconst phishingListNameKeyMap = {\n  [ListNames.Phishfort]: ListKeys.PhishfortHotlist,\n  [ListNames.MetaMask]: ListKeys.EthPhishingDetectConfig,\n};\n\n/**\n * Maps from list key sourced from upstream data\n * provider to downstream client attribution name.\n */\nexport const phishingListKeyNameMap = {\n  [ListKeys.EthPhishingDetectConfig]: ListNames.MetaMask,\n  [ListKeys.PhishfortHotlist]: ListNames.Phishfort,\n};\n\nconst controllerName = 'PhishingController';\n\nconst metadata = {\n  phishingLists: { persist: true, anonymous: false },\n  whitelist: { persist: true, anonymous: false },\n  hotlistLastFetched: { persist: true, anonymous: false },\n  stalelistLastFetched: { persist: true, anonymous: false },\n};\n\n/**\n * Get a default empty state for the controller.\n * @returns The default empty state.\n */\nconst getDefaultState = (): PhishingControllerState => {\n  return {\n    phishingLists: [],\n    whitelist: [],\n    hotlistLastFetched: 0,\n    stalelistLastFetched: 0,\n  };\n};\n\n/**\n * @type PhishingControllerState\n *\n * Phishing controller state\n * @property phishing - eth-phishing-detect configuration\n * @property whitelist - array of temporarily-approved origins\n */\nexport type PhishingControllerState = {\n  phishingLists: PhishingListState[];\n  whitelist: string[];\n  hotlistLastFetched: number;\n  stalelistLastFetched: number;\n};\n\n/**\n * @type PhishingControllerOptions\n *\n * Phishing controller options\n * @property stalelistRefreshInterval - Polling interval used to fetch stale list.\n * @property hotlistRefreshInterval - Polling interval used to fetch hotlist diff list.\n */\nexport type PhishingControllerOptions = {\n  stalelistRefreshInterval?: number;\n  hotlistRefreshInterval?: number;\n  messenger: PhishingControllerMessenger;\n  state?: Partial<PhishingControllerState>;\n};\n\nexport type MaybeUpdateState = {\n  type: `${typeof controllerName}:maybeUpdateState`;\n  handler: PhishingController['maybeUpdateState'];\n};\n\nexport type TestOrigin = {\n  type: `${typeof controllerName}:testOrigin`;\n  handler: PhishingController['test'];\n};\n\nexport type PhishingControllerActions = MaybeUpdateState | TestOrigin;\n\nexport type PhishingControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  PhishingControllerActions,\n  never,\n  never,\n  never\n>;\n\n/**\n * Controller that manages community-maintained lists of approved and unapproved website origins.\n */\nexport class PhishingController extends BaseController<\n  typeof controllerName,\n  PhishingControllerState,\n  PhishingControllerMessenger\n> {\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  #detector: any;\n\n  #stalelistRefreshInterval: number;\n\n  #hotlistRefreshInterval: number;\n\n  #inProgressHotlistUpdate?: Promise<void>;\n\n  #inProgressStalelistUpdate?: Promise<void>;\n\n  /**\n   * Construct a Phishing Controller.\n   *\n   * @param config - Initial options used to configure this controller.\n   * @param config.stalelistRefreshInterval - Polling interval used to fetch stale list.\n   * @param config.hotlistRefreshInterval - Polling interval used to fetch hotlist diff list.\n   * @param config.messenger - The controller restricted messenger.\n   * @param config.state - Initial state to set on this controller.\n   */\n  constructor({\n    stalelistRefreshInterval = STALELIST_REFRESH_INTERVAL,\n    hotlistRefreshInterval = HOTLIST_REFRESH_INTERVAL,\n    messenger,\n    state = {},\n  }: PhishingControllerOptions) {\n    super({\n      name: controllerName,\n      metadata,\n      messenger,\n      state: {\n        ...getDefaultState(),\n        ...state,\n      },\n    });\n\n    this.#stalelistRefreshInterval = stalelistRefreshInterval;\n    this.#hotlistRefreshInterval = hotlistRefreshInterval;\n    this.#registerMessageHandlers();\n\n    this.updatePhishingDetector();\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:maybeUpdateState` as const,\n      this.maybeUpdateState.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:testOrigin` as const,\n      this.test.bind(this),\n    );\n  }\n\n  /**\n   * Updates this.detector with an instance of PhishingDetector using the current state.\n   */\n  updatePhishingDetector() {\n    this.#detector = new PhishingDetector(this.state.phishingLists);\n  }\n\n  /**\n   * Set the interval at which the stale phishing list will be refetched.\n   * Fetching will only occur on the next call to test/bypass.\n   * For immediate update to the phishing list, call {@link updateStalelist} directly.\n   *\n   * @param interval - the new interval, in ms.\n   */\n  setStalelistRefreshInterval(interval: number) {\n    this.#stalelistRefreshInterval = interval;\n  }\n\n  /**\n   * Set the interval at which the hot list will be refetched.\n   * Fetching will only occur on the next call to test/bypass.\n   * For immediate update to the phishing list, call {@link updateHotlist} directly.\n   *\n   * @param interval - the new interval, in ms.\n   */\n  setHotlistRefreshInterval(interval: number) {\n    this.#hotlistRefreshInterval = interval;\n  }\n\n  /**\n   * Determine if an update to the stalelist configuration is needed.\n   *\n   * @returns Whether an update is needed\n   */\n  isStalelistOutOfDate() {\n    return (\n      fetchTimeNow() - this.state.stalelistLastFetched >=\n      this.#stalelistRefreshInterval\n    );\n  }\n\n  /**\n   * Determine if an update to the hotlist configuration is needed.\n   *\n   * @returns Whether an update is needed\n   */\n  isHotlistOutOfDate() {\n    return (\n      fetchTimeNow() - this.state.hotlistLastFetched >=\n      this.#hotlistRefreshInterval\n    );\n  }\n\n  /**\n   * Conditionally update the phishing configuration.\n   *\n   * If the stalelist configuration is out of date, this function will call `updateStalelist`\n   * to update the configuration. This will automatically grab the hotlist,\n   * so it isn't necessary to continue on to download the hotlist.\n   *\n   */\n  async maybeUpdateState() {\n    const staleListOutOfDate = this.isStalelistOutOfDate();\n    if (staleListOutOfDate) {\n      await this.updateStalelist();\n      return;\n    }\n    const hotlistOutOfDate = this.isHotlistOutOfDate();\n    if (hotlistOutOfDate) {\n      await this.updateHotlist();\n    }\n  }\n\n  /**\n   * Determines if a given origin is unapproved.\n   *\n   * It is strongly recommended that you call {@link maybeUpdateState} before calling this,\n   * to check whether the phishing configuration is up-to-date. It will be updated if necessary\n   * by calling {@link updateStalelist} or {@link updateHotlist}.\n   *\n   * @param origin - Domain origin of a website.\n   * @returns Whether the origin is an unapproved origin.\n   */\n  test(origin: string): EthPhishingDetectResult {\n    const punycodeOrigin = toASCII(origin);\n    if (this.state.whitelist.includes(punycodeOrigin)) {\n      return { result: false, type: 'all' }; // Same as whitelisted match returned by detector.check(...).\n    }\n    return this.#detector.check(punycodeOrigin);\n  }\n\n  /**\n   * Temporarily marks a given origin as approved.\n   *\n   * @param origin - The origin to mark as approved.\n   */\n  bypass(origin: string) {\n    const punycodeOrigin = toASCII(origin);\n    const { whitelist } = this.state;\n    if (whitelist.includes(punycodeOrigin)) {\n      return;\n    }\n    this.update((draftState) => {\n      draftState.whitelist.push(punycodeOrigin);\n    });\n  }\n\n  /**\n   * Update the hotlist.\n   *\n   * If an update is in progress, no additional update will be made. Instead this will wait until\n   * the in-progress update has finished.\n   */\n  async updateHotlist() {\n    if (this.#inProgressHotlistUpdate) {\n      await this.#inProgressHotlistUpdate;\n      return;\n    }\n\n    try {\n      this.#inProgressHotlistUpdate = this.#updateHotlist();\n      await this.#inProgressHotlistUpdate;\n    } finally {\n      this.#inProgressHotlistUpdate = undefined;\n    }\n  }\n\n  /**\n   * Update the stalelist.\n   *\n   * If an update is in progress, no additional update will be made. Instead this will wait until\n   * the in-progress update has finished.\n   */\n  async updateStalelist() {\n    if (this.#inProgressStalelistUpdate) {\n      await this.#inProgressStalelistUpdate;\n      return;\n    }\n\n    try {\n      this.#inProgressStalelistUpdate = this.#updateStalelist();\n      await this.#inProgressStalelistUpdate;\n    } finally {\n      this.#inProgressStalelistUpdate = undefined;\n    }\n  }\n\n  /**\n   * Update the stalelist configuration.\n   *\n   * This should only be called from the `updateStalelist` function, which is a wrapper around\n   * this function that prevents redundant configuration updates.\n   */\n  async #updateStalelist() {\n    let stalelistResponse;\n    let hotlistDiffsResponse;\n    try {\n      stalelistResponse = await this.#queryConfig<\n        DataResultWrapper<PhishingStalelist>\n      >(METAMASK_STALELIST_URL).then((d) => d);\n\n      // Fetching hotlist diffs relies on having a lastUpdated timestamp to do `GET /v1/diffsSince/:timestamp`,\n      // so it doesn't make sense to call if there is not a timestamp to begin with.\n      if (stalelistResponse?.data && stalelistResponse.data.lastUpdated > 0) {\n        hotlistDiffsResponse = await this.#queryConfig<\n          DataResultWrapper<Hotlist>\n        >(`${METAMASK_HOTLIST_DIFF_URL}/${stalelistResponse.data.lastUpdated}`);\n      }\n    } finally {\n      // Set `stalelistLastFetched` and `hotlistLastFetched` even for failed requests to prevent server\n      // from being overwhelmed with traffic after a network disruption.\n      const timeNow = fetchTimeNow();\n      this.update((draftState) => {\n        draftState.stalelistLastFetched = timeNow;\n        draftState.hotlistLastFetched = timeNow;\n      });\n    }\n\n    if (!stalelistResponse || !hotlistDiffsResponse) {\n      return;\n    }\n\n    const { phishfort_hotlist, eth_phishing_detect_config, ...partialState } =\n      stalelistResponse.data;\n\n    const phishfortListState: PhishingListState = {\n      ...phishfort_hotlist,\n      ...partialState,\n      fuzzylist: [], // Phishfort hotlist doesn't contain a fuzzylist\n      allowlist: [], // Phishfort hotlist doesn't contain an allowlist\n      name: phishingListKeyNameMap.phishfort_hotlist,\n    };\n    const metamaskListState: PhishingListState = {\n      ...eth_phishing_detect_config,\n      ...partialState,\n      name: phishingListKeyNameMap.eth_phishing_detect_config,\n    };\n    // Correctly shaping eth-phishing-detect state by applying hotlist diffs to the stalelist.\n    const newPhishfortListState: PhishingListState = applyDiffs(\n      phishfortListState,\n      hotlistDiffsResponse.data,\n      ListKeys.PhishfortHotlist,\n    );\n    const newMetaMaskListState: PhishingListState = applyDiffs(\n      metamaskListState,\n      hotlistDiffsResponse.data,\n      ListKeys.EthPhishingDetectConfig,\n    );\n\n    this.update((draftState) => {\n      draftState.phishingLists = [newMetaMaskListState, newPhishfortListState];\n    });\n    this.updatePhishingDetector();\n  }\n\n  /**\n   * Update the stalelist configuration.\n   *\n   * This should only be called from the `updateStalelist` function, which is a wrapper around\n   * this function that prevents redundant configuration updates.\n   */\n  async #updateHotlist() {\n    const lastDiffTimestamp = Math.max(\n      ...this.state.phishingLists.map(({ lastUpdated }) => lastUpdated),\n    );\n    let hotlistResponse: DataResultWrapper<Hotlist> | null;\n\n    try {\n      hotlistResponse = await this.#queryConfig<DataResultWrapper<Hotlist>>(\n        `${METAMASK_HOTLIST_DIFF_URL}/${lastDiffTimestamp}`,\n      );\n    } finally {\n      // Set `hotlistLastFetched` even for failed requests to prevent server from being overwhelmed with\n      // traffic after a network disruption.\n      this.update((draftState) => {\n        draftState.hotlistLastFetched = fetchTimeNow();\n      });\n    }\n\n    if (!hotlistResponse?.data) {\n      return;\n    }\n    const hotlist = hotlistResponse.data;\n    const newPhishingLists = this.state.phishingLists.map((phishingList) =>\n      applyDiffs(\n        phishingList,\n        hotlist,\n        phishingListNameKeyMap[phishingList.name],\n      ),\n    );\n\n    this.update((draftState) => {\n      draftState.phishingLists = newPhishingLists;\n    });\n    this.updatePhishingDetector();\n  }\n\n  async #queryConfig<ResponseType>(\n    input: RequestInfo,\n  ): Promise<ResponseType | null> {\n    const response = await safelyExecute(\n      () => fetch(input, { cache: 'no-cache' }),\n      true,\n    );\n\n    switch (response?.status) {\n      case 200: {\n        return await response.json();\n      }\n\n      default: {\n        return null;\n      }\n    }\n  }\n}\n\nexport default PhishingController;\n"]}