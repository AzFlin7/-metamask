{"version":3,"sources":["../src/BlockTrackerPollingController.ts"],"sourcesContent":["import { BaseController, BaseControllerV1 } from '@metamask/base-controller';\nimport type {\n  NetworkClientId,\n  NetworkClient,\n} from '@metamask/network-controller';\nimport type { Json } from '@metamask/utils';\n\nimport {\n  AbstractPollingControllerBaseMixin,\n  getKey,\n} from './AbstractPollingController';\nimport type { Constructor, PollingTokenSetId } from './types';\n\n/**\n * BlockTrackerPollingControllerMixin\n * A polling controller that polls using a block tracker.\n *\n * @param Base - The base class to mix onto.\n * @returns The composed class.\n */\nfunction BlockTrackerPollingControllerMixin<TBase extends Constructor>(\n  Base: TBase,\n) {\n  abstract class BlockTrackerPollingController extends AbstractPollingControllerBaseMixin(\n    Base,\n  ) {\n    #activeListeners: Record<string, (options: Json) => Promise<void>> = {};\n\n    abstract _getNetworkClientById(\n      networkClientId: NetworkClientId,\n    ): NetworkClient | undefined;\n\n    _startPollingByNetworkClientId(\n      networkClientId: NetworkClientId,\n      options: Json,\n    ) {\n      const key = getKey(networkClientId, options);\n\n      if (this.#activeListeners[key]) {\n        return;\n      }\n\n      const networkClient = this._getNetworkClientById(networkClientId);\n      if (networkClient) {\n        const updateOnNewBlock = this._executePoll.bind(\n          this,\n          networkClientId,\n          options,\n        );\n        networkClient.blockTracker.addListener('latest', updateOnNewBlock);\n        this.#activeListeners[key] = updateOnNewBlock;\n      } else {\n        throw new Error(\n          `Unable to retrieve blockTracker for networkClientId ${networkClientId}`,\n        );\n      }\n    }\n\n    _stopPollingByPollingTokenSetId(key: PollingTokenSetId) {\n      const [networkClientId] = key.split(':');\n      const networkClient = this._getNetworkClientById(\n        networkClientId as NetworkClientId,\n      );\n\n      if (networkClient && this.#activeListeners[key]) {\n        const listener = this.#activeListeners[key];\n        if (listener) {\n          networkClient.blockTracker.removeListener('latest', listener);\n          delete this.#activeListeners[key];\n        }\n      }\n    }\n  }\n\n  return BlockTrackerPollingController;\n}\n\nclass Empty {}\n\nexport const BlockTrackerPollingControllerOnly =\n  BlockTrackerPollingControllerMixin(Empty);\nexport const BlockTrackerPollingController =\n  BlockTrackerPollingControllerMixin(BaseController);\nexport const BlockTrackerPollingControllerV1 =\n  BlockTrackerPollingControllerMixin(BaseControllerV1);\n"],"mappings":";;;;;;;;AAAA,SAAS,gBAAgB,wBAAwB;AAoBjD,SAAS,mCACP,MACA;AAtBF;AAAA,EAuBE,MAAeA,uCAAsC;AAAA,IACnD;AAAA,EACF,EAAE;AAAA,IAFF;AAAA;AAGE,2CAAqE,CAAC;AAAA;AAAA,IAMtE,+BACE,iBACA,SACA;AACA,YAAM,MAAM,OAAO,iBAAiB,OAAO;AAE3C,UAAI,mBAAK,kBAAiB,GAAG,GAAG;AAC9B;AAAA,MACF;AAEA,YAAM,gBAAgB,KAAK,sBAAsB,eAAe;AAChE,UAAI,eAAe;AACjB,cAAM,mBAAmB,KAAK,aAAa;AAAA,UACzC;AAAA,UACA;AAAA,UACA;AAAA,QACF;AACA,sBAAc,aAAa,YAAY,UAAU,gBAAgB;AACjE,2BAAK,kBAAiB,GAAG,IAAI;AAAA,MAC/B,OAAO;AACL,cAAM,IAAI;AAAA,UACR,uDAAuD,eAAe;AAAA,QACxE;AAAA,MACF;AAAA,IACF;AAAA,IAEA,gCAAgC,KAAwB;AACtD,YAAM,CAAC,eAAe,IAAI,IAAI,MAAM,GAAG;AACvC,YAAM,gBAAgB,KAAK;AAAA,QACzB;AAAA,MACF;AAEA,UAAI,iBAAiB,mBAAK,kBAAiB,GAAG,GAAG;AAC/C,cAAM,WAAW,mBAAK,kBAAiB,GAAG;AAC1C,YAAI,UAAU;AACZ,wBAAc,aAAa,eAAe,UAAU,QAAQ;AAC5D,iBAAO,mBAAK,kBAAiB,GAAG;AAAA,QAClC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AA9CE;AAgDF,SAAOA;AACT;AAEA,IAAM,QAAN,MAAY;AAAC;AAEN,IAAM,oCACX,mCAAmC,KAAK;AACnC,IAAM,gCACX,mCAAmC,cAAc;AAC5C,IAAM,kCACX,mCAAmC,gBAAgB;","names":["BlockTrackerPollingController"]}