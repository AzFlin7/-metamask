{"version":3,"file":"TokenRatesController.js","sourceRoot":"","sources":["../src/TokenRatesController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n  FALL_BACK_VS_CURRENCY,\n  toHex,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { createDeferredPromise, type Hex } from '@metamask/utils';\nimport { isEqual } from 'lodash';\n\nimport { reduceInBatchesSerially, TOKEN_PRICES_BATCH_SIZE } from './assetsUtil';\nimport { fetchExchangeRate as fetchNativeCurrencyExchangeRate } from './crypto-compare';\nimport type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';\nimport type { TokensState } from './TokensController';\n\n/**\n * @type Token\n *\n * Token representation\n * @property address - Hex address of the token contract\n * @property decimals - Number of decimals the token uses\n * @property symbol - Symbol of the token\n * @property image - Image of the token, url or bit32 image\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Token {\n  address: string;\n  decimals: number;\n  symbol: string;\n  aggregators?: string[];\n  image?: string;\n  balanceError?: unknown;\n  isERC721?: boolean;\n  name?: string;\n}\n\n/**\n * @type TokenRatesConfig\n *\n * Token rates controller configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property nativeCurrency - Current native currency selected to use base of rates\n * @property chainId - Current network chainId\n * @property tokens - List of tokens to track exchange rates for\n * @property threshold - Threshold to invalidate the supportedChains\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesConfig extends BaseConfig {\n  interval: number;\n  nativeCurrency: string;\n  chainId: Hex;\n  selectedAddress: string;\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  threshold: number;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ContractExchangeRates {\n  [address: string]: number | undefined;\n}\n\nenum PollState {\n  Active = 'Active',\n  Inactive = 'Inactive',\n}\n\n/**\n * @type TokenRatesState\n *\n * Token rates controller state\n * @property contractExchangeRates - Hash of token contract addresses to exchange rates (single globally selected chain, will be deprecated soon)\n * @property contractExchangeRatesByChainId - Hash of token contract addresses to exchange rates keyed by chain ID and native currency (ticker)\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesState extends BaseState {\n  contractExchangeRates: ContractExchangeRates;\n  contractExchangeRatesByChainId: Record<\n    Hex,\n    Record<string, ContractExchangeRates>\n  >;\n}\n\n/**\n * Uses the CryptoCompare API to fetch the exchange rate between one currency\n * and another, i.e., the multiplier to apply the amount of one currency in\n * order to convert it to another.\n *\n * @param args - The arguments to this function.\n * @param args.from - The currency to convert from.\n * @param args.to - The currency to convert to.\n * @returns The exchange rate between `fromCurrency` to `toCurrency` if one\n * exists, or null if one does not.\n */\nasync function getCurrencyConversionRate({\n  from,\n  to,\n}: {\n  from: string;\n  to: string;\n}) {\n  const includeUSDRate = false;\n  try {\n    const result = await fetchNativeCurrencyExchangeRate(\n      to,\n      from,\n      includeUSDRate,\n    );\n    return result.conversionRate;\n  } catch (error) {\n    if (\n      error instanceof Error &&\n      error.message.includes('market does not exist for this coin pair')\n    ) {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Controller that passively polls on a set interval for token-to-fiat exchange rates\n * for tokens stored in the TokensController\n */\nexport class TokenRatesController extends StaticIntervalPollingControllerV1<\n  TokenRatesConfig,\n  TokenRatesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  #pollState = PollState.Inactive;\n\n  #tokenPricesService: AbstractTokenPricesService;\n\n  #inProcessExchangeRateUpdates: Record<`${Hex}:${string}`, Promise<void>> = {};\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenRatesController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a TokenRatesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.interval - The polling interval in ms\n   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.ticker - The ticker for the current network.\n   * @param options.selectedAddress - The current selected address.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network state changes.\n   * @param options.tokenPricesService - An object in charge of retrieving token prices.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      interval = 3 * 60 * 1000,\n      threshold = 6 * 60 * 60 * 1000,\n      getNetworkClientById,\n      chainId: initialChainId,\n      ticker: initialTicker,\n      selectedAddress: initialSelectedAddress,\n      onPreferencesStateChange,\n      onTokensStateChange,\n      onNetworkStateChange,\n      tokenPricesService,\n    }: {\n      interval?: number;\n      threshold?: number;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      chainId: Hex;\n      ticker: string;\n      selectedAddress: string;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onTokensStateChange: (\n        listener: (tokensState: TokensState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      tokenPricesService: AbstractTokenPricesService;\n    },\n    config?: Partial<TokenRatesConfig>,\n    state?: Partial<TokenRatesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval,\n      threshold,\n      disabled: false,\n      nativeCurrency: initialTicker,\n      chainId: initialChainId,\n      selectedAddress: initialSelectedAddress,\n      allTokens: {}, // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration\n      allDetectedTokens: {},\n    };\n\n    this.defaultState = {\n      contractExchangeRates: {},\n      contractExchangeRatesByChainId: {},\n    };\n    this.initialize();\n    this.setIntervalLength(interval);\n    this.getNetworkClientById = getNetworkClientById;\n    this.#tokenPricesService = tokenPricesService;\n\n    if (config?.disabled) {\n      this.configure({ disabled: true }, false, false);\n    }\n\n    onPreferencesStateChange(async ({ selectedAddress }) => {\n      if (this.config.selectedAddress !== selectedAddress) {\n        this.configure({ selectedAddress });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n\n    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {\n      const previousTokenAddresses = this.#getTokenAddresses(\n        this.config.chainId,\n      );\n      this.configure({ allTokens, allDetectedTokens });\n      const newTokenAddresses = this.#getTokenAddresses(this.config.chainId);\n      if (\n        !isEqual(previousTokenAddresses, newTokenAddresses) &&\n        this.#pollState === PollState.Active\n      ) {\n        await this.updateExchangeRates();\n      }\n    });\n\n    onNetworkStateChange(async ({ providerConfig }) => {\n      const { chainId, ticker } = providerConfig;\n      if (\n        this.config.chainId !== chainId ||\n        this.config.nativeCurrency !== ticker\n      ) {\n        this.update({ contractExchangeRates: {} });\n        this.configure({ chainId, nativeCurrency: ticker });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the user's tokens for the given chain.\n   *\n   * @param chainId - The chain ID.\n   * @returns The list of tokens addresses for the current chain\n   */\n  #getTokenAddresses(chainId: Hex): Hex[] {\n    const { allTokens, allDetectedTokens } = this.config;\n    const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];\n    const detectedTokens =\n      allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];\n\n    return [\n      ...new Set(\n        [...tokens, ...detectedTokens].map((token) =>\n          toHex(toChecksumHexAddress(token.address)),\n        ),\n      ),\n    ].sort();\n  }\n\n  /**\n   * Start (or restart) polling.\n   */\n  async start() {\n    this.#stopPoll();\n    this.#pollState = PollState.Active;\n    await this.#poll();\n  }\n\n  /**\n   * Stop polling.\n   */\n  stop() {\n    this.#stopPoll();\n    this.#pollState = PollState.Inactive;\n  }\n\n  /**\n   * Clear the active polling timer, if present.\n   */\n  #stopPoll() {\n    if (this.handle) {\n      clearTimeout(this.handle);\n    }\n  }\n\n  /**\n   * Poll for exchange rate updates.\n   */\n  async #poll() {\n    await safelyExecute(() => this.updateExchangeRates());\n\n    // Poll using recursive `setTimeout` instead of `setInterval` so that\n    // requests don't stack if they take longer than the polling interval\n    this.handle = setTimeout(() => {\n      this.#poll();\n    }, this.config.interval);\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   */\n  async updateExchangeRates() {\n    const { chainId, nativeCurrency } = this.config;\n    await this.updateExchangeRatesByChainId({\n      chainId,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   *\n   * @param options - The options to fetch exchange rates.\n   * @param options.chainId - The chain ID.\n   * @param options.nativeCurrency - The ticker for the chain.\n   */\n  async updateExchangeRatesByChainId({\n    chainId,\n    nativeCurrency,\n  }: {\n    chainId: Hex;\n    nativeCurrency: string;\n  }) {\n    if (this.disabled) {\n      return;\n    }\n\n    const tokenAddresses = this.#getTokenAddresses(chainId);\n    if (tokenAddresses.length === 0) {\n      return;\n    }\n\n    const updateKey: `${Hex}:${string}` = `${chainId}:${nativeCurrency}`;\n    if (updateKey in this.#inProcessExchangeRateUpdates) {\n      // This prevents redundant updates\n      // This promise is resolved after the in-progress update has finished,\n      // and state has been updated.\n      await this.#inProcessExchangeRateUpdates[updateKey];\n      return;\n    }\n\n    const {\n      promise: inProgressUpdate,\n      resolve: updateSucceeded,\n      reject: updateFailed,\n    } = createDeferredPromise({ suppressUnhandledRejection: true });\n    this.#inProcessExchangeRateUpdates[updateKey] = inProgressUpdate;\n\n    try {\n      const newContractExchangeRates = await this.#fetchAndMapExchangeRates({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n\n      const existingContractExchangeRates = this.state.contractExchangeRates;\n      const updatedContractExchangeRates =\n        chainId === this.config.chainId &&\n        nativeCurrency === this.config.nativeCurrency\n          ? newContractExchangeRates\n          : existingContractExchangeRates;\n\n      const existingContractExchangeRatesForChainId =\n        this.state.contractExchangeRatesByChainId[chainId] ?? {};\n      const updatedContractExchangeRatesForChainId = {\n        ...this.state.contractExchangeRatesByChainId,\n        [chainId]: {\n          ...existingContractExchangeRatesForChainId,\n          [nativeCurrency]: {\n            ...existingContractExchangeRatesForChainId[nativeCurrency],\n            ...newContractExchangeRates,\n          },\n        },\n      };\n\n      this.update({\n        contractExchangeRates: updatedContractExchangeRates,\n        contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId,\n      });\n      updateSucceeded();\n    } catch (error: unknown) {\n      updateFailed(error);\n      throw error;\n    } finally {\n      delete this.#inProcessExchangeRateUpdates[updateKey];\n    }\n  }\n\n  /**\n   * Uses the token prices service to retrieve exchange rates for tokens in a\n   * particular currency.\n   *\n   * If the price API does not support the given chain ID, returns an empty\n   * object.\n   *\n   * If the price API does not support the given currency, retrieves exchange\n   * rates in a known currency instead, then converts those rates using the\n   * exchange rate between the known currency and desired currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * exchange rates.\n   * @returns A map from token address to its exchange rate in the native\n   * currency, or an empty map if no exchange rates can be obtained for the\n   * chain ID.\n   */\n  async #fetchAndMapExchangeRates({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    if (!this.#tokenPricesService.validateChainIdSupported(chainId)) {\n      return tokenAddresses.reduce((obj, tokenAddress) => {\n        return {\n          ...obj,\n          [tokenAddress]: undefined,\n        };\n      }, {});\n    }\n\n    if (this.#tokenPricesService.validateCurrencySupported(nativeCurrency)) {\n      return await this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n    }\n\n    return await this.#fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n      tokenAddresses,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates token rates for the given networkClientId\n   *\n   * @param networkClientId - The network client ID used to get a ticker value.\n   * @returns The controller state.\n   */\n  async _executePoll(networkClientId: NetworkClientId): Promise<void> {\n    const networkClient = this.getNetworkClientById(networkClientId);\n    await this.updateExchangeRatesByChainId({\n      chainId: networkClient.configuration.chainId,\n      nativeCurrency: networkClient.configuration.ticker,\n    });\n  }\n\n  /**\n   * Retrieves prices in the given currency for the given tokens on the given\n   * chain. Ensures that token addresses are checksum addresses.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForSupportedNativeCurrency({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const tokenPricesByTokenAddress = await reduceInBatchesSerially<\n      Hex,\n      Awaited<ReturnType<AbstractTokenPricesService['fetchTokenPrices']>>\n    >({\n      values: [...tokenAddresses].sort(),\n      batchSize: TOKEN_PRICES_BATCH_SIZE,\n      eachBatch: async (allTokenPricesByTokenAddress, batch) => {\n        const tokenPricesByTokenAddressForBatch =\n          await this.#tokenPricesService.fetchTokenPrices({\n            tokenAddresses: batch,\n            chainId,\n            currency: nativeCurrency,\n          });\n\n        return {\n          ...allTokenPricesByTokenAddress,\n          ...tokenPricesByTokenAddressForBatch,\n        };\n      },\n      initialResult: {},\n    });\n\n    return Object.entries(tokenPricesByTokenAddress).reduce(\n      (obj, [tokenAddress, tokenPrice]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenPrice?.value,\n        };\n      },\n      {},\n    );\n  }\n\n  /**\n   * If the price API does not support a given native currency, then we need to\n   * convert it to a fallback currency and feed that currency into the price\n   * API, then convert the prices to our desired native currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n    tokenAddresses,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const [\n      contractExchangeRates,\n      fallbackCurrencyToNativeCurrencyConversionRate,\n    ] = await Promise.all([\n      this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId: this.config.chainId,\n        nativeCurrency: FALL_BACK_VS_CURRENCY,\n      }),\n      getCurrencyConversionRate({\n        from: FALL_BACK_VS_CURRENCY,\n        to: nativeCurrency,\n      }),\n    ]);\n\n    if (fallbackCurrencyToNativeCurrencyConversionRate === null) {\n      return {};\n    }\n\n    return Object.entries(contractExchangeRates).reduce(\n      (obj, [tokenAddress, tokenValue]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenValue\n            ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate\n            : undefined,\n        };\n      },\n      {},\n    );\n  }\n}\n\nexport default TokenRatesController;\n"]}