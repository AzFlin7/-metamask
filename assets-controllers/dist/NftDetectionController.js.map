{"version":3,"file":"NftDetectionController.js","sourceRoot":"","sources":["../src/NftDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  OPENSEA_PROXY_URL,\n  fetchWithErrorHandling,\n  toChecksumHexAddress,\n  ChainId,\n  timeoutFetch,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n  NetworkClient,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport { mapOpenSeaNftV2ToV1 } from './assetsUtil';\nimport { Source } from './constants';\nimport type { OpenSeaV2GetNftResponse } from './NftController';\nimport {\n  type NftController,\n  type NftState,\n  type NftMetadata,\n  type OpenSeaV2ListNftsResponse,\n  OpenSeaV2ChainIds,\n} from './NftController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type ApiNft\n *\n * NFT object coming from OpenSea api\n * @property token_id - The NFT identifier\n * @property num_sales - Number of sales\n * @property background_color - The background color to be displayed with the item\n * @property image_url - URI of an image associated with this NFT\n * @property image_preview_url - URI of a smaller image associated with this NFT\n * @property image_thumbnail_url - URI of a thumbnail image associated with this NFT\n * @property image_original_url - URI of the original image associated with this NFT\n * @property animation_url - URI of a animation associated with this NFT\n * @property animation_original_url - URI of the original animation associated with this NFT\n * @property name - The NFT name\n * @property description - The NFT description\n * @property external_link - External link containing additional information\n * @property assetContract - The NFT contract information object\n * @property creator - The NFT owner information object\n * @property lastSale - When this item was last sold\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ApiNft {\n  token_id: string;\n  num_sales: number | null;\n  background_color: string | null;\n  image_url: string | null;\n  image_preview_url: string | null;\n  image_thumbnail_url: string | null;\n  image_original_url: string | null;\n  animation_url: string | null;\n  animation_original_url: string | null;\n  name: string | null;\n  description: string | null;\n  external_link: string | null;\n  asset_contract: ApiNftContract;\n  creator: ApiNftCreator;\n  last_sale: ApiNftLastSale | null;\n}\n\n/**\n * @type ApiNftContract\n *\n * NFT contract object coming from OpenSea api\n * @property address - Address of the NFT contract\n * @property asset_contract_type - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property created_date - Creation date\n * @property collection - Object containing the contract name and URI of an image associated\n * @property schema_name - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property symbol - The NFT contract symbol\n * @property total_supply - Total supply of NFTs\n * @property description - The NFT contract description\n * @property external_link - External link containing additional information\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ApiNftContract {\n  address: string;\n  asset_contract_type: string | null;\n  created_date: string | null;\n  schema_name: string | null;\n  symbol: string | null;\n  total_supply: string | null;\n  description: string | null;\n  external_link: string | null;\n  collection: {\n    name: string | null;\n    image_url?: string | null;\n  };\n}\n\n/**\n * @type ApiNftLastSale\n *\n * NFT sale object coming from OpenSea api\n * @property event_timestamp - Object containing a `username`\n * @property total_price - URI of NFT image associated with this owner\n * @property transaction - Object containing transaction_hash and block_hash\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ApiNftLastSale {\n  event_timestamp: string;\n  total_price: string;\n  transaction: { transaction_hash: string; block_hash: string };\n}\n\n/**\n * @type ApiNftCreator\n *\n * NFT creator object coming from OpenSea api\n * @property user - Object containing a `username`\n * @property profile_img_url - URI of NFT image associated with this owner\n * @property address - The owner address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ApiNftCreator {\n  user: { username: string };\n  profile_img_url: string;\n  address: string;\n}\n\n/**\n * @type NftDetectionConfig\n *\n * NftDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property chainId - Current chain ID\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftDetectionConfig extends BaseConfig {\n  interval: number;\n  chainId: Hex;\n  selectedAddress: string;\n}\n\n/**\n * Controller that passively polls on a set interval for NFT auto detection\n */\nexport class NftDetectionController extends StaticIntervalPollingControllerV1<\n  NftDetectionConfig,\n  BaseState\n> {\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private getOwnerNftApi({\n    address,\n    next,\n  }: {\n    address: string;\n    next?: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/chain/${\n      OpenSeaV2ChainIds.ethereum\n    }/account/${address}/nfts?limit=200&next=${next ?? ''}`;\n  }\n\n  private async getOwnerNfts(address: string) {\n    let nftApiResponse: OpenSeaV2ListNftsResponse;\n    let nfts: ApiNft[] = [];\n    let next;\n\n    do {\n      nftApiResponse = await fetchWithErrorHandling({\n        url: this.getOwnerNftApi({ address, next }),\n        timeout: 15000,\n      });\n\n      if (!nftApiResponse) {\n        return nfts;\n      }\n\n      const newNfts = await Promise.all(\n        nftApiResponse.nfts.map(async (nftV2) => {\n          const nftV1 = mapOpenSeaNftV2ToV1(nftV2);\n\n          // If the image hasn't been processed into OpenSea's CDN, the image_url will be null.\n          // Try fetching the NFT individually, which returns the original image url from metadata if available.\n          if (!nftV1.image_url && nftV2.metadata_url) {\n            const nftDetails: OpenSeaV2GetNftResponse | undefined =\n              await safelyExecute(() =>\n                timeoutFetch(\n                  this.getNftApi({\n                    contractAddress: nftV2.contract,\n                    tokenId: nftV2.identifier,\n                  }),\n                  undefined,\n                  1000,\n                ).then((r) => r.json()),\n              );\n\n            nftV1.image_original_url = nftDetails?.nft?.image_url ?? null;\n          }\n          return nftV1;\n        }),\n      );\n\n      nfts = [...nfts, ...newNfts];\n    } while ((next = nftApiResponse.next));\n\n    return nfts;\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftDetectionController';\n\n  private readonly getOpenSeaApiKey: () => string | undefined;\n\n  private readonly addNft: NftController['addNft'];\n\n  private readonly getNftApi: NftController['getNftApi'];\n\n  private readonly getNftState: () => NftState;\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates an NftDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNftsStateChange - Allows subscribing to assets controller state changes.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.\n   * @param options.addNft - Add an NFT.\n   * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.\n   * @param options.getNftState - Gets the current state of the Assets controller.\n   * @param options.getNetworkClientById - Gets the network client by ID, from the NetworkController.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      getNetworkClientById,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getOpenSeaApiKey,\n      addNft,\n      getNftApi,\n      getNftState,\n    }: {\n      chainId: Hex;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      onNftsStateChange: (listener: (nftsState: NftState) => void) => void;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getOpenSeaApiKey: () => string | undefined;\n      addNft: NftController['addNft'];\n      getNftApi: NftController['getNftApi'];\n      getNftState: () => NftState;\n    },\n    config?: Partial<NftDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      chainId: initialChainId,\n      selectedAddress: '',\n      disabled: true,\n    };\n    this.initialize();\n    this.getNftState = getNftState;\n    this.getNetworkClientById = getNetworkClientById;\n    onPreferencesStateChange(({ selectedAddress, useNftDetection }) => {\n      const { selectedAddress: previouslySelectedAddress, disabled } =\n        this.config;\n\n      if (\n        selectedAddress !== previouslySelectedAddress ||\n        !useNftDetection !== disabled\n      ) {\n        this.configure({ selectedAddress, disabled: !useNftDetection });\n        if (useNftDetection) {\n          this.start();\n        } else {\n          this.stop();\n        }\n      }\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      this.configure({\n        chainId: providerConfig.chainId,\n      });\n    });\n    this.getOpenSeaApiKey = getOpenSeaApiKey;\n    this.addNft = addNft;\n    this.getNftApi = getNftApi;\n    this.setIntervalLength(this.config.interval);\n  }\n\n  async _executePoll(\n    networkClientId: string,\n    options: { address: string },\n  ): Promise<void> {\n    await this.detectNfts({ networkClientId, userAddress: options.address });\n  }\n\n  /**\n   * Start polling for the currency rate.\n   */\n  async start() {\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the currency rate.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectNfts();\n    this.intervalId = setInterval(async () => {\n      await this.detectNfts();\n    }, this.config.interval);\n  }\n\n  /**\n   * Checks whether network is mainnet or not.\n   *\n   * @returns Whether current network is mainnet.\n   */\n  isMainnet = (): boolean => this.config.chainId === ChainId.mainnet;\n\n  isMainnetByNetworkClientId = (networkClient: NetworkClient): boolean => {\n    return networkClient.configuration.chainId === ChainId.mainnet;\n  };\n\n  /**\n   * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are\n   * added.\n   *\n   * @param options - Options bag.\n   * @param options.networkClientId - The network client ID to detect NFTs on.\n   * @param options.userAddress - The address to detect NFTs for.\n   */\n  async detectNfts(\n    {\n      networkClientId,\n      userAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress: string;\n    } = { userAddress: this.config.selectedAddress },\n  ) {\n    /* istanbul ignore if */\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n    /* istanbul ignore else */\n    if (!userAddress) {\n      return;\n    }\n\n    const apiNfts = await this.getOwnerNfts(userAddress);\n    const addNftPromises = apiNfts.map(async (nft: ApiNft) => {\n      const {\n        token_id,\n        num_sales,\n        background_color,\n        image_url,\n        image_preview_url,\n        image_thumbnail_url,\n        image_original_url,\n        animation_url,\n        animation_original_url,\n        name,\n        description,\n        external_link,\n        creator,\n        asset_contract: { address, schema_name },\n        last_sale,\n      } = nft;\n\n      let ignored;\n      /* istanbul ignore else */\n      const { ignoredNfts } = this.getNftState();\n      if (ignoredNfts.length) {\n        ignored = ignoredNfts.find((c) => {\n          /* istanbul ignore next */\n          return (\n            c.address === toChecksumHexAddress(address) &&\n            c.tokenId === token_id\n          );\n        });\n      }\n\n      /* istanbul ignore else */\n      if (!ignored) {\n        /* istanbul ignore next */\n        const nftMetadata: NftMetadata = Object.assign(\n          {},\n          { name },\n          creator && { creator },\n          description && { description },\n          image_url && { image: image_url },\n          num_sales && { numberOfSales: num_sales },\n          background_color && { backgroundColor: background_color },\n          image_preview_url && { imagePreview: image_preview_url },\n          image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n          image_original_url && { imageOriginal: image_original_url },\n          animation_url && { animation: animation_url },\n          animation_original_url && {\n            animationOriginal: animation_original_url,\n          },\n          schema_name && { standard: schema_name },\n          external_link && { externalLink: external_link },\n          last_sale && { lastSale: last_sale },\n        );\n\n        await this.addNft(address, token_id, {\n          nftMetadata,\n          userAddress,\n          source: Source.Detected,\n          networkClientId,\n        });\n      }\n    });\n    await Promise.all(addNftPromises);\n  }\n}\n\nexport default NftDetectionController;\n"]}