{"version":3,"file":"TokenDetectionController.js","sourceRoot":"","sources":["../src/TokenDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  AccountsControllerGetSelectedAccountAction,\n  AccountsControllerSelectedAccountChangeEvent,\n} from '@metamask/accounts-controller';\nimport type {\n  RestrictedControllerMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport contractMap from '@metamask/contract-metadata';\nimport { ChainId, safelyExecute } from '@metamask/controller-utils';\nimport type {\n  KeyringControllerGetStateAction,\n  KeyringControllerLockEvent,\n  KeyringControllerUnlockEvent,\n} from '@metamask/keyring-controller';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerGetNetworkConfigurationByNetworkClientId,\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkDidChangeEvent,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport type {\n  PreferencesControllerGetStateAction,\n  PreferencesControllerStateChangeEvent,\n} from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { isTokenDetectionSupportedForNetwork } from './assetsUtil';\nimport type {\n  GetTokenListState,\n  TokenListMap,\n  TokenListStateChange,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\nimport type {\n  TokensControllerAddDetectedTokensAction,\n  TokensControllerGetStateAction,\n} from './TokensController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * Compare 2 given strings and return boolean\n * eg: \"foo\" and \"FOO\" => true\n * eg: \"foo\" and \"bar\" => false\n * eg: \"foo\" and 123 => false\n *\n * @param value1 - first string to compare\n * @param value2 - first string to compare\n * @returns true if 2 strings are identical when they are lowercase\n */\nexport function isEqualCaseInsensitive(\n  value1: string,\n  value2: string,\n): boolean {\n  if (typeof value1 !== 'string' || typeof value2 !== 'string') {\n    return false;\n  }\n  return value1.toLowerCase() === value2.toLowerCase();\n}\n\ntype LegacyToken = {\n  name: string;\n  logo: `${string}.svg`;\n  symbol: string;\n  decimals: number;\n  erc20?: boolean;\n  erc721?: boolean;\n};\n\ntype TokenDetectionMap = {\n  [P in keyof TokenListMap]: Omit<TokenListMap[P], 'occurrences'>;\n};\n\nexport const STATIC_MAINNET_TOKEN_LIST = Object.entries<LegacyToken>(\n  contractMap,\n).reduce<TokenDetectionMap>((acc, [base, contract]) => {\n  const { logo, erc20, erc721, ...tokenMetadata } = contract;\n  return {\n    ...acc,\n    [base.toLowerCase()]: {\n      ...tokenMetadata,\n      address: base.toLowerCase(),\n      iconUrl: `images/contract/${logo}`,\n      aggregators: [],\n    },\n  };\n}, {});\n\nexport const controllerName = 'TokenDetectionController';\n\nexport type TokenDetectionState = Record<never, never>;\n\nexport type TokenDetectionControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  TokenDetectionState\n>;\n\nexport type TokenDetectionControllerActions =\n  TokenDetectionControllerGetStateAction;\n\nexport type AllowedActions =\n  | AccountsControllerGetSelectedAccountAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetNetworkConfigurationByNetworkClientId\n  | NetworkControllerGetStateAction\n  | GetTokenListState\n  | KeyringControllerGetStateAction\n  | PreferencesControllerGetStateAction\n  | TokensControllerGetStateAction\n  | TokensControllerAddDetectedTokensAction;\n\nexport type TokenDetectionControllerStateChangeEvent =\n  ControllerStateChangeEvent<typeof controllerName, TokenDetectionState>;\n\nexport type TokenDetectionControllerEvents =\n  TokenDetectionControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | AccountsControllerSelectedAccountChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | TokenListStateChange\n  | KeyringControllerLockEvent\n  | KeyringControllerUnlockEvent\n  | PreferencesControllerStateChangeEvent;\n\nexport type TokenDetectionControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokenDetectionControllerActions | AllowedActions,\n  TokenDetectionControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Controller that passively polls on a set interval for Tokens auto detection\n * @property intervalId - Polling interval used to fetch new token rates\n * @property selectedAddress - Vault selected address\n * @property networkClientId - The network client ID of the current selected network\n * @property disabled - Boolean to track if network requests are blocked\n * @property isUnlocked - Boolean to track if the keyring state is unlocked\n * @property isDetectionEnabledFromPreferences - Boolean to track if detection is enabled from PreferencesController\n * @property isDetectionEnabledForNetwork - Boolean to track if detected is enabled for current network\n */\nexport class TokenDetectionController extends StaticIntervalPollingController<\n  typeof controllerName,\n  TokenDetectionState,\n  TokenDetectionControllerMessenger\n> {\n  #intervalId?: ReturnType<typeof setTimeout>;\n\n  #selectedAddress: string;\n\n  #networkClientId: NetworkClientId;\n\n  #tokenList: TokenDetectionMap = {};\n\n  #disabled: boolean;\n\n  #isUnlocked: boolean;\n\n  #isDetectionEnabledFromPreferences: boolean;\n\n  #isDetectionEnabledForNetwork: boolean;\n\n  readonly #getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n\n  readonly #trackMetaMetricsEvent: (options: {\n    event: string;\n    category: string;\n    properties: {\n      tokens: string[];\n      token_standard: string;\n      asset_type: string;\n    };\n  }) => void;\n\n  /**\n   * Creates a TokenDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.messenger - The controller messaging system.\n   * @param options.disabled - If set to true, all network requests are blocked.\n   * @param options.interval - Polling interval used to fetch new token rates\n   * @param options.selectedAddress - Vault selected address\n   * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.\n   * @param options.trackMetaMetricsEvent - Sets options for MetaMetrics event tracking.\n   */\n  constructor({\n    selectedAddress,\n    interval = DEFAULT_INTERVAL,\n    disabled = true,\n    getBalancesInSingleCall,\n    trackMetaMetricsEvent,\n    messenger,\n  }: {\n    selectedAddress?: string;\n    interval?: number;\n    disabled?: boolean;\n    getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n    trackMetaMetricsEvent: (options: {\n      event: string;\n      category: string;\n      properties: {\n        tokens: string[];\n        token_standard: string;\n        asset_type: string;\n      };\n    }) => void;\n    messenger: TokenDetectionControllerMessenger;\n  }) {\n    super({\n      name: controllerName,\n      messenger,\n      state: {},\n      metadata: {},\n    });\n\n    this.#disabled = disabled;\n    this.setIntervalLength(interval);\n\n    this.#selectedAddress =\n      selectedAddress ??\n      this.messagingSystem.call('AccountsController:getSelectedAccount')\n        .address;\n\n    const { chainId, networkClientId } =\n      this.#getCorrectChainIdAndNetworkClientId();\n    this.#networkClientId = networkClientId;\n\n    const { useTokenDetection: defaultUseTokenDetection } =\n      this.messagingSystem.call('PreferencesController:getState');\n    this.#isDetectionEnabledFromPreferences = defaultUseTokenDetection;\n    this.#isDetectionEnabledForNetwork =\n      isTokenDetectionSupportedForNetwork(chainId);\n\n    this.#getBalancesInSingleCall = getBalancesInSingleCall;\n\n    this.#trackMetaMetricsEvent = trackMetaMetricsEvent;\n\n    const { isUnlocked } = this.messagingSystem.call(\n      'KeyringController:getState',\n    );\n    this.#isUnlocked = isUnlocked;\n\n    this.#registerEventListeners();\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system subscriptions to controller events.\n   */\n  #registerEventListeners() {\n    this.messagingSystem.subscribe('KeyringController:unlock', async () => {\n      this.#isUnlocked = true;\n      await this.#restartTokenDetection();\n    });\n\n    this.messagingSystem.subscribe('KeyringController:lock', () => {\n      this.#isUnlocked = false;\n      this.#stopPolling();\n    });\n\n    this.messagingSystem.subscribe(\n      'TokenListController:stateChange',\n      async ({ tokenList }) => {\n        const hasTokens = Object.keys(tokenList).length;\n\n        if (hasTokens) {\n          await this.#restartTokenDetection();\n        }\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'PreferencesController:stateChange',\n      async ({ selectedAddress: newSelectedAddress, useTokenDetection }) => {\n        const isSelectedAddressChanged =\n          this.#selectedAddress !== newSelectedAddress;\n        const isDetectionChangedFromPreferences =\n          this.#isDetectionEnabledFromPreferences !== useTokenDetection;\n\n        this.#selectedAddress = newSelectedAddress;\n        this.#isDetectionEnabledFromPreferences = useTokenDetection;\n\n        if (\n          useTokenDetection &&\n          (isSelectedAddressChanged || isDetectionChangedFromPreferences)\n        ) {\n          await this.#restartTokenDetection({\n            selectedAddress: this.#selectedAddress,\n          });\n        }\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'AccountsController:selectedAccountChange',\n      async ({ address: newSelectedAddress }) => {\n        const isSelectedAddressChanged =\n          this.#selectedAddress !== newSelectedAddress;\n        if (\n          isSelectedAddressChanged &&\n          this.#isDetectionEnabledFromPreferences\n        ) {\n          this.#selectedAddress = newSelectedAddress;\n          await this.#restartTokenDetection({\n            selectedAddress: this.#selectedAddress,\n          });\n        }\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      async ({ selectedNetworkClientId }) => {\n        const isNetworkClientIdChanged =\n          this.#networkClientId !== selectedNetworkClientId;\n\n        const { chainId: newChainId } =\n          this.#getCorrectChainIdAndNetworkClientId(selectedNetworkClientId);\n        this.#isDetectionEnabledForNetwork =\n          isTokenDetectionSupportedForNetwork(newChainId);\n\n        if (isNetworkClientIdChanged && this.#isDetectionEnabledForNetwork) {\n          this.#networkClientId = selectedNetworkClientId;\n          await this.#restartTokenDetection({\n            networkClientId: this.#networkClientId,\n          });\n        }\n      },\n    );\n  }\n\n  /**\n   * Allows controller to make active and passive polling requests\n   */\n  enable(): void {\n    this.#disabled = false;\n  }\n\n  /**\n   * Blocks controller from making network calls\n   */\n  disable(): void {\n    this.#disabled = true;\n  }\n\n  /**\n   * Internal isActive state\n   * @type {boolean}\n   */\n  get isActive(): boolean {\n    return !this.#disabled && this.#isUnlocked;\n  }\n\n  /**\n   * Start polling for detected tokens.\n   */\n  async start(): Promise<void> {\n    this.enable();\n    await this.#startPolling();\n  }\n\n  /**\n   * Stop polling for detected tokens.\n   */\n  stop(): void {\n    this.disable();\n    this.#stopPolling();\n  }\n\n  #stopPolling(): void {\n    if (this.#intervalId) {\n      clearInterval(this.#intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  async #startPolling(): Promise<void> {\n    if (!this.isActive) {\n      return;\n    }\n    this.#stopPolling();\n    await this.detectTokens();\n    this.#intervalId = setInterval(async () => {\n      await this.detectTokens();\n    }, this.getIntervalLength());\n  }\n\n  #getCorrectChainIdAndNetworkClientId(networkClientId?: NetworkClientId): {\n    chainId: Hex;\n    networkClientId: NetworkClientId;\n  } {\n    if (networkClientId) {\n      const networkConfiguration = this.messagingSystem.call(\n        'NetworkController:getNetworkConfigurationByNetworkClientId',\n        networkClientId,\n      );\n      if (networkConfiguration) {\n        return {\n          chainId: networkConfiguration.chainId,\n          networkClientId,\n        };\n      }\n    }\n    const { selectedNetworkClientId } = this.messagingSystem.call(\n      'NetworkController:getState',\n    );\n    const {\n      configuration: { chainId },\n    } = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      selectedNetworkClientId,\n    );\n    return {\n      chainId,\n      networkClientId: selectedNetworkClientId,\n    };\n  }\n\n  async _executePoll(\n    networkClientId: NetworkClientId,\n    options: { address: string },\n  ): Promise<void> {\n    if (!this.isActive) {\n      return;\n    }\n    await this.detectTokens({\n      networkClientId,\n      selectedAddress: options.address,\n    });\n  }\n\n  /**\n   * Restart token detection polling period and call detectNewTokens\n   * in case of address change or user session initialization.\n   *\n   * @param options - Options for restart token detection.\n   * @param options.selectedAddress - the selectedAddress against which to detect for token balances\n   * @param options.networkClientId - The ID of the network client to use.\n   */\n  async #restartTokenDetection({\n    selectedAddress,\n    networkClientId,\n  }: {\n    selectedAddress?: string;\n    networkClientId?: NetworkClientId;\n  } = {}): Promise<void> {\n    await this.detectTokens({\n      networkClientId,\n      selectedAddress,\n    });\n    this.setIntervalLength(DEFAULT_INTERVAL);\n  }\n\n  /**\n   * For each token in the token list provided by the TokenListController, checks the token's balance for the selected account address on the active network.\n   * On mainnet, if token detection is disabled in preferences, ERC20 token auto detection will be triggered for each contract address in the legacy token list from the @metamask/contract-metadata repo.\n   *\n   * @param options - Options for token detection.\n   * @param options.networkClientId - The ID of the network client to use.\n   * @param options.selectedAddress - the selectedAddress against which to detect for token balances.\n   */\n  async detectTokens({\n    networkClientId,\n    selectedAddress,\n  }: {\n    networkClientId?: NetworkClientId;\n    selectedAddress?: string;\n  } = {}): Promise<void> {\n    if (!this.isActive) {\n      return;\n    }\n\n    const addressAgainstWhichToDetect =\n      selectedAddress ?? this.#selectedAddress;\n    const { chainId, networkClientId: selectedNetworkClientId } =\n      this.#getCorrectChainIdAndNetworkClientId(networkClientId);\n    const chainIdAgainstWhichToDetect = chainId;\n    const networkClientIdAgainstWhichToDetect = selectedNetworkClientId;\n\n    if (!isTokenDetectionSupportedForNetwork(chainIdAgainstWhichToDetect)) {\n      return;\n    }\n    if (\n      !this.#isDetectionEnabledFromPreferences &&\n      chainIdAgainstWhichToDetect !== ChainId.mainnet\n    ) {\n      return;\n    }\n    const isTokenDetectionInactiveInMainnet =\n      !this.#isDetectionEnabledFromPreferences &&\n      chainIdAgainstWhichToDetect === ChainId.mainnet;\n    const { tokensChainsCache } = this.messagingSystem.call(\n      'TokenListController:getState',\n    );\n    this.#tokenList = isTokenDetectionInactiveInMainnet\n      ? STATIC_MAINNET_TOKEN_LIST\n      : tokensChainsCache[chainIdAgainstWhichToDetect]?.data ?? {};\n\n    for (const tokensSlice of this.#getSlicesOfTokensToDetect({\n      chainId: chainIdAgainstWhichToDetect,\n      selectedAddress: addressAgainstWhichToDetect,\n    })) {\n      await this.#addDetectedTokens({\n        tokensSlice,\n        selectedAddress: addressAgainstWhichToDetect,\n        networkClientId: networkClientIdAgainstWhichToDetect,\n        chainId: chainIdAgainstWhichToDetect,\n      });\n    }\n  }\n\n  #getSlicesOfTokensToDetect({\n    chainId,\n    selectedAddress,\n  }: {\n    chainId: Hex;\n    selectedAddress: string;\n  }): string[][] {\n    const { allTokens, allDetectedTokens, allIgnoredTokens } =\n      this.messagingSystem.call('TokensController:getState');\n    const [tokensAddresses, detectedTokensAddresses, ignoredTokensAddresses] = [\n      allTokens,\n      allDetectedTokens,\n      allIgnoredTokens,\n    ].map((tokens) =>\n      (tokens[chainId]?.[selectedAddress] ?? []).map((value) =>\n        typeof value === 'string' ? value : value.address,\n      ),\n    );\n\n    const tokensToDetect: string[] = [];\n    for (const tokenAddress of Object.keys(this.#tokenList)) {\n      if (\n        [\n          tokensAddresses,\n          detectedTokensAddresses,\n          ignoredTokensAddresses,\n        ].every(\n          (addresses) =>\n            !addresses.find((address) =>\n              isEqualCaseInsensitive(address, tokenAddress),\n            ),\n        )\n      ) {\n        tokensToDetect.push(tokenAddress);\n      }\n    }\n\n    const slicesOfTokensToDetect = [];\n    for (let i = 0, size = 1000; i < tokensToDetect.length; i += size) {\n      slicesOfTokensToDetect.push(tokensToDetect.slice(i, i + size));\n    }\n\n    return slicesOfTokensToDetect;\n  }\n\n  async #addDetectedTokens({\n    tokensSlice,\n    selectedAddress,\n    networkClientId,\n    chainId,\n  }: {\n    tokensSlice: string[];\n    selectedAddress: string;\n    networkClientId: NetworkClientId;\n    chainId: Hex;\n  }): Promise<void> {\n    await safelyExecute(async () => {\n      const balances = await this.#getBalancesInSingleCall(\n        selectedAddress,\n        tokensSlice,\n        networkClientId,\n      );\n\n      const tokensWithBalance: Token[] = [];\n      const eventTokensDetails: string[] = [];\n      for (const nonZeroTokenAddress of Object.keys(balances)) {\n        const { decimals, symbol, aggregators, iconUrl, name } =\n          this.#tokenList[nonZeroTokenAddress];\n        eventTokensDetails.push(`${symbol} - ${nonZeroTokenAddress}`);\n        tokensWithBalance.push({\n          address: nonZeroTokenAddress,\n          decimals,\n          symbol,\n          aggregators,\n          image: iconUrl,\n          isERC721: false,\n          name,\n        });\n      }\n\n      if (tokensWithBalance.length) {\n        this.#trackMetaMetricsEvent({\n          event: 'Token Detected',\n          category: 'Wallet',\n          properties: {\n            tokens: eventTokensDetails,\n            token_standard: 'ERC20',\n            asset_type: 'TOKEN',\n          },\n        });\n\n        await this.messagingSystem.call(\n          'TokensController:addDetectedTokens',\n          tokensWithBalance,\n          {\n            selectedAddress,\n            chainId,\n          },\n        );\n      }\n    });\n  }\n}\n\nexport default TokenDetectionController;\n"]}