{"version":3,"file":"TokensController.js","sourceRoot":"","sources":["../src/TokensController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport contractsMap from '@metamask/contract-metadata';\nimport {\n  toChecksumHexAddress,\n  ERC721_INTERFACE_ID,\n  ORIGIN_METAMASK,\n  ApprovalType,\n  ERC20,\n  ERC721,\n  ERC1155,\n  isValidHexAddress,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerNetworkDidChangeEvent,\n  Provider,\n} from '@metamask/network-controller';\nimport type { PreferencesControllerStateChangeEvent } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { EventEmitter } from 'events';\nimport { v1 as random } from 'uuid';\n\nimport { formatAggregatorNames, formatIconUrlWithProxy } from './assetsUtil';\nimport { ERC20Standard } from './Standards/ERC20Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\nimport type {\n  TokenListMap,\n  TokenListStateChange,\n  TokenListToken,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\n\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokensConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  provider: Provider | undefined;\n}\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property id - Generated UUID associated with this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n * @property interactingAddress - Account address that requested watch asset\n */\ntype SuggestedAssetMeta = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n  interactingAddress: string;\n};\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n */\nexport type TokensState = {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [chainId: Hex]: { [key: string]: string[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n};\n\n/**\n * The name of the {@link TokensController}.\n */\nconst controllerName = 'TokensController';\n\nexport type TokensControllerActions =\n  | TokensControllerGetStateAction\n  | TokensControllerAddDetectedTokensAction;\n\nexport type TokensControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  TokensState\n>;\n\nexport type TokensControllerAddDetectedTokensAction = {\n  type: `${typeof controllerName}:addDetectedTokens`;\n  handler: TokensController['addDetectedTokens'];\n};\n\n/**\n * The external actions available to the {@link TokensController}.\n */\nexport type AllowedActions =\n  | AddApprovalRequest\n  | NetworkControllerGetNetworkClientByIdAction;\n\nexport type TokensControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  TokensState\n>;\n\nexport type TokensControllerEvents = TokensControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | NetworkControllerNetworkDidChangeEvent\n  | PreferencesControllerStateChangeEvent\n  | TokenListStateChange;\n\n/**\n * The messenger of the {@link TokensController}.\n */\nexport type TokensControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokensControllerActions | AllowedActions,\n  TokensControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport const getDefaultTokensState = (): TokensState => {\n  return {\n    tokens: [],\n    ignoredTokens: [],\n    detectedTokens: [],\n    allTokens: {},\n    allIgnoredTokens: {},\n    allDetectedTokens: {},\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseControllerV1<\n  TokensConfig,\n  TokensState & BaseState\n> {\n  private readonly mutex = new Mutex();\n\n  private abortController: AbortController;\n\n  private readonly messagingSystem: TokensControllerMessenger;\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  private async fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.config.chainId,\n        tokenAddress,\n        this.abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokensController';\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller messenger.\n   */\n  constructor({\n    chainId: initialChainId,\n    config,\n    state,\n    messenger,\n  }: {\n    chainId: Hex;\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n    messenger: TokensControllerMessenger;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      ...getDefaultTokensState(),\n      ...state,\n    };\n\n    this.initialize();\n    this.abortController = new AbortController();\n\n    this.messagingSystem = messenger;\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:addDetectedTokens` as const,\n      this.addDetectedTokens.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'PreferencesController:stateChange',\n      ({ selectedAddress }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { chainId } = this.config;\n        this.configure({ selectedAddress });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] ?? [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] ?? [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] ?? [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      ({ providerConfig }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { selectedAddress } = this.config;\n        const { chainId } = providerConfig;\n        this.abortController.abort();\n        this.abortController = new AbortController();\n        this.configure({ chainId });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] || [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'TokenListController:stateChange',\n      ({ tokenList }) => {\n        const { tokens } = this.state;\n        if (tokens.length && !tokens[0].name) {\n          this.updateTokensAttribute(tokenList, 'name');\n        }\n      },\n    );\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param options - The method argument object.\n   * @param options.address - Hex address of the token contract.\n   * @param options.symbol - Symbol of the token.\n   * @param options.decimals - Number of decimals the token uses.\n   * @param options.name - Name of the token.\n   * @param options.image - Image of the token.\n   * @param options.interactingAddress - The address of the account to add a token to.\n   * @param options.networkClientId - Network Client ID.\n   * @returns Current token list.\n   */\n  async addToken({\n    address,\n    symbol,\n    decimals,\n    name,\n    image,\n    interactingAddress,\n    networkClientId,\n  }: {\n    address: string;\n    symbol: string;\n    decimals: number;\n    name?: string;\n    image?: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<Token[]> {\n    const { chainId, selectedAddress } = this.config;\n    const releaseLock = await this.mutex.acquire();\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    let currentChainId = chainId;\n    if (networkClientId) {\n      currentChainId = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      ).configuration.chainId;\n    }\n\n    const accountAddress = interactingAddress || selectedAddress;\n    const isInteractingWithWalletAccount = accountAddress === selectedAddress;\n\n    try {\n      address = toChecksumHexAddress(address);\n      const tokens = allTokens[currentChainId]?.[accountAddress] || [];\n      const ignoredTokens =\n        allIgnoredTokens[currentChainId]?.[accountAddress] || [];\n      const detectedTokens =\n        allDetectedTokens[currentChainId]?.[accountAddress] || [];\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this._detectIsERC721(address, networkClientId),\n        // TODO parameterize the token metadata fetch by networkClientId\n        this.fetchTokenMetadata(address),\n      ]);\n      // TODO remove this once this method is fully parameterized by networkClientId\n      if (!networkClientId && currentChainId !== this.config.chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: currentChainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n        name,\n      };\n      const previousIndex = newTokens.findIndex(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousIndex !== -1) {\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: currentChainId,\n        });\n\n      let newState: Partial<TokensState> = {\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      };\n\n      // Only update active tokens if user is interacting with their active wallet account.\n      if (isInteractingWithWalletAccount) {\n        newState = {\n          ...newState,\n          tokens: newTokens,\n          ignoredTokens: newIgnoredTokens,\n          detectedTokens: newDetectedTokens,\n        };\n      }\n\n      this.update(newState);\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   * @param networkClientId - Optional network client ID used to determine interacting chain ID.\n   */\n  async addTokens(tokensToImport: Token[], networkClientId?: NetworkClientId) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, name } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          name,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      let interactingChainId;\n      if (networkClientId) {\n        interactingChainId = this.messagingSystem.call(\n          'NetworkController:getNetworkClientById',\n          networkClientId,\n        ).configuration.chainId;\n      }\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n          interactingChainId,\n        });\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n        ignoredTokens: newIgnoredTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this._getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update({\n      ignoredTokens: newIgnoredTokens,\n      tokens: newTokens,\n      detectedTokens: newDetectedTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      allDetectedTokens: newAllDetectedTokens,\n      allTokens: newAllTokens,\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: Hex },\n  ) {\n    const releaseLock = await this.mutex.acquire();\n\n    // Get existing tokens for the chain + account\n    const chainId = detectionDetails?.chainId ?? this.config.chainId;\n    const accountAddress =\n      detectionDetails?.selectedAddress ?? this.config.selectedAddress;\n\n    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;\n    let newTokens = [...(allTokens?.[chainId]?.[accountAddress] ?? [])];\n    let newDetectedTokens = [\n      ...(allDetectedTokens?.[chainId]?.[accountAddress] ?? []),\n    ];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const {\n          address,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          isERC721,\n          name,\n        } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n          name,\n        };\n        const previousImportedIndex = newTokens.findIndex(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedIndex !== -1) {\n          // Update existing data of imported token\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex =\n            allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ??\n            -1;\n\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedIndex = newDetectedTokens.findIndex(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedIndex !== -1) {\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: chainId,\n        },\n      );\n\n      // We may be detecting tokens on a different chain/account pair than are currently configured.\n      // Re-point `tokens` and `detectedTokens` to keep them referencing the current chain/account.\n      const { chainId: currentChain, selectedAddress: currentAddress } =\n        this.config;\n\n      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];\n      newDetectedTokens =\n        newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * This is a function that updates the tokens name for the tokens name if it is not defined.\n   *\n   * @param tokenList - Represents the fetched token list from service API\n   * @param tokenAttribute - Represents the token attribute that we want to update on the token list\n   */\n  private updateTokensAttribute(\n    tokenList: TokenListMap,\n    tokenAttribute: keyof Token & keyof TokenListToken,\n  ) {\n    const { tokens } = this.state;\n\n    const newTokens = tokens.map((token) => {\n      const newToken = tokenList[token.address.toLowerCase()];\n\n      return !token[tokenAttribute] && newToken?.[tokenAttribute]\n        ? { ...token, [tokenAttribute]: newToken[tokenAttribute] }\n        : { ...token };\n    });\n\n    this.update({ tokens: newTokens });\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @param networkClientId - Optional network client ID to fetch contract info with.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(\n    tokenAddress: string,\n    networkClientId?: NetworkClientId,\n  ) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      networkClientId,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  _getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    return new Web3Provider(\n      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released\n      networkClientId\n        ? this.messagingSystem.call(\n            'NetworkController:getNetworkClientById',\n            networkClientId,\n          ).provider\n        : this.config.provider,\n    );\n  }\n\n  _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    networkClientId?: NetworkClientId,\n  ): Contract {\n    const web3provider = this._getProvider(networkClientId);\n    const tokenContract = new Contract(tokenAddress, abi, web3provider);\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to the list of watched assets.\n   * Parameters will be validated according to the asset type being watched.\n   *\n   * @param options - The method options.\n   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param options.type - The asset type.\n   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.\n   * @param options.networkClientId - Network Client ID.\n   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.\n   */\n  async watchAsset({\n    asset,\n    type,\n    interactingAddress,\n    networkClientId,\n  }: {\n    asset: Token;\n    type: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<void> {\n    if (type !== ERC20) {\n      throw new Error(`Asset of type ${type} not supported`);\n    }\n\n    if (!asset.address) {\n      throw rpcErrors.invalidParams('Address must be specified');\n    }\n\n    if (!isValidHexAddress(asset.address)) {\n      throw rpcErrors.invalidParams(`Invalid address \"${asset.address}\"`);\n    }\n\n    // Validate contract\n\n    if (await this._detectIsERC721(asset.address, networkClientId)) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC721}`,\n      );\n    }\n\n    const provider = this._getProvider(networkClientId);\n    const isErc1155 = await safelyExecute(() =>\n      new ERC1155Standard(provider).contractSupportsBase1155Interface(\n        asset.address,\n      ),\n    );\n    if (isErc1155) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC1155}`,\n      );\n    }\n\n    const erc20 = new ERC20Standard(provider);\n    const [contractName, contractSymbol, contractDecimals] = await Promise.all([\n      safelyExecute(() => erc20.getTokenName(asset.address)),\n      safelyExecute(() => erc20.getTokenSymbol(asset.address)),\n      safelyExecute(async () => erc20.getTokenDecimals(asset.address)),\n    ]);\n\n    asset.name = contractName;\n\n    // Validate symbol\n\n    if (!asset.symbol && !contractSymbol) {\n      throw rpcErrors.invalidParams(\n        'A symbol is required, but was not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractSymbol !== undefined &&\n      asset.symbol !== undefined &&\n      asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()\n    ) {\n      throw rpcErrors.invalidParams(\n        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`,\n      );\n    }\n\n    asset.symbol = contractSymbol ?? asset.symbol;\n    if (typeof asset.symbol !== 'string') {\n      throw rpcErrors.invalidParams(`Invalid symbol: not a string`);\n    }\n\n    if (asset.symbol.length > 11) {\n      throw rpcErrors.invalidParams(\n        `Invalid symbol \"${asset.symbol}\": longer than 11 characters`,\n      );\n    }\n\n    // Validate decimals\n\n    if (asset.decimals === undefined && contractDecimals === undefined) {\n      throw rpcErrors.invalidParams(\n        'Decimals are required, but were not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractDecimals !== undefined &&\n      asset.decimals !== undefined &&\n      String(asset.decimals) !== contractDecimals\n    ) {\n      throw rpcErrors.invalidParams(\n        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`,\n      );\n    }\n\n    const decimalsStr = contractDecimals ?? asset.decimals;\n    const decimalsNum = parseInt(decimalsStr as unknown as string, 10);\n    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {\n      throw rpcErrors.invalidParams(\n        `Invalid decimals \"${decimalsStr}\": must be an integer 0 <= 36`,\n      );\n    }\n    asset.decimals = decimalsNum;\n\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      time: Date.now(),\n      type,\n      interactingAddress: interactingAddress || this.config.selectedAddress,\n    };\n\n    await this._requestApproval(suggestedAssetMeta);\n\n    const { address, symbol, decimals, name, image } = asset;\n    await this.addToken({\n      address,\n      symbol,\n      decimals,\n      name,\n      image,\n      interactingAddress: suggestedAssetMeta.interactingAddress,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.interactingAddress - The account address to use to store the tokens.\n   * @param params.interactingChainId - The chainId to use to store the tokens.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    interactingAddress?: string;\n    interactingChainId?: Hex;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      interactingAddress,\n      interactingChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n\n    const userAddressToAddTokens = interactingAddress ?? selectedAddress;\n    const chainIdToAddTokens = interactingChainId ?? chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n\n  async _requestApproval(suggestedAssetMeta: SuggestedAssetMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedAssetMeta.id,\n        origin: ORIGIN_METAMASK,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedAssetMeta.id,\n          interactingAddress: suggestedAssetMeta.interactingAddress,\n          asset: {\n            address: suggestedAssetMeta.asset.address,\n            decimals: suggestedAssetMeta.asset.decimals,\n            symbol: suggestedAssetMeta.asset.symbol,\n            image: suggestedAssetMeta.asset.image || null,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default TokensController;\n"]}