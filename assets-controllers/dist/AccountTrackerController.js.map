{"version":3,"file":"AccountTrackerController.js","sourceRoot":"","sources":["../src/AccountTrackerController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  BNToHex,\n  query,\n  safelyExecuteWithTimeout,\n} from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport type { Provider } from '@metamask/eth-query';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { assert } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { cloneDeep } from 'lodash';\n\n/**\n * @type AccountInformation\n *\n * Account information object\n * @property balance - Hex string of an account balancec in wei\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface AccountInformation {\n  balance: string;\n}\n\n/**\n * @type AccountTrackerConfig\n *\n * Account tracker controller configuration\n * @property provider - Provider used to create a new underlying EthQuery instance\n */\n// This interface was created before this ESLint rule was added.\n// Remove in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface AccountTrackerConfig extends BaseConfig {\n  interval: number;\n  provider?: Provider;\n}\n\n/**\n * @type AccountTrackerState\n *\n * Account tracker controller state\n * @property accounts - Map of addresses to account information\n */\n// This interface was created before this ESLint rule was added.\n// Remove in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface AccountTrackerState extends BaseState {\n  accounts: { [address: string]: AccountInformation };\n  accountsByChainId: Record<string, { [address: string]: AccountInformation }>;\n}\n\n/**\n * Controller that tracks the network balances for all user accounts.\n */\nexport class AccountTrackerController extends StaticIntervalPollingControllerV1<\n  AccountTrackerConfig,\n  AccountTrackerState\n> {\n  private _provider?: Provider;\n\n  private readonly refreshMutex = new Mutex();\n\n  private handle?: ReturnType<typeof setTimeout>;\n\n  private syncAccounts(newChainId: string) {\n    const accounts = { ...this.state.accounts };\n    const accountsByChainId = cloneDeep(this.state.accountsByChainId);\n\n    const existing = Object.keys(accounts);\n    if (!accountsByChainId[newChainId]) {\n      accountsByChainId[newChainId] = {};\n      existing.forEach((address) => {\n        accountsByChainId[newChainId][address] = { balance: '0x0' };\n      });\n    }\n\n    const addresses = Object.keys(this.getIdentities());\n    const newAddresses = addresses.filter(\n      (address) => !existing.includes(address),\n    );\n    const oldAddresses = existing.filter(\n      (address) => !addresses.includes(address),\n    );\n    newAddresses.forEach((address) => {\n      accounts[address] = { balance: '0x0' };\n    });\n    Object.keys(accountsByChainId).forEach((chainId) => {\n      newAddresses.forEach((address) => {\n        accountsByChainId[chainId][address] = {\n          balance: '0x0',\n        };\n      });\n    });\n\n    oldAddresses.forEach((address) => {\n      delete accounts[address];\n    });\n    Object.keys(accountsByChainId).forEach((chainId) => {\n      oldAddresses.forEach((address) => {\n        delete accountsByChainId[chainId][address];\n      });\n    });\n\n    this.update({ accounts, accountsByChainId });\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AccountTrackerController';\n\n  private readonly getIdentities: () => PreferencesState['identities'];\n\n  private readonly getSelectedAddress: () => PreferencesState['selectedAddress'];\n\n  private readonly getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n\n  private readonly getCurrentChainId: () => NetworkState['providerConfig']['chainId'];\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates an AccountTracker instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.getIdentities - Gets the identities from the Preferences store.\n   * @param options.getSelectedAddress - Gets the selected address from the Preferences store.\n   * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.\n   * @param options.getCurrentChainId - Gets the chain ID for the current network from the Network store.\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      getIdentities,\n      getSelectedAddress,\n      getMultiAccountBalancesEnabled,\n      getCurrentChainId,\n      getNetworkClientById,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      getIdentities: () => PreferencesState['identities'];\n      getSelectedAddress: () => PreferencesState['selectedAddress'];\n      getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n      getCurrentChainId: () => NetworkState['providerConfig']['chainId'];\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n    },\n    config?: Partial<AccountTrackerConfig>,\n    state?: Partial<AccountTrackerState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: 10000,\n    };\n    this.defaultState = {\n      accounts: {},\n      accountsByChainId: {\n        [getCurrentChainId()]: {},\n      },\n    };\n    this.initialize();\n    this.setIntervalLength(this.config.interval);\n    this.getIdentities = getIdentities;\n    this.getSelectedAddress = getSelectedAddress;\n    this.getMultiAccountBalancesEnabled = getMultiAccountBalancesEnabled;\n    this.getCurrentChainId = getCurrentChainId;\n    this.getNetworkClientById = getNetworkClientById;\n    onPreferencesStateChange(() => {\n      this.refresh();\n    });\n    this.poll();\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @param provider - Provider used to create a new underlying EthQuery instance.\n   */\n  set provider(provider: Provider) {\n    this._provider = provider;\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Resolves a networkClientId to a network client config\n   * or globally selected network config if not provided\n   *\n   * @param networkClientId - Optional networkClientId to fetch a network client with\n   * @returns network client config\n   */\n  #getCorrectNetworkClient(networkClientId?: NetworkClientId): {\n    chainId: string;\n    ethQuery?: EthQuery;\n  } {\n    if (networkClientId) {\n      const networkClient = this.getNetworkClientById(networkClientId);\n\n      return {\n        chainId: networkClient.configuration.chainId,\n        ethQuery: new EthQuery(networkClient.provider),\n      };\n    }\n\n    return {\n      chainId: this.getCurrentChainId(),\n      ethQuery: this._provider ? new EthQuery(this._provider) : undefined,\n    };\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - Polling interval trigger a 'refresh'.\n   */\n  async poll(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await this.refresh();\n    this.handle = setTimeout(() => {\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Refreshes the balances of the accounts using the networkClientId\n   *\n   * @param networkClientId - The network client ID used to get balances.\n   */\n  async _executePoll(networkClientId: string): Promise<void> {\n    this.refresh(networkClientId);\n  }\n\n  /**\n   * Refreshes the balances of the accounts depending on the multi-account setting.\n   * If multi-account is disabled, only updates the selected account balance.\n   * If multi-account is enabled, updates balances for all accounts.\n   *\n   * @param networkClientId - Optional networkClientId to fetch a network client with\n   */\n  refresh = async (networkClientId?: NetworkClientId) => {\n    const releaseLock = await this.refreshMutex.acquire();\n    try {\n      const { chainId, ethQuery } =\n        this.#getCorrectNetworkClient(networkClientId);\n      this.syncAccounts(chainId);\n      const { accounts, accountsByChainId } = this.state;\n      const isMultiAccountBalancesEnabled =\n        this.getMultiAccountBalancesEnabled();\n\n      const accountsToUpdate = isMultiAccountBalancesEnabled\n        ? Object.keys(accounts)\n        : [this.getSelectedAddress()];\n\n      const accountsForChain = { ...accountsByChainId[chainId] };\n      for (const address of accountsToUpdate) {\n        accountsForChain[address] = {\n          balance: BNToHex(await this.getBalanceFromChain(address, ethQuery)),\n        };\n      }\n\n      this.update({\n        ...(chainId === this.getCurrentChainId() && {\n          accounts: accountsForChain,\n        }),\n        accountsByChainId: {\n          ...this.state.accountsByChainId,\n          [chainId]: accountsForChain,\n        },\n      });\n    } catch (err) {\n      releaseLock();\n      throw err;\n    }\n  };\n\n  /**\n   * Fetches the balance of a given address from the blockchain.\n   *\n   * @param address - The account address to fetch the balance for.\n   * @param ethQuery - The EthQuery instance to query getBalnce with.\n   * @returns A promise that resolves to the balance in a hex string format.\n   */\n  private async getBalanceFromChain(\n    address: string,\n    ethQuery?: EthQuery,\n  ): Promise<string | undefined> {\n    return await safelyExecuteWithTimeout(async () => {\n      assert(ethQuery, 'Provider not set.');\n      return await query(ethQuery, 'getBalance', [address]);\n    });\n  }\n\n  /**\n   * Sync accounts balances with some additional addresses.\n   *\n   * @param addresses - the additional addresses, may be hardware wallet addresses.\n   * @param networkClientId - Optional networkClientId to fetch a network client with.\n   * @returns accounts - addresses with synced balance\n   */\n  async syncBalanceWithAddresses(\n    addresses: string[],\n    networkClientId?: NetworkClientId,\n  ): Promise<Record<string, { balance: string }>> {\n    const { ethQuery } = this.#getCorrectNetworkClient(networkClientId);\n\n    return await Promise.all(\n      addresses.map((address): Promise<[string, string] | undefined> => {\n        return safelyExecuteWithTimeout(async () => {\n          assert(ethQuery, 'Provider not set.');\n          const balance = await query(ethQuery, 'getBalance', [address]);\n          return [address, balance];\n        });\n      }),\n    ).then((value) => {\n      return value.reduce((obj, item) => {\n        if (!item) {\n          return obj;\n        }\n\n        const [address, balance] = item;\n        return {\n          ...obj,\n          [address]: {\n            balance,\n          },\n        };\n      }, {});\n    });\n  }\n}\n\nexport default AccountTrackerController;\n"]}