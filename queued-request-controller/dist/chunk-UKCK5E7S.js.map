{"version":3,"sources":["../src/QueuedRequestController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type {\n  NetworkControllerGetStateAction,\n  NetworkControllerSetActiveNetworkAction,\n} from '@metamask/network-controller';\nimport type { SelectedNetworkControllerGetNetworkClientIdForDomainAction } from '@metamask/selected-network-controller';\nimport { createDeferredPromise } from '@metamask/utils';\n\nimport type { QueuedRequestMiddlewareJsonRpcRequest } from './types';\n\nexport const controllerName = 'QueuedRequestController';\n\nexport type QueuedRequestControllerState = {\n  queuedRequestCount: number;\n};\n\nexport const QueuedRequestControllerActionTypes = {\n  enqueueRequest: `${controllerName}:enqueueRequest` as const,\n  getState: `${controllerName}:getState` as const,\n};\n\nexport type QueuedRequestControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  QueuedRequestControllerState\n>;\n\nexport type QueuedRequestControllerEnqueueRequestAction = {\n  type: typeof QueuedRequestControllerActionTypes.enqueueRequest;\n  handler: QueuedRequestController['enqueueRequest'];\n};\n\nexport const QueuedRequestControllerEventTypes = {\n  networkSwitched: `${controllerName}:networkSwitched` as const,\n  stateChange: `${controllerName}:stateChange` as const,\n};\n\nexport type QueuedRequestControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    QueuedRequestControllerState\n  >;\n\nexport type QueuedRequestControllerNetworkSwitched = {\n  type: typeof QueuedRequestControllerEventTypes.networkSwitched;\n  payload: [string];\n};\n\nexport type QueuedRequestControllerEvents =\n  | QueuedRequestControllerStateChangeEvent\n  | QueuedRequestControllerNetworkSwitched;\n\nexport type QueuedRequestControllerActions =\n  | QueuedRequestControllerGetStateAction\n  | QueuedRequestControllerEnqueueRequestAction;\n\nexport type AllowedActions =\n  | NetworkControllerGetStateAction\n  | NetworkControllerSetActiveNetworkAction\n  | SelectedNetworkControllerGetNetworkClientIdForDomainAction;\n\nexport type QueuedRequestControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  QueuedRequestControllerActions | AllowedActions,\n  QueuedRequestControllerEvents,\n  AllowedActions['type'],\n  never\n>;\n\nexport type QueuedRequestControllerOptions = {\n  messenger: QueuedRequestControllerMessenger;\n};\n\n/**\n * A queued request.\n */\ntype QueuedRequest = {\n  /**\n   * The origin of the queued request.\n   */\n  origin: string;\n  /**\n   * A callback used to continue processing the request, called when the request is dequeued.\n   */\n  processRequest: (error: unknown) => void;\n};\n\n/**\n * Queue requests for processing in batches, by request origin.\n *\n * Processing requests in batches allows us to completely separate sets of requests that originate\n * from different origins. This ensures that our UI will not display those requests as a set, which\n * could mislead users into thinking they are related.\n *\n * Queuing requests in batches also allows us to ensure the globally selected network matches the\n * dapp-selected network, before the confirmation UI is rendered. This is important because the\n * data shown on some confirmation screens is only collected for the globally selected network.\n *\n * Requests get processed in order of insertion, even across batches. All requests get processed\n * even in the event of preceding requests failing.\n */\nexport class QueuedRequestController extends BaseController<\n  typeof controllerName,\n  QueuedRequestControllerState,\n  QueuedRequestControllerMessenger\n> {\n  /**\n   * The origin of the current batch of requests being processed, or `undefined` if there are no\n   * requests currently being processed.\n   */\n  #originOfCurrentBatch: string | undefined;\n\n  /**\n   * The list of all queued requests, in chronological order.\n   */\n  #requestQueue: QueuedRequest[] = [];\n\n  /**\n   * The number of requests currently being processed.\n   *\n   * Note that this does not include queued requests, just those being actively processed (i.e.\n   * those in the \"current batch\").\n   */\n  #processingRequestCount = 0;\n\n  /**\n   * Construct a QueuedRequestController.\n   *\n   * @param options - Controller options.\n   * @param options.messenger - The restricted controller messenger that facilitates communication with other controllers.\n   */\n  constructor({ messenger }: QueuedRequestControllerOptions) {\n    super({\n      name: controllerName,\n      metadata: {\n        queuedRequestCount: {\n          anonymous: true,\n          persist: false,\n        },\n      },\n      messenger,\n      state: { queuedRequestCount: 0 },\n    });\n    this.#registerMessageHandlers();\n  }\n\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:enqueueRequest`,\n      this.enqueueRequest.bind(this),\n    );\n  }\n\n  /**\n   * Process the next batch of requests.\n   *\n   * This will trigger the next batch of requests with matching origins to be processed. Each\n   * request in the batch is dequeued one at a time, in chronological order, but they all get\n   * processed in parallel.\n   *\n   * This should be called after a batch of requests has finished processing, if the queue is non-\n   * empty.\n   */\n  async #processNextBatch() {\n    const firstRequest = this.#requestQueue.shift() as QueuedRequest;\n    this.#originOfCurrentBatch = firstRequest.origin;\n    const batch = [firstRequest.processRequest];\n    while (this.#requestQueue[0]?.origin === this.#originOfCurrentBatch) {\n      const nextEntry = this.#requestQueue.shift() as QueuedRequest;\n      batch.push(nextEntry.processRequest);\n    }\n\n    // If globally selected network is different from origin selected network,\n    // switch network before processing batch\n    let networkSwitchError: unknown;\n    try {\n      await this.#switchNetworkIfNecessary();\n    } catch (error: unknown) {\n      networkSwitchError = error;\n    }\n\n    for (const processRequest of batch) {\n      processRequest(networkSwitchError);\n    }\n    this.#updateQueuedRequestCount();\n  }\n\n  /**\n   * Switch the globally selected network client to match the network\n   * client of the current batch.\n   *\n   * @throws Throws an error if the current selected `networkClientId` or the\n   * `networkClientId` on the request are invalid.\n   */\n  async #switchNetworkIfNecessary() {\n    // This branch is unreachable; it's just here for type reasons.\n    /* istanbul ignore next */\n    if (!this.#originOfCurrentBatch) {\n      throw new Error('Current batch origin must be initialized first');\n    }\n    const originNetworkClientId = this.messagingSystem.call(\n      'SelectedNetworkController:getNetworkClientIdForDomain',\n      this.#originOfCurrentBatch,\n    );\n    const { selectedNetworkClientId } = this.messagingSystem.call(\n      'NetworkController:getState',\n    );\n    if (originNetworkClientId === selectedNetworkClientId) {\n      return;\n    }\n\n    await this.messagingSystem.call(\n      'NetworkController:setActiveNetwork',\n      originNetworkClientId,\n    );\n\n    this.messagingSystem.publish(\n      'QueuedRequestController:networkSwitched',\n      originNetworkClientId,\n    );\n  }\n\n  /**\n   * Update the queued request count.\n   */\n  #updateQueuedRequestCount() {\n    this.update((state) => {\n      state.queuedRequestCount = this.#requestQueue.length;\n    });\n  }\n\n  /**\n   * Enqueue a request to be processed in a batch with other requests from the same origin.\n   *\n   * We process requests one origin at a time, so that requests from different origins do not get\n   * interwoven, and so that we can ensure that the globally selected network matches the dapp-\n   * selected network.\n   *\n   * Requests get processed in order of insertion, even across origins/batches. All requests get\n   * processed even in the event of preceding requests failing.\n   *\n   * @param request - The JSON-RPC request to process.\n   * @param requestNext - A function representing the next steps for processing this request.\n   * @returns A promise that resolves when the given request has been fully processed.\n   */\n  async enqueueRequest(\n    request: QueuedRequestMiddlewareJsonRpcRequest,\n    requestNext: () => Promise<void>,\n  ): Promise<void> {\n    if (this.#originOfCurrentBatch === undefined) {\n      this.#originOfCurrentBatch = request.origin;\n    }\n\n    try {\n      // Queue request for later processing\n      // Network switch is handled when this batch is processed\n      if (\n        this.state.queuedRequestCount > 0 ||\n        this.#originOfCurrentBatch !== request.origin\n      ) {\n        const {\n          promise: waitForDequeue,\n          reject,\n          resolve,\n        } = createDeferredPromise({\n          suppressUnhandledRejection: true,\n        });\n        this.#requestQueue.push({\n          origin: request.origin,\n          processRequest: (error: unknown) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve();\n            }\n          },\n        });\n        this.#updateQueuedRequestCount();\n\n        await waitForDequeue;\n      } else if (request.method !== 'eth_requestAccounts') {\n        // Process request immediately\n        // Requires switching network now if necessary\n        // Note: we dont need to switch chain before processing eth_requestAccounts because accounts are not network-specific (at the time of writing)\n        await this.#switchNetworkIfNecessary();\n      }\n      this.#processingRequestCount += 1;\n      try {\n        await requestNext();\n      } finally {\n        this.#processingRequestCount -= 1;\n      }\n      return undefined;\n    } finally {\n      if (this.#processingRequestCount === 0) {\n        this.#originOfCurrentBatch = undefined;\n        if (this.#requestQueue.length > 0) {\n          // The next batch is triggered here. We intentionally omit the `await` because we don't\n          // want the next batch to block resolution of the current request.\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          this.#processNextBatch();\n        }\n      }\n    }\n  }\n}\n"]}