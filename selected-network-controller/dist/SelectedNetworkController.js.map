{"version":3,"file":"SelectedNetworkController.js","sourceRoot":"","sources":["../src/SelectedNetworkController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type {\n  BlockTrackerProxy,\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerGetStateAction,\n  NetworkControllerStateChangeEvent,\n  ProviderProxy,\n} from '@metamask/network-controller';\nimport type {\n  PermissionControllerStateChange,\n  GetSubjects as PermissionControllerGetSubjectsAction,\n  HasPermissions as PermissionControllerHasPermissions,\n} from '@metamask/permission-controller';\nimport { createEventEmitterProxy } from '@metamask/swappable-obj-proxy';\nimport type { Patch } from 'immer';\n\nexport const controllerName = 'SelectedNetworkController';\n\nconst stateMetadata = {\n  domains: { persist: true, anonymous: false },\n};\n\nconst getDefaultState = () => ({ domains: {} });\n\ntype Domain = string;\n\nexport const METAMASK_DOMAIN = 'metamask' as const;\n\nexport const SelectedNetworkControllerActionTypes = {\n  getState: `${controllerName}:getState` as const,\n  getNetworkClientIdForDomain:\n    `${controllerName}:getNetworkClientIdForDomain` as const,\n  setNetworkClientIdForDomain:\n    `${controllerName}:setNetworkClientIdForDomain` as const,\n};\n\nexport const SelectedNetworkControllerEventTypes = {\n  stateChange: `${controllerName}:stateChange` as const,\n};\n\nexport type SelectedNetworkControllerState = {\n  domains: Record<Domain, NetworkClientId>;\n};\n\nexport type SelectedNetworkControllerStateChangeEvent = {\n  type: typeof SelectedNetworkControllerEventTypes.stateChange;\n  payload: [SelectedNetworkControllerState, Patch[]];\n};\n\nexport type SelectedNetworkControllerGetSelectedNetworkStateAction = {\n  type: typeof SelectedNetworkControllerActionTypes.getState;\n  handler: () => SelectedNetworkControllerState;\n};\n\nexport type SelectedNetworkControllerGetNetworkClientIdForDomainAction = {\n  type: typeof SelectedNetworkControllerActionTypes.getNetworkClientIdForDomain;\n  handler: SelectedNetworkController['getNetworkClientIdForDomain'];\n};\n\nexport type SelectedNetworkControllerSetNetworkClientIdForDomainAction = {\n  type: typeof SelectedNetworkControllerActionTypes.setNetworkClientIdForDomain;\n  handler: SelectedNetworkController['setNetworkClientIdForDomain'];\n};\n\nexport type SelectedNetworkControllerActions =\n  | SelectedNetworkControllerGetSelectedNetworkStateAction\n  | SelectedNetworkControllerGetNetworkClientIdForDomainAction\n  | SelectedNetworkControllerSetNetworkClientIdForDomainAction;\n\nexport type AllowedActions =\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetStateAction\n  | PermissionControllerHasPermissions\n  | PermissionControllerGetSubjectsAction;\n\nexport type SelectedNetworkControllerEvents =\n  SelectedNetworkControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | NetworkControllerStateChangeEvent\n  | PermissionControllerStateChange;\n\nexport type SelectedNetworkControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  SelectedNetworkControllerActions | AllowedActions,\n  SelectedNetworkControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport type GetUseRequestQueue = () => boolean;\n\nexport type SelectedNetworkControllerOptions = {\n  state?: SelectedNetworkControllerState;\n  messenger: SelectedNetworkControllerMessenger;\n  getUseRequestQueue: GetUseRequestQueue;\n};\n\nexport type NetworkProxy = {\n  provider: ProviderProxy;\n  blockTracker: BlockTrackerProxy;\n};\n\n/**\n * Controller for getting and setting the network for a particular domain.\n */\nexport class SelectedNetworkController extends BaseController<\n  typeof controllerName,\n  SelectedNetworkControllerState,\n  SelectedNetworkControllerMessenger\n> {\n  #proxies = new Map<Domain, NetworkProxy>();\n\n  #getUseRequestQueue: GetUseRequestQueue;\n\n  /**\n   * Construct a SelectedNetworkController controller.\n   *\n   * @param options - The controller options.\n   * @param options.messenger - The restricted controller messenger for the EncryptionPublicKey controller.\n   * @param options.state - The controllers initial state.\n   * @param options.getUseRequestQueue - feature flag for perDappNetwork & request queueing features\n   */\n  constructor({\n    messenger,\n    state = getDefaultState(),\n    getUseRequestQueue,\n  }: SelectedNetworkControllerOptions) {\n    super({\n      name: controllerName,\n      metadata: stateMetadata,\n      messenger,\n      state,\n    });\n    this.#getUseRequestQueue = getUseRequestQueue;\n    this.#registerMessageHandlers();\n\n    // this is fetching all the dapp permissions from the PermissionsController and looking for any domains that are not in domains state in this controller. Then we take any missing domains and add them to state here, setting it with the globally selected networkClientId (fetched from the NetworkController)\n    this.messagingSystem\n      .call('PermissionController:getSubjectNames')\n      .filter((domain) => this.state.domains[domain] === undefined)\n      .forEach((domain) =>\n        this.setNetworkClientIdForDomain(\n          domain,\n          this.messagingSystem.call('NetworkController:getState')\n            .selectedNetworkClientId,\n        ),\n      );\n\n    this.messagingSystem.subscribe(\n      'PermissionController:stateChange',\n      (_, patches) => {\n        patches.forEach(({ op, path }) => {\n          const isChangingSubject =\n            path[0] === 'subjects' && path[1] !== undefined;\n          if (isChangingSubject && typeof path[1] === 'string') {\n            const domain = path[1];\n            if (op === 'add' && this.state.domains[domain] === undefined) {\n              this.setNetworkClientIdForDomain(\n                domain,\n                this.messagingSystem.call('NetworkController:getState')\n                  .selectedNetworkClientId,\n              );\n            } else if (\n              op === 'remove' &&\n              this.state.domains[domain] !== undefined\n            ) {\n              this.update(({ domains }) => {\n                delete domains[domain];\n              });\n            }\n          }\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:stateChange',\n      ({ selectedNetworkClientId }, patches) => {\n        patches.forEach(({ op, path }) => {\n          // if a network is removed, update the networkClientId for all domains that were using it to the selected network\n          if (op === 'remove' && path[0] === 'networkConfigurations') {\n            const removedNetworkClientId = path[1] as NetworkClientId;\n            Object.entries(this.state.domains).forEach(\n              ([domain, networkClientIdForDomain]) => {\n                if (networkClientIdForDomain === removedNetworkClientId) {\n                  this.setNetworkClientIdForDomain(\n                    domain,\n                    selectedNetworkClientId,\n                  );\n                }\n              },\n            );\n          }\n        });\n      },\n    );\n  }\n\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      SelectedNetworkControllerActionTypes.getNetworkClientIdForDomain,\n      this.getNetworkClientIdForDomain.bind(this),\n    );\n    this.messagingSystem.registerActionHandler(\n      SelectedNetworkControllerActionTypes.setNetworkClientIdForDomain,\n      this.setNetworkClientIdForDomain.bind(this),\n    );\n  }\n\n  #setNetworkClientIdForDomain(\n    domain: Domain,\n    networkClientId: NetworkClientId,\n  ) {\n    const networkClient = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      networkClientId,\n    );\n    const networkProxy = this.#proxies.get(domain);\n    if (networkProxy === undefined) {\n      this.#proxies.set(domain, {\n        provider: createEventEmitterProxy(networkClient.provider),\n        blockTracker: createEventEmitterProxy(networkClient.blockTracker, {\n          eventFilter: 'skipInternal',\n        }),\n      });\n    } else {\n      networkProxy.provider.setTarget(networkClient.provider);\n      networkProxy.blockTracker.setTarget(networkClient.blockTracker);\n    }\n\n    this.update((state) => {\n      state.domains[domain] = networkClientId;\n    });\n  }\n\n  #domainHasPermissions(domain: Domain): boolean {\n    return this.messagingSystem.call(\n      'PermissionController:hasPermissions',\n      domain,\n    );\n  }\n\n  setNetworkClientIdForDomain(\n    domain: Domain,\n    networkClientId: NetworkClientId,\n  ) {\n    if (domain === METAMASK_DOMAIN) {\n      throw new Error(\n        `NetworkClientId for domain \"${METAMASK_DOMAIN}\" cannot be set on the SelectedNetworkController`,\n      );\n    }\n\n    if (!this.#domainHasPermissions(domain)) {\n      throw new Error(\n        'NetworkClientId for domain cannot be called with a domain that has not yet been granted permissions',\n      );\n    }\n\n    this.#setNetworkClientIdForDomain(domain, networkClientId);\n  }\n\n  getNetworkClientIdForDomain(domain: Domain): NetworkClientId {\n    const { selectedNetworkClientId: metamaskSelectedNetworkClientId } =\n      this.messagingSystem.call('NetworkController:getState');\n    if (!this.#getUseRequestQueue()) {\n      return metamaskSelectedNetworkClientId;\n    }\n    return this.state.domains[domain] ?? metamaskSelectedNetworkClientId;\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @param domain - the domain for the provider\n   * @returns The proxy and block tracker proxies.\n   */\n  getProviderAndBlockTracker(domain: Domain): NetworkProxy {\n    if (!this.#getUseRequestQueue()) {\n      throw new Error(\n        'Provider and BlockTracker should be fetched from NetworkController when useRequestQueue is false',\n      );\n    }\n    const networkClientId = this.state.domains[domain];\n    if (!networkClientId) {\n      throw new Error(\n        'NetworkClientId has not been set for the requested domain',\n      );\n    }\n    let networkProxy = this.#proxies.get(domain);\n    if (networkProxy === undefined) {\n      const networkClient = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n      networkProxy = {\n        provider: createEventEmitterProxy(networkClient.provider),\n        blockTracker: createEventEmitterProxy(networkClient.blockTracker, {\n          eventFilter: 'skipInternal',\n        }),\n      };\n      this.#proxies.set(domain, networkProxy);\n    }\n\n    return networkProxy;\n  }\n}\n"]}